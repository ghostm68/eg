
<!DOCTYPE html>
<html>
    
    <head><base href="https://wordstar-online.com/">
        <meta charset="UTF-8">
        <meta name="keywords" content="typewriter, writing, retro, vintage, text editor, AI, generative, creative writing">
        <meta name="description" content="Experience the nostalgia of a classic typewriter with Wordstar, a web-based app that combines vintage aesthetics with modern AI-powered writing tools. Generate creative text, experiment with different writing styles, and rediscover the joy of putting words on paper (virtually!).">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>WordStar Nexus - Modern Text Editor</title><style>

<!DOCTYPE html><html><head><base href="https://wordstar-online.com/"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>WordStar Online - Modern Text Editor</title><style>
    body, html {
        height: 100%;
        margin: 0;
        font-family: Arial, sans-serif;
        background-color: #2d2d2d;
        color: #f0f0f0;
    }
    .container {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    #toolbar {
        background-color: #1e1e1e;
        padding: 10px;
        display: flex;
        justify-content: space-between;
    }
    #editor {
        flex-grow: 1;
        padding: 20px;
        font-size: 16px;
        line-height: 1.6;
        background-color: #1e1e1e;
        color: #f0f0f0;
        border: none;
        resize: none;
    }
    #statusbar {
        background-color: #cc0000;
        color: white;
        padding: 5px 10px;
        font-size: 14px;
    }
    button {
        background-color: #cc0000;
        color: white;
        border: none;
        padding: 5px 10px;
        margin-right: 5px;
        cursor: pointer;
    }
    button:hover {
        background-color: #990000;
    }
    #dictionary-select {
        margin-right: 10px;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
</head>
<body>
<div class="container">
    <div id="toolbar">
    <div>
    <button onclick="newDocument()" style="background-color: #cc0000;">New</button>
    <button onclick="saveDocument()" style="background-color: #cc0000;">Save</button>
    <button onclick="exportTxt()" style="background-color: #cc0000;">Export TXT</button>
    <button onclick="exportRtf()" style="background-color: #cc0000;">Export RTF</button>
    <button onclick="exportPdf()" style="background-color: #cc0000;">Export PDF</button>
    <button onclick="insertPoeticParagraph()" style="background-color: #cc0000;">Insert Random Poetic Paragraph</button>
    <button onclick="insertRandomScientificWord()" style="background-color: #cc0000;">Random Word</button>
</div>
    <div>
</div>
    <div id="notebook" style="background-color: #cc0000; padding: 10px; border-radius: 5px; margin-left: 10px;">
        <textarea id="notebookText" rows="3" style="width: 200px; background-color: #cc0000; color: black; border: 1px solid black; padding: 5px;" placeholder="Write your note here..."></textarea>
        <div>
            <button onclick="saveNote()" style="background-color: black; color: #cc0000; border: none; padding: 5px 10px; margin-top: 5px; cursor: pointer;">Save Note</button>
            <button onclick="insertNote()" style="background-color: black; color: #cc0000; border: none; padding: 5px 10px; margin-top: 5px; cursor: pointer;">Insert Note</button>
        </div>
    </div>
</div>
    <div id="editor" style="display: flex; justify-content: space-between;">
    <div id="ace-editor" style="width: 100%; height: 100%;"></div>
    <div style="width: 18%; display: flex; flex-direction: column;">
        <div>
    <select id="ai-model-select" style="width: 100%; padding: 5px; margin-bottom: 5px;">
    <option value="gpt2">GPT-2</option>
    <option value="bert">BERT</option>
    <option value="t5">T5</option>
    <option value="roberta">RoBERTa</option>
    <option value="xlnet">XLNet</option>
    <option value="elmo">ELMo</option>
    <option value="distilbert">DistilBERT</option>
    <option value="albert">ALBERT</option>
    <option value="electra">ELECTRA</option>
    <option value="markov">Markov Chain</option>
    <option value="wordassociation">Word Association</option>
    <option value="randomsentence">Random Sentence Generator</option>
    <option value="gpt-neo">GPT-Neo</option>
    <option value="gpt-j">GPT-J</option>
    <option value="bloom">BLOOM</option>
    <option value="opt">OPT</option>
    <option value="llama">LLaMA</option>
    <option value="tensorflow">TensorFlow</option>
    <option value="pytorch">PyTorch</option>
    <option value="huggingface">Hugging Face Transformers</option>
    <option value="gemma-2b">Gemma 2B</option>
    <option value="gemma-7b">Gemma 7B</option>
    <option value="palm">PaLM</option>
    <option value="bard">Bard</option>
</select>
    <textarea id="ai-prompt" placeholder="Enter your prompt here" style="width: 100%; padding: 5px; margin-bottom: 5px; height: 60px;"></textarea>
    <button onclick="generateText()" style="width: 100%; background-color: #cc0000; color: white; border: none; padding: 5px 10px; cursor: pointer; font-size: 12px;">Create Text</button>
</div>
        <div id="dictionary-results" style="flex-grow: 1; overflow-y: auto; background-color: #2d2d2d; padding: 10px; border: 1px solid #444; font-size: 12px;">
    <div id="word-info" style="display: none;">
        <h3 id="word-title" style="color: #cc0000; margin-bottom: 10px;"></h3>
        <div id="word-definition" style="margin-bottom: 10px;"></div>
        <div id="word-etymology" style="margin-bottom: 10px; font-style: italic;"></div>
        <div id="word-thesaurus">
            <h4 style="color: #cc0000; margin-bottom: 5px;">Synonyms:</h4>
            <ul id="word-synonyms" style="list-style-type: none; padding-left: 0;"></ul>
        </div>
    </div>
    <div id="ai-response" style="white-space: pre-wrap;">To use the text generation feature:

1. Choose a language model from the dropdown menu.
2. Enter a prompt in the text area.
3. Click the "Create Text" button.

The text will be generated based on your input and the selected model. Here's a brief overview of the working models:

1. Markov Chain: Generates text based on statistical patterns from a predefined dataset.
2. Word Association: Creates text by following word associations from a custom dictionary.
3. Random Sentence Generator: Constructs simple sentences using predefined components.

These models will generate more than just repeating the prompt. Here's what to expect:

- Markov Chain: Produces a sequence of words based on probabilistic transitions.
- Word Association: Expands on the prompt by following associated words.
- Random Sentence Generator: Creates a completely new sentence each time.

The other AI models listed are currently offline simulations. In a full implementation, they would connect to more sophisticated language models.

Try different prompts and models to see varied results. The generated text will appear here after you click "Create Text".</div>
</div>
    </div>
</div>
    <div id="statusbar" style="background-color: #cc0000; display: flex; justify-content: space-between; align-items: center;">
    <span>WordStar Online - Ready</span>
    <span id="word-count" style="font-size: 12px;">Words: 0</span>
    <span style="font-size: 12px;">Â© MMXXIV www.inkrealm.info</span>
</div>
</div>

<script>
    let editor;
    let aiEngines = {
        "gpt2": "GPT-2 (Offline)",
        "bert": "BERT (Offline)",
        "t5": "T5 (Offline)",
        "roberta": "RoBERTa (Offline)",
        "xlnet": "XLNet (Offline)",
        "elmo": "ELMo (Offline)",
        "distilbert": "DistilBERT (Offline)",
        "albert": "ALBERT (Offline)",
        "electra": "ELECTRA (Offline)",
        "markov": "Markov Chain",
        "wordassociation": "Word Association",
        "randomsentence": "Random Sentence Generator",
        "gpt-neo": "GPT-Neo (Offline)",
        "gpt-j": "GPT-J (Offline)",
        "bloom": "BLOOM (Offline)",
        "opt": "OPT (Offline)",
        "llama": "LLaMA (Offline)",
        "tensorflow": "TensorFlow (Offline)",
        "pytorch": "PyTorch (Offline)",
        "huggingface": "Hugging Face Transformers (Offline)",
        "gemma-2b": "Gemma 2B (Offline)",
        "gemma-7b": "Gemma 7B (Offline)",
        "palm": "PaLM (Offline)",
        "bard": "Bard (Offline)"
    };

    // Word associations for the Word Association generator
    const wordAssociations = {
        "sun": ["bright", "warm", "yellow", "sky", "summer"],
        "moon": ["night", "stars", "crescent", "lunar", "glow"],
        "tree": ["leaves", "branches", "forest", "green", "nature"],
        "water": ["ocean", "river", "blue", "liquid", "flow"],
        "fire": ["hot", "flame", "burn", "red", "smoke"]
    };

    // Expanded Markov chain data structure
    const markovChain = {
        "the": ["cat", "dog", "sun", "moon", "tree", "river", "mountain", "city", "book", "computer"],
        "cat": ["is", "sleeps", "meows", "purrs", "stretches", "jumps", "plays", "hunts", "naps", "scratches"],
        "dog": ["barks", "runs", "plays", "fetches", "wags", "sniffs", "chases", "guards", "obeys", "drools"],
        "sun": ["shines", "sets", "rises", "warms", "illuminates", "brightens", "scorches", "dazzles", "glows", "beams"],
        "moon": ["glows", "wanes", "waxes", "rises", "sets", "illuminates", "orbits", "reflects", "inspires", "changes"],
        "tree": ["grows", "sways", "blooms", "sheds", "provides", "reaches", "stands", "rustles", "shades", "photosynthesizes"],
        "river": ["flows", "meanders", "rushes", "erodes", "floods", "nourishes", "carries", "reflects", "babbles", "surges"],
        "mountain": ["towers", "looms", "challenges", "inspires", "protects", "erodes", "stands", "rises", "dominates", "beckons"],
        "city": ["bustles", "grows", "thrives", "expands", "evolves", "glows", "sleeps", "awakens", "pulsates", "changes"],
        "book": ["informs", "entertains", "inspires", "educates", "captivates", "challenges", "enlightens", "provokes", "comforts", "transports"],
        "computer": ["calculates", "processes", "stores", "displays", "connects", "analyzes", "assists", "learns", "crashes", "updates"],
        "is": ["sleeping", "running", "shining", "growing", "flowing", "towering", "bustling", "informing", "calculating", "changing"],
        "sleeps": ["on", "under", "beside", "peacefully", "soundly", "fitfully", "deeply", "lightly", "briefly", "comfortably"],
        "meows": ["loudly", "softly", "at", "persistently", "melodiously", "plaintively", "happily", "angrily", "hungrily", "sleepily"],
        "barks": ["at", "loudly", "excitedly", "fiercely", "playfully", "warningly", "joyfully", "continuously", "suddenly", "softly"],
        "shines": ["brightly", "warmly", "through", "upon", "brilliantly", "softly", "steadily", "dimly", "radiantly", "gloriously"],
        "flows": ["swiftly", "gently", "steadily", "turbulently", "peacefully", "rapidly", "slowly", "smoothly", "powerfully", "endlessly"],
        "towers": ["above", "majestically", "imposingly", "steadily", "silently", "menacingly", "protectively", "grandly", "solidly", "impressively"],
        "bustles": ["with", "energetically", "chaotically", "vibrantly", "noisily", "excitedly", "constantly", "hurriedly", "busily", "frenetically"],
        "informs": ["clearly", "concisely", "thoroughly", "accurately", "effectively", "engagingly", "objectively", "comprehensively", "succinctly", "reliably"],
        "calculates": ["rapidly", "accurately", "efficiently", "tirelessly", "precisely", "instantly", "continuously", "reliably", "automatically", "systematically"]
    };

    window.onload = function() {
        editor = ace.edit("ace-editor");
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/text");
        editor.setOptions({
            fontSize: "14pt",
            wrap: true,
            printMargin: false
        });
        
        // Ensure the Ace editor resizes correctly
        editor.resize();

        // Update status bar to reflect offline status
        updateStatusBar("WordStar Online - Ready");

        // Add event listener for word count update
        editor.getSession().on('change', updateWordCount);

        // Initial word count update
        updateWordCount();
    }

    function updateWordCount() {
        const text = editor.getValue();
        const wordCount = text.trim().split(/\s+/).length;
        document.getElementById('word-count').textContent = `Words: ${wordCount}`;
    }

    function newDocument() {
        editor.setValue("");
        updateStatusBar("New document created");
        updateWordCount();
    }

    function saveDocument() {
        const content = editor.getValue();
        const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "document.txt";
        link.click();
        URL.revokeObjectURL(url);
        updateStatusBar("Document saved");
    }

    function exportTxt() {
        const content = editor.getValue();
        const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "document.txt";
        link.click();
        URL.revokeObjectURL(url);
        updateStatusBar("Document exported as TXT");
    }

    function exportRtf() {
        const content = editor.getValue();
        const rtfContent = `{\\rtf1\\ansi\\deff0\n${content.replace(/\n/g, "\\par\n")}\n}`;
        const blob = new Blob([rtfContent], {type: "application/rtf"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "document.rtf";
        link.click();
        URL.revokeObjectURL(url);
        updateStatusBar("Document exported as RTF");
    }

    function exportPdf() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const content = editor.getValue();
        doc.text(content, 10, 10);
        doc.save("document.pdf");
        updateStatusBar("Document exported as PDF");
    }

    function insertRandomScientificWord() {
        const scientificWords = [
            "Mitochondria", "Photosynthesis", "Quantum entanglement", "Cytoplasm", "Neurotransmitter",
            "Thermodynamics", "Genome sequencing", "Electromagnetism", "Cellular respiration", "Higgs boson",
            "Relativity", "Plate tectonics", "Superconductivity", "Chromatography", "Nucleosynthesis",
            "Homeostasis", "Endocytosis", "Gravitational waves", "Electrophoresis", "Nanotechnology"
        ];
        
        const randomWord = scientificWords[Math.floor(Math.random() * scientificWords.length)];
        editor.insert(randomWord + " ");
        updateStatusBar("Inserted scientific term: " + randomWord);
        updateWordCount();
    }

    function generateText() {
        const selectedModel = document.getElementById("ai-model-select").value;
        const prompt = document.getElementById("ai-prompt").value;
        
        let generatedText;
        
        switch(selectedModel) {
            case "markov":
                generatedText = generateMarkovText(prompt);
                break;
            case "wordassociation":
                generatedText = generateWordAssociationText(prompt);
                break;
            case "randomsentence":
                generatedText = generateRandomSentence();
                break;
            default:
                generatedText = simulateAIGeneration(selectedModel, prompt);
        }
        
        // Display the generated text in the former search result box
        const aiResponseElement = document.getElementById("ai-response");
        aiResponseElement.textContent = generatedText;
        
        updateStatusBar(`Text created using ${aiEngines[selectedModel]}`);
    }

    function generateMarkovText(prompt) {
        let words = prompt.split(" ");
        if (words.length === 0 || !markovChain[words[words.length - 1]]) {
            words = ["the"];
        }
        let result = words.join(" ");
        for (let i = 0; i < 30; i++) {
            let lastWord = words[words.length - 1].toLowerCase();
            let nextWords = markovChain[lastWord];
            if (!nextWords) break;
            let nextWord = nextWords[Math.floor(Math.random() * nextWords.length)];
            result += " " + nextWord;
            words.push(nextWord);
        }
        return result;
    }

    function generateWordAssociationText(prompt) {
        let words = prompt.split(" ");
        let result = prompt;
        for (let i = 0; i < 10; i++) {
            let lastWord = words[words.length - 1].toLowerCase();
            let associations = wordAssociations[lastWord];
            if (!associations) break;
            let nextWord = associations[Math.floor(Math.random() * associations.length)];
            result += " " + nextWord;
            words.push(nextWord);
        }
        return result;
    }

    function generateRandomSentence() {
        const subjects = ["The cat", "A dog", "The sun", "The moon", "A tree", "The river", "The mountain", "The city", "The book", "The computer"];
        const verbs = ["jumps", "shines", "barks", "grows", "glows", "flows", "towers", "bustles", "informs", "calculates"];
        const objects = ["over the fence", "in the sky", "at the mailman", "in the forest", "through the night", "down the valley", "above the clouds", "with excitement", "the reader", "complex data"];
        
        const subject = subjects[Math.floor(Math.random() * subjects.length)];
        const verb = verbs[Math.floor(Math.random() * verbs.length)];
        const object = objects[Math.floor(Math.random() * objects.length)];
        
        return `${subject} ${verb} ${object}.`;
    }

    function simulateAIGeneration(model, prompt) {
        // This is a simple simulation. In a real implementation, you would call an API here.
        const responses = {
            "gpt2": "GPT-2 generated text based on: ",
            "bert": "BERT analysis result: ",
            "t5": "T5 transformation output: ",
            "roberta": "RoBERTa's interpretation: ",
            "xlnet": "XLNet's generated sequence: ",
            "elmo": "ELMo's contextual representation: ",
            "distilbert": "DistilBERT's efficient output: ",
            "albert": "ALBERT's response: ",
            "electra": "ELECTRA's discriminative output: ",
            "gpt-neo": "GPT-Neo's generated content: ",
            "gpt-j": "GPT-J's creative output: ",
            "bloom": "BLOOM's multilingual response: ",
            "opt": "OPT's optimized text: ",
            "llama": "LLaMA's language model output: ",
            "tensorflow": "TensorFlow's processed result: ",
            "pytorch": "PyTorch's neural network output: ",
            "huggingface": "Hugging Face Transformers' generated text: ",
            "gemma-2b": "Gemma 2B's concise response: ",
            "gemma-7b": "Gemma 7B's more detailed output: ",
            "palm": "PaLM's large language model response: ",
            "bard": "Bard's AI-generated content: "
        };

        return responses[model] + prompt + "\n\nThis is a simulated response. In a real implementation, this would be generated by the AI model.\n\n";
    }

    function updateStatusBar(message) {
        const statusBarSpan = document.querySelector("#statusbar span:first-child");
        if (statusBarSpan) {
            statusBarSpan.textContent = message;
        }
    }

    function insertPoeticParagraph() {
        const poeticParagraphs = [
                 "Neon rain on chrome streets, slick and bright,\nReflects the city's restless, electric night.\nHolographic ghosts flicker in the haze,\nWhile data streams through digital pathways.\nA lone hacker, hunched in flickering glow,\nWeaves through code, where secrets darkly flow.",

"Binary whispers of forgotten gods,\nResonate through fiber optic rods.\nData fragments, like myths from ages past,\nIn virtual realms, their echoes forever cast.\nAthena's wisdom, encoded in the core,\nWhile Ares' fury rages in the network war.",

"Underneath the concrete, roots of Yggdrasil,\nReach deep into the earth, where ancient spirits still,\nWhisper tales of realms beyond our sight,\nOf Asgard's glory, and Valhalla's light.\nThe world tree branches, in digital disguise,\nConnect us to the cosmos, through the wired skies.",

"Silicon and gold, an alchemic blend,\nWhere modern magic and ancient lore transcend.\nCircuits hum with life, a digital spark,\nAs electrons dance, within the coded dark.\nTransmutation of data, a modern art,\nWithin the microcosm of the silicon heart.",

"The Sphinx's riddle, hidden in the code,\nA quantum labyrinth, where secrets are bestowed.\nIn superposition, possibilities entwine,\nAs reality unravels, on the quantum line.\nWho are we, in this digital age?\nThe answer lies within, on the coded page.",

"Whispers of the wind, through autumn leaves,\nCarry tales of time, that memory weaves.\nIn golden light, and shadows long,\nNature composes her twilight song.\nAs day surrenders to starry night,\nWe ponder life's beauty, fleeting and bright.",

"Moonlit waves caress the shore,\nEchoing secrets from days of yore.\nSilver sands stretch far and wide,\nWhere dreams and reality collide.\nIn this moment, between earth and sky,\nWe glimpse eternity passing by.",

"Amidst the urban jungle's roar,\nA flower breaks through concrete floor.\nResilience in vibrant hue,\nReminding us what life can do.\nIn chaos, beauty finds its way,\nA testament to brighter day.",

"Mountains touch the azure sky,\nWhere eagles soar and spirits fly.\nAncient peaks, with wisdom old,\nStand sentinel o'er stories untold.\nIn their presence, we are small,\nYet part of something grand and tall.",

"Through fields of gold and emerald green,\nA river winds, its path unseen.\nReflecting clouds and summer's glow,\nIt carries life where'er it flows.\nIn its journey to the sea,\nWe see our own life's odyssey.",

"Through swirling mists of time and space,\nThe ancients whisper, leave their trace.\nIn runes and glyphs, a hidden lore,\nThey speak of powers we explore.\nIn starlight, myths and legends blend,\nAnd guide us to the journey's end.",

"Beneath the city's neon gleam,\nA hidden river flows, a silent stream.\nIt carries secrets, dark and deep,\nOf lives lived, and promises to keep.\nIn its depths, reflections shimmer bright,\nA glimpse of truth in the urban night.",

"The desert wind whispers tales untold,\nOf forgotten empires, brave and bold.\nSands shift and swirl, a timeless dance,\nBeneath a sky, vast and expanse.\nIn solitude, we find our way,\nAnd listen to the whispers of the day.",

"Across the void, a distant star,\nShines brightly, though incredibly far.\nA beacon of hope, in darkest night,\nA reminder that there's still some light.\nIn its gaze, we feel so small,\nYet connected to the cosmic sprawl.",

"The forest murmurs, ancient and wise,\nBeneath a canopy of emerald skies.\nSunlight filters through the leaves so green,\nIlluminating secrets yet unseen.\nIn its embrace, we find our peace,\nAnd feel the cycle of life's release.",

"On wings of dreams, we take to flight,\nSoaring through the starlit night.\nAcross the moon, and through the clouds,\nWe chase the whispers, soft and loud.\nIn slumber's realm, we find our truth,\nAnd wake renewed, with endless youth.",

"In depths of ocean, mysteries lie,\nWhere creatures swim, and currents fly.\nA world unseen, yet teeming with life,\nA symphony of silence, and of strife.\nWe dive deep, to explore the unknown,\nAnd find the wonders that the sea has sown.",

"The city sleeps, beneath a blanket of stars,\nWhile dreams ignite, and hopes unfurl like scars.\nA canvas painted with lights so bright,\nA symphony of shadows, in the fading light.\nWe wander streets, in quiet contemplation,\nAnd find the beauty in urban transformation."
        ];
        const randomParagraph = poeticParagraphs[Math.floor(Math.random() * poeticParagraphs.length)] + '\n\n';
        editor.insert(randomParagraph);
        updateStatusBar("Random poetic paragraph inserted");
        updateWordCount();
    }

</script>
                
                
  

</body></html>
