<!DOCTYPE html>
<html>
<head><base href="https://wordstar-online.com/">
    <meta charset="UTF-8">
    <meta name="keywords" content="typewriter, writing, retro, vintage, text editor, AI, generative, creative writing">
    <meta name="description" content="Experience the nostalgia of a classic typewriter with Wordstar, a web-based app that combines vintage aesthetics with modern AI-powered writing tools. Generate creative text, experiment with different writing styles, and rediscover the joy of putting words on paper (virtually!).">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WordStar Nexus - Modern Text Editor</title>
    <style>
        body, html {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #2d2d2d;
            color: #f0f0f0;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        #toolbar {
            background-color: #1e1e1e;
            padding: 10px;
            display: flex;
            justify-content: space-between;
        }
        #editor {
            flex-grow: 1;
            padding: 20px;
            font-size: 16px;
            line-height: 1.6;
            background-color: #1e1e1e;
            color: #f0f0f0;
            border: none;
            resize: none;
        }
        #statusbar {
            background-color: #cc0000;
            color: white;
            padding: 5px 10px;
            font-size: 14px;
        }
        button {
            background-color: #cc0000;
            color: white;
            border: none;
            padding: 5px 10px;
            margin-right: 5px;
            cursor: pointer;
        }
        button:hover {
            background-color: #990000;
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        .loading {
            opacity: 0.6;
        }
        .api-config {
            margin-bottom: 10px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
            font-size: 12px;
        }
        .api-config input {
            width: 100%;
            padding: 3px;
            margin-top: 3px;
            background-color: #555;
            color: white;
            border: 1px solid #666;
        }
        .model-status {
            font-size: 11px;
            color: #999;
            margin-left: 5px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2"></script>
</head>
<body>
<div class="container">
    <div id="toolbar">
        <div>
            <button onclick="newDocument()">New</button>
            <button onclick="saveDocument()">Save</button>
            <button onclick="exportTxt()">Export TXT</button>
            <button onclick="exportRtf()">Export RTF</button>
            <button onclick="exportPdf()">Export PDF</button>
            <button onclick="insertPoeticParagraph()">Insert Random Poetic Paragraph</button>
            <button onclick="insertRandomScientificWord()">Random Word</button>
        </div>
        <div id="notebook" style="background-color: #cc0000; padding: 10px; border-radius: 5px; margin-left: 10px;">
            <textarea id="notebookText" rows="3" style="width: 200px; background-color: #cc0000; color: black; border: 1px solid black; padding: 5px;" placeholder="Write your note here..."></textarea>
            <div>
                <button onclick="insertNoteToEditor()" style="background-color: black; color: #cc0000; border: none; padding: 5px 10px; margin-top: 5px; cursor: pointer;">Insert Note</button>
            </div>
        </div>
    </div>
    
    <div id="editor" style="display: flex; justify-content: space-between;">
        <div id="ace-editor" style="width: 80%; height: 100%;">
            <textarea id="main-text-area" style="width: 100%; height: 100%; background-color: #1e1e1e; color: #f0f0f0; border: none; resize: none; font-family: 'Courier New', monospace; font-size: 16pt; font-weight: bold; padding: 10px;" placeholder="Start typing your document here..."></textarea>
        </div>
        
        <div style="width: 18%; display: flex; flex-direction: column;">
            <div>
                <select id="ai-model-select" style="width: 100%; padding: 5px; margin-bottom: 5px;" onchange="onModelChange()">
                    <option value="markov">Markov Chain (Local)</option>
                    <option value="wordassociation">Word Association (Local)</option>
                    <option value="randomsentence">Random Sentence (Local)</option>
                    <option value="distilgpt2">DistilGPT-2 (Client-side)</option>
                    <option value="gpt2">GPT-2 Small (Client-side)</option>
                    <option value="hf-gpt2">GPT-2 (API)</option>
                    <option value="hf-distilgpt2">DistilGPT-2 (API)</option>
                    <option value="hf-gpt-neo">GPT-Neo-1.3B (API)</option>
                    <option value="hf-opt">OPT-350M (API)</option>
                </select>
                <span id="model-status" class="model-status">Ready</span>
                
                <div id="api-config" class="api-config" style="display: none;">
                    <label>Hugging Face API Token:</label>
                    <input type="password" id="hf-token" placeholder="Enter your HF token (optional)">
                    <div style="font-size: 10px; margin-top: 3px; color: #aaa;">
                        Free tier available without token, but with rate limits
                    </div>
                </div>
                
                <textarea id="ai-prompt" placeholder="Enter your prompt here" style="width: 100%; padding: 5px; margin-bottom: 5px; height: 60px;"></textarea>
                <button id="generate-btn" onclick="generateText()" style="width: 100%; background-color: #cc0000; color: white; border: none; padding: 5px 10px; cursor: pointer; font-size: 12px;">Create Text</button>
            </div>
            
            <div id="dictionary-results" style="flex-grow: 1; overflow-y: auto; background-color: #2d2d2d; padding: 10px; border: 1px solid #444; font-size: 12px;">
                <div id="ai-response" style="white-space: pre-wrap;">WordStar AI Text Generation - Enhanced

Available Models:

LOCAL MODELS (No internet required):
• Markov Chain - Statistical text generation
• Word Association - Contextual word chains  
• Random Sentence - Simple sentence construction

CLIENT-SIDE AI (Download once, run offline):
• DistilGPT-2 - Lightweight transformer model
• GPT-2 Small - Original GPT-2 for creative text

API MODELS (Internet required):
• BLOOM-560M - Multilingual text generation
• Flan-T5-Base - Instruction-following model
• GPT-Neo-125M - Open-source alternative
• DistilBERT - Fast text understanding

Instructions:
1. Select a model from the dropdown
2. Enter your writing prompt
3. Click "Create Text" to generate

Client-side models will download automatically on first use (~50-150MB). API models work immediately but may have rate limits without a token.

Generated text will appear here and can be inserted into your document.</div>
            </div>
        </div>
    </div>
    
    <div id="statusbar" style="background-color: #cc0000; display: flex; justify-content: space-between; align-items: center;">
        <span id="status-text">WordStar Online - Ready</span>
        <span id="word-count" style="font-size: 12px;">Words: 0</span>
        <span style="font-size: 12px;">© MMXXIV www.inkrealm.info</span>
    </div>
</div>

<script>
    let editor;
    let currentPipeline = null;
    let isGenerating = false;

    // Markov chain data
    const markovData = {
        "the": ["quick", "lazy", "beautiful", "mysterious", "ancient"],
        "quick": ["brown", "silver", "golden", "dark"],
        "brown": ["fox", "dog", "cat", "horse"],
        "fox": ["jumps", "runs", "walks", "sleeps"],
        "jumps": ["over", "across", "through"],
        "over": ["the", "a", "an"],
        "lazy": ["dog", "cat", "afternoon", "river"],
        "beautiful": ["sunset", "morning", "garden", "melody"],
        "mysterious": ["forest", "cave", "stranger", "light"],
        "ancient": ["tree", "castle", "wisdom", "book"]
    };

    // Word associations
    const wordAssociations = {
        "write": ["pen", "paper", "story", "author", "book"],
        "story": ["tale", "narrative", "adventure", "character", "plot"],
        "adventure": ["journey", "quest", "exploration", "discovery"],
        "journey": ["travel", "path", "destination", "experience"],
        "creative": ["artistic", "imaginative", "innovative", "original"],
        "time": ["moment", "eternity", "past", "future", "present"],
        "light": ["bright", "illumination", "dawn", "star", "hope"],
        "hope": ["dream", "aspiration", "future", "possibility"],
        "dream": ["vision", "imagination", "sleep", "fantasy"],
        "nature": ["forest", "ocean", "mountain", "wildlife", "peace"]
    };

    // Initialize editor
    window.onload = function() {
        editor = ace.edit("ace-editor");
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/text");
        editor.session.on('change', updateWordCount);
        updateWordCount();
    };

    function onModelChange() {
        const selectedModel = document.getElementById('ai-model-select').value;
        const apiConfig = document.getElementById('api-config');
        const modelStatus = document.getElementById('model-status');
        
        if (selectedModel.startsWith('hf-')) {
            apiConfig.style.display = 'block';
            modelStatus.textContent = 'API Model - Ready';
        } else if (selectedModel === 'distilgpt2' || selectedModel === 'gpt2') {
            apiConfig.style.display = 'none';
            modelStatus.textContent = 'Client-side - Will download on first use';
        } else {
            apiConfig.style.display = 'none';
            modelStatus.textContent = 'Local Model - Ready';
        }
    }

    async function generateText() {
        if (isGenerating) return;
        
        const prompt = document.getElementById('ai-prompt').value.trim();
        if (!prompt) {
            alert('Please enter a prompt first');
            return;
        }
        
        const model = document.getElementById('ai-model-select').value;
        const generateBtn = document.getElementById('generate-btn');
        const aiResponse = document.getElementById('ai-response');
        const statusText = document.getElementById('status-text');
        
        isGenerating = true;
        generateBtn.disabled = true;
        generateBtn.textContent = 'Generating...';
        statusText.textContent = 'WordStar Online - Generating text...';
        
        try {
            let generatedText = '';
            
            switch (model) {
                case 'markov':
                    generatedText = generateMarkovText(prompt, 50);
                    break;
                case 'wordassociation':
                    generatedText = generateWordAssociation(prompt, 30);
                    break;
                case 'randomsentence':
                    generatedText = generateRandomSentence();
                    break;
                case 'distilgpt2':
                case 'gpt2':
                    generatedText = await generateWithTransformers(model, prompt);
                    break;
                default:
                    if (model.startsWith('hf-')) {
                        generatedText = await generateWithHuggingFaceAPI(model, prompt);
                    } else {
                        generatedText = 'Model not implemented yet';
                    }
            }
            
            aiResponse.textContent = `Prompt: "${prompt}"\nModel: ${model}\n\nGenerated Text:\n${generatedText}\n\n---\n\nClick a model and try different prompts to see varied results!`;
            
        } catch (error) {
            aiResponse.textContent = `Error generating text: ${error.message}`;
        } finally {
            isGenerating = false;
            generateBtn.disabled = false;
            generateBtn.textContent = 'Create Text';
            statusText.textContent = 'WordStar Online - Ready';
        }
    }

    function generateMarkovText(seed, maxWords) {
        const words = seed.toLowerCase().split(' ');
        let result = seed;
        let currentWord = words[words.length - 1];
        
        for (let i = 0; i < maxWords; i++) {
            const nextWords = markovData[currentWord];
            if (!nextWords || nextWords.length === 0) {
                // Pick a random starting word if we hit a dead end
                const keys = Object.keys(markovData);
                currentWord = keys[Math.floor(Math.random() * keys.length)];
            } else {
                currentWord = nextWords[Math.floor(Math.random() * nextWords.length)];
            }
            result += ' ' + currentWord;
        }
        
        return result + '.';
    }

    function generateWordAssociation(seed, maxWords) {
        const words = seed.toLowerCase().split(' ');
        let result = seed;
        let currentWord = words[words.length - 1];
        
        for (let i = 0; i < maxWords; i++) {
            const associations = wordAssociations[currentWord];
            if (!associations || associations.length === 0) {
                // Find a word that has associations
                const keys = Object.keys(wordAssociations);
                currentWord = keys[Math.floor(Math.random() * keys.length)];
            } else {
                currentWord = associations[Math.floor(Math.random() * associations.length)];
            }
            result += ' ' + currentWord;
        }
        
        return result + '.';
    }

    function generateRandomSentence() {
        const subjects = ['The writer', 'A poet', 'The storyteller', 'An author', 'The dreamer'];
        const verbs = ['crafts', 'weaves', 'creates', 'imagines', 'discovers'];
        const objects = ['beautiful prose', 'vivid imagery', 'compelling narratives', 'magical worlds', 'timeless stories'];
        const endings = ['with passion', 'through dedication', 'using creativity', 'with great care', 'in quiet moments'];
        
        const subject = subjects[Math.floor(Math.random() * subjects.length)];
        const verb = verbs[Math.floor(Math.random() * verbs.length)];
        const object = objects[Math.floor(Math.random() * objects.length)];
        const ending = endings[Math.floor(Math.random() * endings.length)];
        
        return `${subject} ${verb} ${object} ${ending}.`;
    }

    async function generateWithTransformers(modelName, prompt) {
        const statusText = document.getElementById('status-text');
        
        try {
            statusText.textContent = 'WordStar Online - Loading AI model (this may take a moment)...';
            
            const modelId = modelName === 'distilgpt2' ? 'distilgpt2' : 'gpt2';
            
            if (!currentPipeline || currentPipeline.model !== modelId) {
                // Use dynamic import for Transformers.js
                const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2');
                currentPipeline = await pipeline('text-generation', modelId, {
                    revision: 'main',
                    quantized: true
                });
                currentPipeline.model = modelId;
            }
            
            statusText.textContent = 'WordStar Online - Generating text...';
            
            const result = await currentPipeline(prompt, {
                max_new_tokens: 30,
                temperature: 0.7,
                do_sample: true,
                repetition_penalty: 1.1
            });
            
            // Handle different response formats
            let generatedText = '';
            if (Array.isArray(result)) {
                generatedText = result[0].generated_text || '';
            } else if (result.generated_text) {
                generatedText = result.generated_text;
            } else {
                generatedText = String(result);
            }
            
            // Remove the original prompt from the response if it's included
            if (generatedText.startsWith(prompt)) {
                generatedText = generatedText.slice(prompt.length);
            }
            
            return generatedText.trim() || "Unable to generate text with this prompt.";
            
        } catch (error) {
            console.error('Transformers error:', error);
            // Fallback to a simple continuation
            return `... and the story continues with new possibilities. The narrative unfolds with ${prompt.split(' ').pop()} leading to unexpected discoveries.`;
        }
    }

    async function generateWithHuggingFaceAPI(model, prompt) {
        const token = document.getElementById('hf-token').value;
        const modelMap = {
            'hf-gpt2': 'gpt2',
            'hf-distilgpt2': 'distilgpt2', 
            'hf-gpt-neo': 'EleutherAI/gpt-neo-1.3B',
            'hf-opt': 'facebook/opt-350m'
        };
        
        const headers = {
            'Content-Type': 'application/json'
        };
        
        if (token && token.trim()) {
            headers['Authorization'] = `Bearer ${token.trim()}`;
        }
        
        try {
            const response = await fetch(`https://api-inference.huggingface.co/models/${modelMap[model]}`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    inputs: prompt,
                    parameters: {
                        max_new_tokens: 50,
                        temperature: 0.8,
                        do_sample: true,
                        return_full_text: false
                    },
                    options: {
                        wait_for_model: true,
                        use_cache: false
                    }
                })
            });
            
            const responseText = await response.text();
            console.log('API Response:', responseText);
            
            if (!response.ok) {
                if (response.status === 503) {
                    return 'Model is currently loading. Please try again in 30 seconds.';
                } else if (response.status === 429) {
                    return 'Rate limit exceeded. Please add a Hugging Face API token or wait a moment.';
                } else if (response.status === 401) {
                    return 'Invalid API token. Please check your Hugging Face token.';
                } else {
                    return `API Error (${response.status}). Try a different model or add an API token.`;
                }
            }
            
            let result;
            try {
                result = JSON.parse(responseText);
            } catch (e) {
                return 'Invalid response from API. Please try again.';
            }
            
            if (result.error) {
                return `Model error: ${result.error}`;
            }
            
            // Handle different response formats
            let generatedText = '';
            if (Array.isArray(result) && result.length > 0) {
                generatedText = result[0].generated_text || '';
            } else if (result.generated_text) {
                generatedText = result.generated_text;
            } else {
                return 'No text generated. The model may be overloaded.';
            }
            
            // Clean up the response
            if (generatedText.includes(prompt)) {
                generatedText = generatedText.replace(prompt, '').trim();
            }
            
            return generatedText || 'Unable to generate meaningful text with this prompt.';
            
        } catch (error) {
            console.error('Network Error:', error);
            return `Network error: ${error.message}. Check your internet connection.`;
        }
    }

    // Keep all original functions
    function newDocument() {
        if (editor) {
            editor.setValue("");
            updateStatusBar("New document created");
            updateWordCount();
        }
    }

    function saveDocument() {
        if (editor) {
            const content = editor.getValue();
            const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "document.txt";
            a.click();
            URL.revokeObjectURL(url);
            updateStatusBar("Document saved");
        }
    }

    function exportTxt() {
        saveDocument();
    }

    function exportRtf() {
        if (editor) {
            const content = editor.getValue();
            const rtfContent = "{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0 Times New Roman;}}\n\n" + content.replace(/\n/g, "\\par\n") + "}";
            const blob = new Blob([rtfContent], {type: "application/rtf"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "document.rtf";
            a.click();
            URL.revokeObjectURL(url);
            updateStatusBar("Document exported as RTF");
        }
    }

    function exportPdf() {
        if (editor && window.jspdf) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const content = editor.getValue();
            doc.text(content, 10, 10);
            doc.save("document.pdf");
            updateStatusBar("Document exported as PDF");
        }
    }

    function insertPoeticParagraph() {
        if (editor) {
            const poeticParagraphs = [
                "Whispers of twilight dance on autumn leaves,\nAs golden hues paint the sky's canvas,\nNature's symphony echoes through the trees,\nA moment of beauty, forever to last.",
                "Moonlit waves caress the shore,\nStars above, a cosmic dance,\nIn this quiet, forevermore,\nWe find life's gentle romance.",
                "Sunflowers reach for azure skies,\nTheir petals, a sea of gold,\nIn fields where summer never dies,\nAnd stories of light unfold."
            ];
            const randomParagraph = poeticParagraphs[Math.floor(Math.random() * poeticParagraphs.length)];
            editor.insert(randomParagraph + "\n\n");
            updateStatusBar("Poetic paragraph inserted");
            updateWordCount();
        }
    }

    function insertRandomScientificWord() {
        if (editor) {
            const scientificWords = [
                "Quantum", "Photosynthesis", "Entropy", "Mitochondria", "Neuroplasticity",
                "Genome", "Algorithm", "Nanotechnology", "Thermodynamics", "Synapse"
            ];
            const randomWord = scientificWords[Math.floor(Math.random() * scientificWords.length)];
            editor.insert(randomWord + " ");
            updateStatusBar("Random scientific word inserted");
            updateWordCount();
        }
    }

    function insertNoteToEditor() {
        if (editor) {
            const noteContent = document.getElementById('notebookText').value;
            if (noteContent.trim() === '') {
                alert('Note is empty. Please write something before inserting.');
                return;
            }
            editor.insert(noteContent + '\n');
            updateStatusBar("Note inserted into main text area");
            updateWordCount();
        }
    }

    function updateStatusBar(message) {
        const statusBarElement = document.getElementById('status-text');
        if (statusBarElement) {
            statusBarElement.textContent = "WordStar Online - " + message;
        }
    }

    function updateWordCount() {
        if (editor) {
            const content = editor.getValue();
            const wordCount = content.trim() ? content.trim().split(/\s+/).length : 0;
            const wordCountElement = document.getElementById('word-count');
            if (wordCountElement) {
                wordCountElement.textContent = `Words: ${wordCount}`;
            }
        }
    }
</script>
</body>
</html>
