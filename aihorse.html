<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"> 
  <meta name="viewport" content="width=1024">
  <title>reader/horse ai ... </title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

  <style>
    :root {
      --red: #ff0033;
      --black: #0a0a0a;
      --dark-grey: #121212;
      --white: #d1d1d1;
    }
    ::selection {
      background: var(--red);
      color: var(--black);
      text-shadow: none;
    }
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: 'Nova Mono', monospace;
      background: var(--black);
      color: var(--white);
      margin: 0;
      touch-action: manipulation;
    }
    /* CRT scanlines */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,.15) 50%),
                  linear-gradient(90deg, rgba(255,0,0,.04), rgba(0,255,0,.02), rgba(0,0,255,.04));
      background-size: 100% 3px, 3px 100%;
      z-index: 999;
      pointer-events: none;
    }
    .highlight {
      background: var(--red);
      color: var(--black);
      padding: 1px 3px;
    }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: var(--black); }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--red); border-radius: 3px; }
    input, textarea, button { font-family: 'Nova Mono', monospace; }
    button { user-select: none; cursor: pointer; }
    .special-elite { font-family: 'Special Elite', serif; }
  </style>
</head>

<body class="bg-black text-gray-300">
<!-- HEADER -->
<div class="sticky top-0 z-50 w-full pt-4 pb-4 px-4 sm:px-6 md:px-8 border-b border-red-800 bg-black">
  <div class="flex justify-between items-center max-w-full">
    <h1 class="text-3xl font-bold special-elite" style="color: var(--red);">⚡ horse reader ai...⚡</h1>
    <a href="https://inkrealm.info"
       class="text-xs font-mono border border-gray-600 px-3 py-1 hover:bg-red-600 hover:text-black hover:border-red-600 transition-all duration-300 uppercase tracking-widest no-underline text-gray-400">
      Return to Realm
    </a>
  </div>
</div>

<!-- TWO-COLUMN LAYOUT -->
<div id="horse-layout" class="flex flex-col md:flex-row w-full h-[calc(100vh-80px)] overflow-hidden bg-black">
  <!-- LEFT: READER -->
  <div class="flex-1 flex flex-col h-full border-r border-gray-800 relative min-w-0">
    <div id="loading" class="absolute inset-0 flex items-center justify-center text-xl" style="color: var(--red);">
      Loading horse.txt ...
    </div>
    <div id="content" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-10 text-base md:text-lg leading-relaxed whitespace-pre-wrap special-elite custom-scrollbar" style="display:none;"></div>
    <div id="entryInfo" class="p-3 border-t border-gray-800 text-xs text-gray-500 bg-black flex-shrink-0"></div>
  </div>
  

  <!-- RIGHT: CONTROLS -->
  <div class="w-full md:w-[400px] flex flex-col h-full bg-[#0a0a0a] border-l border-gray-800 flex-shrink-0">
    <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">
      <!-- NAV -->
      <div class="flex items-center justify-between mb-6 gap-2">
        <button id="prevBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">← Prev</button>
        <button id="randomBtn" class="px-4 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">⚡</button>
        <button id="nextBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">Next →</button>
      </div>

      <!-- SEARCH -->
      <div class="mb-6">
        <input type="text" id="searchBox" class="w-full bg-[#111] border border-gray-700 p-3 text-white focus:border-red-500 focus:outline-none transition-colors" placeholder="Search text...">
        <div class="flex justify-between items-center mt-2">
          <div id="searchStats" class="text-xs text-gray-500 h-4"></div>
        </div>
      </div>

      <!-- FILTERS -->
      <div id="filterBtns" class="flex flex-wrap gap-2 mb-6 pb-6 border-b border-gray-800">
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="all">All</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="fragments">Fragments</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="passages">Passages</button>
       <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sections">Sections</button>
      </div>

      <!-- INDEX -->
      <div id="dateNav" class="hidden mb-6 max-h-60 overflow-y-auto border border-gray-800 bg-[#111] custom-scrollbar"></div>

      <!-- NVIDIA AI -->
      <div class="mt-2">
        <h2 class="text-xl font-bold mb-4 text-gray-600 special-elite">AI EDITOR</h2>
        <input type="password" id="apiKeyInput" class="w-full bg-black border border-gray-800 p-2 text-xs text-red-500 font-mono mb-4 focus:outline-none focus:border-red-900" placeholder="NVIDIA API KEY...">
        <div class="flex gap-2 mb-2">
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="current">Current</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="all">Outline</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="none">None</button>
        </div>
        <p id="contextInfo" class="text-[10px] text-gray-600 mb-3 text-right">Target: Current Entry</p>
        <textarea id="aiInput" class="w-full bg-[#111] border border-gray-800 p-3 text-sm text-gray-300 focus:border-red-500 focus:outline-none min-h-[80px] mb-2" placeholder="Enter prompt..."></textarea>
        <button id="askAiBtn" class="w-full bg-red-900/20 hover:bg-red-900/40 border border-red-900 text-red-500 py-2 text-xs font-bold tracking-widest transition-all">TRANSMIT</button>
        <div id="aiResponse" class="mt-4 p-3 bg-black border border-gray-800 text-sm text-gray-400 min-h-[100px] whitespace-pre-wrap special-elite font-mono custom-scrollbar"><span class="opacity-30">:: Awaiting Input ::</span></div>
      </div>
    </div>
  </div>
</div>

<!-- ============  SCRIPTS  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->

<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<script id="reader-script">
/* ==========  CONFIG  ========== */
const TXT_FILE_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/horse.txt';

// Markdown pattern
const ENTRY_PATTERN = /^(#{1,3})\s+(.+)$/;

// SIMPLE TAG PATTERNS
const TAG_PATTERNS = {
  all: /.*/,
  fragments: /\bfragment(s)?\b|\[fragment\]/i,
  passages: /\bpassage(s)?\b|\[passage\]/i,
  sections: /\bsection(s)?\b|\[section\]/i
};

/* ==========  STATE  ========== */
window.readerEntries = [];
window.readerCurrentIndex = 0;
let currentFilter = 'all';
let searchQuery = '';
let searchResults = [];
let isSearching = false;
let isIndexVisible = false;
let searchTimeout = null;

/* ==========  DOM  ========== */
const searchBox = document.getElementById('searchBox');
const searchStats = document.getElementById('searchStats');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const randomBtn = document.getElementById('randomBtn');
const indexBtn = document.getElementById('indexBtn');
const dateNav = document.getElementById('dateNav');
const entryInfo = document.getElementById('entryInfo');
const loadingDiv = document.getElementById('loading');
const contentDiv = document.getElementById('content');

/* ==========  LOAD DATA  ========== */
async function loadText() {
  try {
    console.log('Loading text from:', TXT_FILE_URL);
    
    const textRes = await fetch(TXT_FILE_URL);
    if (!textRes.ok) throw new Error('Text file not found');
    
    let text = await textRes.text();
    console.log('Text loaded, length:', text.length);
    
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    parseEntries(text);
    
    loadingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    
    console.log(`Parsed ${window.readerEntries.length} entries`);
    
    if (window.readerEntries.length > 0) {
      showEntry(window.readerEntries[0].id);
    }
    
    // Set "All" button active
    const allBtn = document.querySelector('.filter-btn[data-filter="all"]');
    if (allBtn) styleActiveFilter(allBtn);
    
    buildIndex();
    updateUIState();
    
    // Log what tags were found for debugging
    logFoundTags();
    
  } catch (err) {
    console.error('Load error:', err);
    loadingDiv.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  }
}

function logFoundTags() {
  const tagCounts = {};
  window.readerEntries.forEach(entry => {
    entry.tags.forEach(tag => {
      tagCounts[tag] = (tagCounts[tag] || 0) + 1;
    });
  });
  console.log('Tags found in content:', tagCounts);
}

/* ==========  SEARCH ========== */
searchBox.addEventListener('input', function(e) {
  performSearch(e.target.value);
});

function performSearch(query) {
  const trimmedQuery = query.trim();
  console.log('Searching for:', trimmedQuery);
  
  if (!trimmedQuery) {
    isSearching = false;
    searchResults = [];
    updateUIState();
    
    // Show current or first entry
    const pool = getCurrentViewEntries();
    if (pool.length > 0) {
      const entryToShow = window.readerCurrentIndex > 0 ? 
        window.readerCurrentIndex : pool[0].id;
      showEntry(entryToShow);
    }
    return;
  }
  
  isSearching = true;
  searchQuery = trimmedQuery;
  
  // Simple search
  const pool = getFilteredEntries();
  const queryLower = trimmedQuery.toLowerCase();
  
  searchResults = pool.filter(entry => {
    const searchText = (entry.content + ' ' + entry.title).toLowerCase();
    return searchText.includes(queryLower);
  });
  
  console.log(`Search results: ${searchResults.length} of ${pool.length} entries`);
  
  updateUIState();
  
  if (searchResults.length > 0) {
    showEntry(searchResults[0].id);
  } else {
    contentDiv.innerHTML = `
      <div class="text-center mt-10 p-4">
        <div class="text-gray-500">No matches found for "${trimmedQuery}"</div>
      </div>`;
    entryInfo.innerHTML = `<div class="text-xs text-gray-500">Search: "${trimmedQuery}"</div>`;
  }
}

function highlightText(text, query) {
  if (!query) return text;
  
  try {
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return text.replace(regex, '<span class="highlight" style="background:var(--red); color:black; padding:0 2px;">$1</span>');
  } catch (e) {
    console.log('Highlight error:', e);
    return text;
  }
}

/* ==========  PARSE ENTRIES  ========== */
function parseEntries(text) {
  const lines = text.split('\n');
  let current = null;
  let id = 0;
  
  lines.forEach((line) => {
    const m = line.match(ENTRY_PATTERN);
    if (m) {
      // Save previous entry if exists
      if (current && current.content.trim()) {
        detectTags(current);
        window.readerEntries.push(current);
      }
      
      // Start new entry
      current = {
        id: ++id,
        title: m[2].trim(),
        headingLevel: m[1].length,
        content: line + '\n',
        tags: []
      };
    } else if (current) {
      // Continue current entry
      current.content += line + '\n';
    }
  });
  
  // Don't forget the last entry
  if (current && current.content.trim()) {
    detectTags(current);
    window.readerEntries.push(current);
  }
}

function detectTags(entry) {
  const detectedTags = [];
  
  // Check each tag pattern
  for (const [tag, pattern] of Object.entries(TAG_PATTERNS)) {
    if (tag !== 'all' && pattern.test(entry.content)) {
      detectedTags.push(tag);
    }
  }
  
  entry.tags = detectedTags;
}

/* ==========  GET CURRENT VIEW ENTRIES - FIXED ========== */
function getCurrentViewEntries() {
  if (isSearching) {
    return searchResults;
  }
  return getFilteredEntries();
}

function getFilteredEntries() {
  let entries = window.readerEntries;
  
  if (currentFilter !== 'all') {
    return entries.filter(e => e.tags.includes(currentFilter));
  }
  
  return entries;
}

/* ==========  DISPLAY FUNCTIONS  ========== */
function showEntry(entryId) {
  const entry = window.readerEntries.find(x => x.id === entryId);
  if (!entry) return;
  
  window.readerCurrentIndex = entryId;
  
  let displayContent = entry.content;
  
  // Apply highlighting if searching
  if (isSearching && searchQuery) {
    displayContent = highlightText(displayContent, searchQuery);
  }
  
  // Process markdown formatting
  const html = displayContent.split('\n').map(line => {
    const trimmed = line.trim();
    if (!trimmed) return '<br>';
    
    const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const headingText = headingMatch[2];
      const headingClass = level === 1 ? 'text-2xl font-bold mt-6 mb-4' :
                          level === 2 ? 'text-xl font-bold mt-5 mb-3' :
                          'text-lg font-bold mt-4 mb-2';
      return `<h${level} class="${headingClass} special-elite" style="color:var(--red)">${headingText}</h${level}>`;
    }
    
    return `<p class="mb-4 leading-relaxed">${trimmed}</p>`;
  }).join('');
  
  contentDiv.innerHTML = html;
  
  const pool = getCurrentViewEntries();
  const idx = pool.findIndex(x => x.id === entryId);
  const words = entry.content.replace(/<[^>]*>/g, '').trim().split(/\s+/).length;
  
  console.log(`Showing entry ${entryId} ("${entry.title}"), position ${idx + 1}/${pool.length} in current view`);
  
  // Tag styling
  const tagStyles = {
    'fragments': 'border-red-400 text-red-400',
    'passages': 'border-red-500 text-red-500', 
    'sections': 'border-red-600 text-red-600'
  };
  
  entryInfo.innerHTML = `
    <div class="flex flex-col gap-1">
      <div>
        <span class="text-xs text-gray-500 uppercase tracking-widest">HORSE ARCHIVE</span>
        <span class="ml-2 font-bold text-xl special-elite" style="color:var(--red)">${entry.title}</span>
      </div>
      <div class="text-xs text-gray-400 flex items-center gap-2 flex-wrap">
        ${isSearching ? `Search result ${idx + 1}/${searchResults.length}` : `Entry ${idx + 1}/${pool.length}`}
        <span>•</span>${words} words
        ${entry.tags.length > 0 ? `<span class="ml-2 flex gap-1 flex-wrap">
          ${entry.tags.map(t => {
            const style = tagStyles[t] || 'border-gray-600 text-gray-600';
            return `<span class="px-2 py-1 border text-[10px] uppercase ${style}">${t}</span>`;
          }).join('')}
        </span>` : ''}
      </div>
    </div>`;
  
  // Update navigation buttons
  updateNavigationButtons(pool, idx);
  
  contentDiv.scrollTop = 0;
  if (isIndexVisible) buildIndex();
}

function updateNavigationButtons(pool, currentIndex) {
  console.log(`Updating nav buttons: index ${currentIndex}, pool size ${pool.length}`);
  
  if (prevBtn) {
    const isDisabled = currentIndex <= 0;
    prevBtn.disabled = isDisabled;
    prevBtn.style.opacity = isDisabled ? '0.5' : '1';
    prevBtn.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
  }
  
  if (nextBtn) {
    const isDisabled = currentIndex >= pool.length - 1;
    nextBtn.disabled = isDisabled;
    nextBtn.style.opacity = isDisabled ? '0.5' : '1';
    nextBtn.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
  }
}

function showRandomEntry() {
  const pool = getCurrentViewEntries();
  console.log(`Random from pool of ${pool.length} entries`);
  
  if (!pool.length) return;
  
  let randomIdx;
  do {
    randomIdx = Math.floor(Math.random() * pool.length);
  } while (pool[randomIdx].id === window.readerCurrentIndex && pool.length > 1);
  
  showEntry(pool[randomIdx].id);
}

function navigateEntries(dir) {
  const pool = getCurrentViewEntries();
  console.log(`Navigate ${dir}, pool size: ${pool.length}`);
  
  if (pool.length === 0) return;
  
  const idx = pool.findIndex(x => x.id === window.readerCurrentIndex);
  console.log(`Current index in pool: ${idx}`);
  
  const newIdx = dir === 'next' ? idx + 1 : idx - 1;
  console.log(`New index: ${newIdx}`);
  
  if (newIdx >= 0 && newIdx < pool.length) {
    showEntry(pool[newIdx].id);
  } else {
    console.log(`Cannot navigate ${dir}: ${newIdx} out of bounds (0-${pool.length-1})`);
  }
}

/* ==========  FILTER HANDLING  ========== */
document.getElementById('filterBtns').addEventListener('click', function(e) {
  if (e.target.classList.contains('filter-btn')) {
    const filter = e.target.dataset.filter;
    console.log('Filter clicked:', filter);
    handleFilterChange(filter, e.target);
  }
});

function handleFilterChange(filter, button) {
  currentFilter = filter;
  
  // Style the active button
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.style.background = 'transparent';
    btn.style.borderColor = '#333';
    btn.style.color = '#666';
  });
  
  button.style.background = 'var(--red)';
  button.style.color = 'black';
  button.style.borderColor = 'var(--red)';
  
  // Clear search
  searchBox.value = '';
  isSearching = false;
  searchQuery = '';
  
  const filtered = getFilteredEntries();
  console.log(`Filter "${filter}" applied: ${filtered.length} entries`);
  
  updateUIState();
  
  if (filtered.length > 0) {
    // Find the current entry in the filtered list, or show first
    const currentInFiltered = filtered.find(e => e.id === window.readerCurrentIndex);
    if (currentInFiltered) {
      showEntry(currentInFiltered.id);
    } else {
      showEntry(filtered[0].id);
    }
  } else {
    contentDiv.innerHTML = `
      <div class="text-center mt-10 p-4">
        <div class="text-gray-500">No entries tagged as "${filter}"</div>
      </div>`;
    entryInfo.innerHTML = `<div class="text-xs text-gray-500">Filter: ${filter}</div>`;
  }
}

/* ==========  UI FUNCTIONS  ========== */
function updateUIState() {
  if (isSearching) {
    searchStats.textContent = `${searchResults.length} match${searchResults.length !== 1 ? 'es' : ''}`;
  } else {
    const count = getFilteredEntries().length;
    searchStats.textContent = currentFilter !== 'all' ? `${count} ${currentFilter}` : `${count} total`;
  }
  
  if (isIndexVisible) {
    buildIndex();
  }
}

function buildIndex() {
  const pool = getCurrentViewEntries();
  console.log(`Building index with ${pool.length} entries`);
  
  dateNav.innerHTML = '';
  
  if (pool.length === 0) {
    dateNav.innerHTML = '<div class="p-3 text-gray-500 text-sm">No entries to display</div>';
    return;
  }
  
  pool.forEach(entry => {
    const div = document.createElement('div');
    div.className = 'p-3 border-b border-gray-700 cursor-pointer hover:bg-gray-900 transition-colors';
    
    if (entry.id === window.readerCurrentIndex) {
      div.style.background = '#1a1a1a';
      div.style.borderLeft = '3px solid var(--red)';
    }
    
    const preview = entry.content.replace(/<[^>]*>/g, '').substring(0, 60).replace(/\n/g, ' ') + '...';
    
    div.innerHTML = `
      <div class="text-sm font-bold text-gray-300 mb-1 truncate special-elite">
        ${entry.title}
      </div>
      <div class="text-xs text-gray-600 font-mono truncate">${preview}</div>
      ${entry.tags.length > 0 ? 
        `<div class="mt-1 flex gap-1 flex-wrap">
          ${entry.tags.slice(0, 2).map(t => 
            `<span class="text-[9px] px-1 py-0.5 border border-gray-700 text-gray-500">${t}</span>`
          ).join('')}
        </div>` : ''}
    `;
    
    div.addEventListener('click', () => {
      showEntry(entry.id);
      if (window.innerWidth < 768) {
        dateNav.classList.add('hidden');
        isIndexVisible = false;
      }
    });
    dateNav.appendChild(div);
  });
}

function styleActiveFilter(btn) {
  if (!btn) return;
  document.querySelectorAll('.filter-btn').forEach(b => {
    b.style.background = 'transparent';
    b.style.borderColor = '#333';
    b.style.color = '#666';
  });
  
  btn.style.background = 'var(--red)';
  btn.style.color = 'black';
  btn.style.borderColor = 'var(--red)';
}

/* ==========  INITIALIZATION  ========== */
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, starting horse reader...');
  loadText();
  
  // Navigation buttons
  prevBtn.addEventListener('click', () => navigateEntries('prev'));
  nextBtn.addEventListener('click', () => navigateEntries('next'));
  randomBtn.addEventListener('click', showRandomEntry);
  indexBtn.addEventListener('click', () => {
    isIndexVisible = !isIndexVisible;
    dateNav.classList.toggle('hidden');
    if (isIndexVisible) buildIndex();
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
    
    if (e.key === 'ArrowLeft') {
      e.preventDefault();
      navigateEntries('prev');
    }
    if (e.key === 'ArrowRight') {
      e.preventDefault();
      navigateEntries('next');
    }
    if (e.key.toLowerCase() === 'r') {
      e.preventDefault();
      showRandomEntry();
    }
    if (e.key === 'Escape' && isIndexVisible) {
      dateNav.classList.add('hidden');
      isIndexVisible = false;
    }
  });
});
</script>
<script id="ai-script">
/* ==========  AI CONFIG  ========== */
const NVIDIA_MODELS={
  stable:"meta/llama-3.3-70b-instruct",
  backup:"nvidia/llama-3.1-nemotron-70b-instruct"
};
let currentModel=NVIDIA_MODELS.stable,aiContext='current';
const apiKeyInput=document.getElementById('apiKeyInput');
const aiInput=document.getElementById('aiInput');
const askAiBtn=document.getElementById('askAiBtn');
const aiResponseDiv=document.getElementById('aiResponse');
const contextInfo=document.getElementById('contextInfo');

/* ==========  INIT  ========== */
if(localStorage.getItem('horse_nvidia_key'))apiKeyInput.value=localStorage.getItem('horse_nvidia_key');
apiKeyInput.addEventListener('input',e=>localStorage.setItem('horse_nvidia_key',e.target.value));

/* ==========  TRANSMIT  ========== */
askAiBtn.addEventListener('click',async()=>{
  const key=apiKeyInput.value.trim(),msg=aiInput.value.trim();
  if(!key){aiResponseDiv.innerHTML='<p class="text-red-500">Please enter an NVIDIA API Key.</p>';return;}
  if(!msg)return;
  if(!window.readerEntries?.length){aiResponseDiv.innerHTML='<p class="text-red-500">horse.txt not loaded yet.</p>';return;}
  askAiBtn.disabled=true;askAiBtn.textContent='TRANSMITTING...';
  aiResponseDiv.innerHTML='<p class="animate-pulse" style="color:var(--red)">Consulting Llama...</p>';
  try{
    let ctx='';
    if(aiContext==='current'){
      const e=window.readerEntries.find(x=>x.id===window.readerCurrentIndex);
      if(e)ctx=`CONTEXT (Current – ${e.title}):\n${e.content.substring(0,4000)}\n\n---\n`;
    }else if(aiContext==='all'){
      ctx=`CONTEXT (Outline):\n${window.readerEntries.map(x=>`- ${x.title} (${x.tags.join(', ')})`).join('\n')}\n\n---\n`;
    }
    const proxyUrl = 'https://lively-limitless.inkrealm.workers.dev/?url=' +encodeURIComponent('https://integrate.api.nvidia.com/v1/chat/completions');
    const res=await fetch(proxy,{
      method:'POST',
      headers:{Authorization:`Bearer ${key}`,'Content-Type':'application/json'},
      body:JSON.stringify({
        model:currentModel,
        messages:[
          {role:'system',content:'You are an editor for HORSE, a narrative where reality and dreams blur. Analyse via surrealism. Be bold, concise, literary.'},
          {role:'user',content:ctx+'User Question: '+msg}
        ],
        temperature:.6,top_p:1,max_tokens:1024
      })
    });
    if(!res.ok){if(res.status===404)throw new Error('404 Switch');const t=await res.text();let m=t;try{m=JSON.parse(t).error?.message||t;}catch{e}throw new Error(m);}
    const data=await res.json();
    let txt=data.choices[0].message.content;
    txt=txt.replace(/\*\*(.*?)\*\*/g,'<strong style="color:var(--red)">$1</strong>').replace(/\n/g,'<br>');
    aiResponseDiv.innerHTML=txt;
  }catch(err){
    console.error(err);
    if(err.message.includes('404')||err.message.includes('Switch')){
      currentModel=NVIDIA_MODELS.backup;
      aiResponseDiv.innerHTML='<p style="color:#888">Primary model unavailable. Switched to Backup.<br><strong>Please click Transmit again.</strong></p>';
    }else{
      aiResponseDiv.innerHTML=`<p style="color:var(--red)">Error: ${err.message}</p>`;
    }
  }finally{askAiBtn.disabled=false;askAiBtn.textContent='TRANSMIT';}
});

/* ==========  CONTEXT BUTTONS  ========== */
document.addEventListener('click',e=>{
  if(!e.target.classList.contains('context-btn'))return;
  document.querySelectorAll('.context-btn').forEach(b=>{b.style.background='var(--dark-grey)';b.style.color='#888';b.style.borderColor='#333';});
  e.target.style.background='var(--red)';e.target.style.color='black';e.target.style.borderColor='var(--red)';
  aiContext=e.target.dataset.context;
  contextInfo.textContent=`Context: ${aiContext.toUpperCase()} (${aiContext==='current'?'Reading current entry':aiContext==='all'?'Reading all titles':'No context'})`;
});
</script>
</body>
</html>
