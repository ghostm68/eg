<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>reader/horse ai is under re-construction... </title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

  <style>
    :root {
      --red: #ff0033;
      --black: #0a0a0a;
      --dark-grey: #121212;
      --white: #d1d1d1;
    }
    ::selection {
      background: var(--red);
      color: var(--black);
      text-shadow: none;
    }
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: 'Nova Mono', monospace;
      background: var(--black);
      color: var(--white);
      margin: 0;
      touch-action: manipulation;
    }
    /* CRT scanlines */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,.15) 50%),
                  linear-gradient(90deg, rgba(255,0,0,.04), rgba(0,255,0,.02), rgba(0,0,255,.04));
      background-size: 100% 3px, 3px 100%;
      z-index: 999;
      pointer-events: none;
    }
    .highlight {
      background: var(--red);
      color: var(--black);
      padding: 1px 3px;
    }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: var(--black); }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--red); border-radius: 3px; }
    input, textarea, button { font-family: 'Nova Mono', monospace; }
    button { user-select: none; cursor: pointer; }
    .special-elite { font-family: 'Special Elite', serif; }
  </style>
</head>

<body class="bg-black text-gray-300">
<!-- HEADER -->
<div class="sticky top-0 z-50 w-full pt-4 pb-4 px-4 sm:px-6 md:px-8 border-b border-red-800 bg-black">
  <div class="flex justify-between items-center max-w-full">
    <h1 class="text-3xl font-bold special-elite" style="color: var(--red);">‚ö° horse reader ai is being rebuilt...‚ö°</h1>
    <a href="https://inkrealm.info"
       class="text-xs font-mono border border-gray-600 px-3 py-1 hover:bg-red-600 hover:text-black hover:border-red-600 transition-all duration-300 uppercase tracking-widest no-underline text-gray-400">
      Return to Realm
    </a>
  </div>
</div>

<!-- TWO-COLUMN LAYOUT -->
<div id="horse-layout" class="flex flex-col md:flex-row w-full h-[calc(100vh-80px)] overflow-hidden bg-black">
  <!-- LEFT: READER -->
  <div class="flex-1 flex flex-col h-full border-r border-gray-800 relative min-w-0">
    <div id="loading" class="absolute inset-0 flex items-center justify-center text-xl" style="color: var(--red);">
      Loading horse.txt ...
    </div>
    <div id="content" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-10 text-base md:text-lg leading-relaxed whitespace-pre-wrap special-elite custom-scrollbar" style="display:none;"></div>
    <div id="entryInfo" class="p-3 border-t border-gray-800 text-xs text-gray-500 bg-black flex-shrink-0"></div>
  </div>
  
  <!-- RIGHT: IMAGES SIDEBAR (Hidden by default, shows for sketches) -->
  <div id="imagesSidebar" class="hidden md:w-80 lg:w-96 border-l border-gray-800 bg-black overflow-y-auto">
    <!-- Content will be populated by JavaScript -->
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="w-full md:w-[400px] flex flex-col h-full bg-[#0a0a0a] border-l border-gray-800 flex-shrink-0">
    <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">
      <!-- NAV -->
      <div class="flex items-center justify-between mb-6 gap-2">
        <button id="prevBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚Üê Prev</button>
        <button id="randomBtn" class="px-4 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚ö°</button>
        <button id="nextBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">Next ‚Üí</button>
      </div>

      <!-- SEARCH -->
      <div class="mb-6">
        <input type="text" id="searchBox" class="w-full bg-[#111] border border-gray-700 p-3 text-white focus:border-red-500 focus:outline-none transition-colors" placeholder="Search text...">
        <div class="flex justify-between items-center mt-2">
          <div id="searchStats" class="text-xs text-gray-500 h-4"></div>
          <button id="indexBtn" class="text-xs text-gray-500 hover:text-red-500 uppercase tracking-widest border-b border-transparent hover:border-red-500">Toggle Index</button>
        </div>
      </div>

      <!-- FILTERS -->
      <div id="filterBtns" class="flex flex-wrap gap-2 mb-6 pb-6 border-b border-gray-800">
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="all">All</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="fragments">Fragments</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="passages">Passages</button>
       <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sections">Sections</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sketches">Sketches</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="characters">Characters</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="dialogue">Dialogue</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="scenes">Scenes</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="settings">Settings</button>
      </div>

      <!-- INDEX -->
      <div id="dateNav" class="hidden mb-6 max-h-60 overflow-y-auto border border-gray-800 bg-[#111] custom-scrollbar"></div>

      <!-- NVIDIA AI -->
      <div class="mt-2">
        <h2 class="text-xl font-bold mb-4 text-gray-600 special-elite">AI EDITOR</h2>
        <input type="password" id="apiKeyInput" class="w-full bg-black border border-gray-800 p-2 text-xs text-red-500 font-mono mb-4 focus:outline-none focus:border-red-900" placeholder="NVIDIA API KEY...">
        <div class="flex gap-2 mb-2">
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="current">Current</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="all">Outline</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="none">None</button>
        </div>
        <p id="contextInfo" class="text-[10px] text-gray-600 mb-3 text-right">Target: Current Entry</p>
        <textarea id="aiInput" class="w-full bg-[#111] border border-gray-800 p-3 text-sm text-gray-300 focus:border-red-500 focus:outline-none min-h-[80px] mb-2" placeholder="Enter prompt..."></textarea>
        <button id="askAiBtn" class="w-full bg-red-900/20 hover:bg-red-900/40 border border-red-900 text-red-500 py-2 text-xs font-bold tracking-widest transition-all">TRANSMIT</button>
        <div id="aiResponse" class="mt-4 p-3 bg-black border border-gray-800 text-sm text-gray-400 min-h-[100px] whitespace-pre-wrap special-elite font-mono custom-scrollbar"><span class="opacity-30">:: Awaiting Input ::</span></div>
      </div>
    </div>
  </div>
</div>

<!-- ============  SCRIPTS  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<script id="reader-script">
/* ==========  CONFIG  ========== */
const TXT_FILE_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/horse.txt';
const IMAGES_JSON_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/your-images.json';

// Markdown pattern
const ENTRY_PATTERN = /^(#{1,3})\s+(.+)$/;

// LET'S TRY CATCHING DIFFERENT TAG PATTERNS
// Based on your console output, entries might use [sketch], [image], [img], etc.
const TAG_PATTERNS = {
  all: /.*/,
  fragments: /\bfragment(s)?\b|\[fragment\]/i,
  passages: /\bpassage(s)?\b|\[passage\]/i,
  sections: /\bsection(s)?\b|\[section\]/i,
  sketches: /\b(sketch(es)?|image(s)?|img(s)?|picture(s)?|photo(s)?)\b|\[(sketch|image|img|picture|photo)\]/i,
  characters: /\b(character(s)?|char(s)?|person(s)?|people)\b|\[(character|char|person)\]/i,
  dialogue: /\b(dialogue|dialog|conversation|speech|talk(ing)?)\b|\[(dialogue|dialog|speech)\]/i,
  scenes: /\b(scene(s)?|moment(s)?|sequence(s)?|part(s)?)\b|\[(scene|moment|sequence)\]/i,
  settings: /\b(setting(s)?|location(s)?|place(s)?|where|environment)\b|\[(setting|location|place)\]/i,
  chapters: /\b(chapter(s)?|part(s)?|section(s)?)\b|\[(chapter|part)\]/i,
  notes: /\b(note(s)?|comment(s)?|annotation(s)?)\b|\[(note|comment|annotation)\]/i,
  quotes: /\b(quote(s)?|saying(s)?|citation(s)?)\b|\[(quote|saying|citation)\]/i
};

/* ==========  STATE  ========== */
window.readerEntries = [];
window.readerCurrentIndex = 0;
let currentFilter = 'all';
let searchQuery = '';
let searchResults = [];
let isSearching = false;
let isIndexVisible = false;
let searchTimeout = null;
let imagesData = [];

/* ==========  DEBUG FUNCTIONS  ========== */
function debugLog(message, data = null) {
  console.log(`[DEBUG] ${message}`, data || '');
}

function showAllTagsInContent() {
  debugLog('=== ALL TAGS FOUND IN CONTENT ===');
  const allTagsFound = new Set();
  
  window.readerEntries.forEach((entry, index) => {
    if (entry.tags && entry.tags.length > 0) {
      debugLog(`Entry ${index} ("${entry.title.substring(0, 40)}..."):`, entry.tags);
      entry.tags.forEach(tag => allTagsFound.add(tag));
    }
  });
  
  debugLog('=== UNIQUE TAGS FOUND ===', Array.from(allTagsFound));
  return Array.from(allTagsFound);
}

/* ==========  DOM  ========== */
const searchBox = document.getElementById('searchBox');
const searchStats = document.getElementById('searchStats');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const randomBtn = document.getElementById('randomBtn');
const indexBtn = document.getElementById('indexBtn');
const dateNav = document.getElementById('dateNav');
const entryInfo = document.getElementById('entryInfo');
const loadingDiv = document.getElementById('loading');
const contentDiv = document.getElementById('content');

/* ==========  LOAD DATA  ========== */
async function loadText() {
  try {
    debugLog('Starting load...');
    
    // Load text
    const textRes = await fetch(TXT_FILE_URL);
    if (!textRes.ok) throw new Error('Text file not found');
    
    let text = await textRes.text();
    debugLog('Text loaded, length:', text.length);
    
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    parseEntries(text);
    
    // Try to load images
    try {
      const imagesRes = await fetch(IMAGES_JSON_URL);
      if (imagesRes.ok) {
        imagesData = await imagesRes.json();
        debugLog('Images JSON loaded, type:', typeof imagesData);
        if (Array.isArray(imagesData)) {
          debugLog('Images array length:', imagesData.length);
          debugLog('First image:', imagesData[0]);
        } else if (imagesData && typeof imagesData === 'object') {
          debugLog('Images object keys:', Object.keys(imagesData).slice(0, 5));
          debugLog('First image value:', Object.values(imagesData)[0]);
        }
      } else {
        debugLog('Images JSON not found or error:', imagesRes.status);
      }
    } catch (imageError) {
      debugLog('Image load error:', imageError.message);
    }
    
    loadingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    
    debugLog(`Parsed ${window.readerEntries.length} entries`);
    
    // Show what tags were actually found
    const foundTags = showAllTagsInContent();
    
    // DYNAMICALLY CREATE FILTER BUTTONS based on found tags
    createFilterButtons(foundTags);
    
    if (window.readerEntries.length > 0) {
      showEntry(window.readerEntries[0].id);
    }
    
    // Setup UI
    styleActiveFilter(document.querySelector('.filter-btn[data-filter="all"]'));
    buildIndex();
    updateUIState();
    
    // Setup event listeners
    setupEventListeners();
    
  } catch (err) {
    console.error('Load error:', err);
    loadingDiv.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  }
}

/* ==========  DYNAMIC FILTER BUTTONS ========== */
function createFilterButtons(foundTags) {
  const filterContainer = document.getElementById('filterBtns');
  if (!filterContainer) return;
  
  // Clear existing buttons (keep All)
  const allBtn = filterContainer.querySelector('.filter-btn[data-filter="all"]');
  filterContainer.innerHTML = '';
  
  // Add All button back
  if (allBtn) {
    filterContainer.appendChild(allBtn);
  } else {
    const allButton = document.createElement('button');
    allButton.className = 'filter-btn px-3 py-1 border text-xs uppercase';
    allButton.dataset.filter = 'all';
    allButton.textContent = 'All';
    filterContainer.appendChild(allButton);
  }
  
  // Add buttons for each found tag
  foundTags.forEach(tag => {
    const button = document.createElement('button');
    button.className = 'filter-btn px-3 py-1 border text-xs uppercase';
    button.dataset.filter = tag;
    button.textContent = tag;
    filterContainer.appendChild(button);
  });
  
  debugLog('Created filter buttons for tags:', foundTags);
}

/* ==========  SEARCH - WORKING VERSION ========== */
function setupEventListeners() {
  // Search with better handling
  searchBox.addEventListener('input', function(e) {
    performSearch(e.target.value);
  });
  
  // Add enter key support
  searchBox.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      performSearch(this.value);
    }
  });
}

function performSearch(query) {
  const trimmedQuery = query.trim();
  debugLog('Searching for:', trimmedQuery);
  
  if (!trimmedQuery) {
    isSearching = false;
    searchResults = [];
    updateUIState();
    
    // Show current or first entry
    const pool = getFilteredEntries();
    if (pool.length > 0) {
      const entryToShow = window.readerCurrentIndex > 0 ? 
        window.readerCurrentIndex : pool[0].id;
      showEntry(entryToShow);
    }
    return;
  }
  
  isSearching = true;
  searchQuery = trimmedQuery;
  
  // Simple but effective search
  const pool = getFilteredEntries();
  const queryLower = trimmedQuery.toLowerCase();
  
  searchResults = pool.filter(entry => {
    const searchText = (entry.content + ' ' + entry.title).toLowerCase();
    return searchText.includes(queryLower);
  });
  
  debugLog(`Search results: ${searchResults.length} of ${pool.length} entries`);
  
  updateUIState();
  
  if (searchResults.length > 0) {
    showEntry(searchResults[0].id);
  } else {
    contentDiv.innerHTML = `
      <div class="text-center mt-10 p-6 border border-gray-800 rounded-lg">
        <div class="text-gray-500 text-lg mb-2">No matches found for "${trimmedQuery}"</div>
        <div class="text-sm text-gray-600">
          Searched ${pool.length} entries<br>
          Try different keywords or check spelling
        </div>
      </div>`;
    entryInfo.innerHTML = `<div class="text-xs text-gray-500">Search: "${trimmedQuery}" - 0 results</div>`;
  }
}

function highlightText(text, query) {
  if (!query) return text;
  
  try {
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return text.replace(regex, '<span class="highlight" style="background:var(--red); color:black; padding:0 2px;">$1</span>');
  } catch (e) {
    debugLog('Highlight error:', e);
    return text;
  }
}

/* ==========  PARSE ENTRIES  ========== */
function parseEntries(text) {
  const lines = text.split('\n');
  let current = null;
  let id = 0;
  
  debugLog('Parsing lines:', lines.length);
  
  lines.forEach((line, lineNum) => {
    const m = line.match(ENTRY_PATTERN);
    if (m) {
      // Save previous entry if exists
      if (current && current.content.trim()) {
        detectTags(current);
        window.readerEntries.push(current);
      }
      
      // Start new entry
      current = {
        id: ++id,
        title: m[2].trim(),
        headingLevel: m[1].length,
        content: line + '\n',
        tags: [],
        images: []
      };
    } else if (current) {
      // Continue current entry
      current.content += line + '\n';
    }
  });
  
  // Don't forget the last entry
  if (current && current.content.trim()) {
    detectTags(current);
    window.readerEntries.push(current);
  }
  
  debugLog(`Total entries parsed: ${window.readerEntries.length}`);
}

function detectTags(entry) {
  const detectedTags = [];
  
  // Check each tag pattern
  for (const [tag, pattern] of Object.entries(TAG_PATTERNS)) {
    if (tag !== 'all') {
      const matches = pattern.test(entry.content);
      if (matches) {
        detectedTags.push(tag);
        // Debug specific tags
        if (['sketches', 'dialogue', 'characters', 'chapters'].includes(tag)) {
          debugLog(`Tag "${tag}" matched in: "${entry.title.substring(0, 30)}..."`);
        }
      }
    }
  }
  
  entry.tags = detectedTags;
  
  // Find images for ANY entry (not just sketches)
  if (imagesData && (detectedTags.includes('sketches') || entry.content.toLowerCase().includes('image') || entry.content.toLowerCase().includes('img'))) {
    entry.images = findImagesForEntry(entry);
    if (entry.images.length > 0) {
      debugLog(`Found ${entry.images.length} images for: "${entry.title}"`);
    }
  }
}

function findImagesForEntry(entry) {
  if (!imagesData) return [];
  
  const foundImages = [];
  const entryText = entry.title.toLowerCase() + ' ' + entry.content.toLowerCase();
  
  // Function to add image
  const addImage = (img, source, index) => {
    const imageUrl = img.url || img.src || img.path || img.filename || img.link || source;
    if (imageUrl && (imageUrl.includes('http') || imageUrl.includes('.jpg') || imageUrl.includes('.png') || imageUrl.includes('.gif'))) {
      foundImages.push({
        url: imageUrl,
        title: img.title || img.caption || img.description || `Image ${index + 1}`,
        description: img.description || img.alt || img.caption || ''
      });
      return true;
    }
    return false;
  };
  
  // Handle array format
  if (Array.isArray(imagesData)) {
    debugLog('Searching in images array, length:', imagesData.length);
    
    // Try to match by keywords in entry text
    imagesData.forEach((img, index) => {
      const imgKeywords = (img.title || img.description || img.tags || '').toLowerCase();
      if (imgKeywords && entryText.includes(imgKeywords.substring(0, 20))) {
        addImage(img, `array[${index}]`, index);
      }
    });
    
    // If no matches, assign by index
    if (foundImages.length === 0 && imagesData.length > 0) {
      const allSketches = window.readerEntries.filter(e => 
        e.tags.includes('sketches') || e.content.toLowerCase().includes('sketch') || e.content.toLowerCase().includes('image')
      );
      const sketchIndex = allSketches.findIndex(e => e.id === entry.id);
      
      if (sketchIndex >= 0 && sketchIndex < imagesData.length) {
        addImage(imagesData[sketchIndex], `array[${sketchIndex}]`, sketchIndex);
      }
    }
  }
  // Handle object format
  else if (typeof imagesData === 'object') {
    debugLog('Searching in images object, keys:', Object.keys(imagesData).length);
    
    Object.entries(imagesData).forEach(([key, img], index) => {
      addImage(img, key, index);
    });
  }
  
  return foundImages;
}

function getFilteredEntries() {
  let entries = window.readerEntries;
  
  if (currentFilter !== 'all') {
    const filtered = entries.filter(e => e.tags.includes(currentFilter));
    return filtered;
  }
  
  return entries;
}

/* ==========  DISPLAY FUNCTIONS  ========== */
function showEntry(entryId) {
  const entry = window.readerEntries.find(x => x.id === entryId);
  if (!entry) return;
  
  window.readerCurrentIndex = entryId;
  
  debugLog(`Showing entry ${entryId}: "${entry.title}"`, {
    tags: entry.tags,
    images: entry.images?.length || 0
  });
  
  let displayContent = entry.content;
  
  // Apply highlighting if searching
  if (isSearching && searchQuery) {
    displayContent = highlightText(displayContent, searchQuery);
  }
  
  // Process markdown formatting
  const html = displayContent.split('\n').map(line => {
    const trimmed = line.trim();
    if (!trimmed) return '<br>';
    
    const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const headingText = headingMatch[2];
      const headingClass = level === 1 ? 'text-2xl font-bold mt-6 mb-4' :
                          level === 2 ? 'text-xl font-bold mt-5 mb-3' :
                          'text-lg font-bold mt-4 mb-2';
      return `<h${level} class="${headingClass} special-elite" style="color:var(--red)">${headingText}</h${level}>`;
    }
    
    return `<p class="mb-4 leading-relaxed">${trimmed}</p>`;
  }).join('');
  
  // Add images if available
  let imagesHtml = '';
  if (entry.images && entry.images.length > 0) {
    debugLog(`Displaying ${entry.images.length} images for entry`);
    imagesHtml = '<div class="my-8 p-4 border-2 border-gray-700 rounded-xl bg-gray-900">';
    imagesHtml += '<h3 class="text-lg font-bold mb-4 text-gray-300 border-b border-gray-700 pb-2">üì∑ Associated Images</h3>';
    imagesHtml += '<div class="grid grid-cols-1 md:grid-cols-2 gap-4">';
    
    imagesHtml += entry.images.map(img => `
      <div class="border border-gray-700 rounded-lg overflow-hidden bg-black hover:bg-gray-900 transition-colors">
        <img src="${img.url}" 
             alt="${img.description || img.title}" 
             class="w-full h-48 object-cover hover:scale-105 transition-transform duration-300"
             loading="lazy"
             onerror="console.error('Image failed:', this.src); this.onerror=null; this.src='https://placehold.co/400x300/111/666?text=Image+Error'; this.className='w-full h-48 object-contain bg-gray-900';">
        <div class="p-3">
          <div class="font-semibold text-gray-300 text-sm mb-1 truncate">${img.title || 'Untitled'}</div>
          ${img.description ? `<div class="text-xs text-gray-500 truncate">${img.description}</div>` : ''}
        </div>
      </div>
    `).join('');
    
    imagesHtml += '</div></div>';
  }
  
  contentDiv.innerHTML = html + imagesHtml;
  
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === entryId);
  const words = entry.content.replace(/<[^>]*>/g, '').trim().split(/\s+/).length;
  
  // Tag styling with fallback
  const tagStyles = {
    'fragments': 'border-red-400 text-red-400',
    'passages': 'border-red-500 text-red-500', 
    'sections': 'border-red-600 text-red-600',
    'sketches': 'border-red-700 text-red-700 bg-red-900/20',
    'characters': 'border-purple-500 text-purple-400',
    'dialogue': 'border-blue-500 text-blue-400',
    'scenes': 'border-green-500 text-green-400',
    'settings': 'border-yellow-500 text-yellow-400',
    'chapters': 'border-indigo-500 text-indigo-400',
    'notes': 'border-gray-500 text-gray-400',
    'quotes': 'border-pink-500 text-pink-400'
  };
  
  entryInfo.innerHTML = `
    <div class="flex flex-col gap-1">
      <div>
        <span class="text-xs text-gray-500 uppercase tracking-widest">HORSE ARCHIVE</span>
        <span class="ml-2 font-bold text-xl special-elite" style="color:var(--red)">${entry.title}</span>
      </div>
      <div class="text-xs text-gray-400 flex items-center gap-2 flex-wrap">
        ${isSearching ? `Search result ${idx + 1}/${searchResults.length}` : `Entry ${idx + 1}/${pool.length}`}
        <span>‚Ä¢</span>${words} words
        ${entry.images?.length > 0 ? `<span class="text-red-400">üì∑${entry.images.length}</span>` : ''}
        ${entry.tags.length > 0 ? `<span class="ml-2 flex gap-1 flex-wrap">
          ${entry.tags.map(t => {
            const style = tagStyles[t] || 'border-gray-600 text-gray-600';
            return `<span class="px-2 py-1 border text-[10px] uppercase ${style}">${t}</span>`;
          }).join('')}
        </span>` : ''}
      </div>
    </div>`;
  
  // Update navigation buttons
  updateNavigationButtons(pool, idx);
  
  contentDiv.scrollTop = 0;
  if (isIndexVisible) buildIndex();
}

function updateNavigationButtons(pool, currentIndex) {
  if (prevBtn) {
    prevBtn.disabled = currentIndex <= 0;
    prevBtn.style.opacity = currentIndex <= 0 ? '0.5' : '1';
  }
  if (nextBtn) {
    nextBtn.disabled = currentIndex >= pool.length - 1;
    nextBtn.style.opacity = currentIndex >= pool.length - 1 ? '0.5' : '1';
  }
}

/* ==========  FILTER HANDLING  ========== */
function setupFilterListeners() {
  const filterContainer = document.getElementById('filterBtns');
  if (!filterContainer) {
    console.error('Filter container not found!');
    return;
  }
  
  filterContainer.addEventListener('click', function(e) {
    if (e.target.classList.contains('filter-btn')) {
      const filter = e.target.dataset.filter;
      debugLog(`Filter clicked: ${filter}`);
      handleFilterChange(filter, e.target);
    }
  });
}

function handleFilterChange(filter, button) {
  currentFilter = filter;
  
  // Style the active button
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.style.background = 'transparent';
    btn.style.borderColor = '#333';
    btn.style.color = '#666';
  });
  
  button.style.background = 'var(--red)';
  button.style.color = 'black';
  button.style.borderColor = 'var(--red)';
  
  // Clear search
  searchBox.value = '';
  isSearching = false;
  searchQuery = '';
  
  const filtered = getFilteredEntries();
  debugLog(`Filter "${filter}" applied: ${filtered.length} entries`);
  
  updateUIState();
  
  if (filtered.length > 0) {
    showEntry(filtered[0].id);
  } else {
    contentDiv.innerHTML = `
      <div class="text-center mt-10 p-6 border border-gray-800 rounded-lg">
        <div class="text-gray-500 text-lg mb-2">No entries tagged as "${filter}"</div>
        <div class="text-sm text-gray-600">
          ${window.readerEntries.length} total entries available<br>
          Try the "All" filter to see everything
        </div>
      </div>`;
    entryInfo.innerHTML = `<div class="text-xs text-gray-500">Filter: ${filter} - 0 entries</div>`;
  }
}

/* ==========  UI FUNCTIONS  ========== */
function updateUIState() {
  if (isSearching) {
    searchStats.textContent = `${searchResults.length} match${searchResults.length !== 1 ? 'es' : ''}`;
  } else {
    const count = getFilteredEntries().length;
    searchStats.textContent = currentFilter !== 'all' ? `${count} ${currentFilter}` : `${count} total`;
  }
  
  if (isIndexVisible) {
    buildIndex();
  }
}

function buildIndex() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  dateNav.innerHTML = '';
  
  if (pool.length === 0) {
    dateNav.innerHTML = '<div class="p-3 text-gray-500 text-sm">No entries to display</div>';
    return;
  }
  
  pool.forEach(entry => {
    const div = document.createElement('div');
    div.className = 'p-3 border-b border-gray-700 cursor-pointer hover:bg-gray-900 transition-colors';
    
    if (entry.id === window.readerCurrentIndex) {
      div.style.background = '#1a1a1a';
      div.style.borderLeft = '3px solid var(--red)';
    }
    
    const preview = entry.content.replace(/<[^>]*>/g, '').substring(0, 60).replace(/\n/g, ' ') + '...';
    const imageCount = entry.images?.length ? ` üì∑${entry.images.length}` : '';
    
    div.innerHTML = `
      <div class="text-sm font-bold text-gray-300 mb-1 truncate special-elite">
        ${entry.title}${imageCount}
      </div>
      <div class="text-xs text-gray-600 font-mono truncate">${preview}</div>
      ${entry.tags.length > 0 ? 
        `<div class="mt-1 flex gap-1 flex-wrap">
          ${entry.tags.slice(0, 3).map(t => 
            `<span class="text-[9px] px-1 py-0.5 border border-gray-700 text-gray-500">${t}</span>`
          ).join('')}
        </div>` : ''}
    `;
    
    div.addEventListener('click', () => showEntry(entry.id));
    dateNav.appendChild(div);
  });
}

function styleActiveFilter(btn) {
  if (!btn) return;
  document.querySelectorAll('.filter-btn').forEach(b => {
    b.style.background = 'transparent';
    b.style.borderColor = '#333';
    b.style.color = '#666';
  });
  
  btn.style.background = 'var(--red)';
  btn.style.color = 'black';
  btn.style.borderColor = 'var(--red)';
}

/* ==========  NAVIGATION  ========== */
function showRandomEntry() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (!pool.length) return;
  
  let randomIdx;
  do {
    randomIdx = Math.floor(Math.random() * pool.length);
  } while (pool[randomIdx].id === window.readerCurrentIndex && pool.length > 1);
  
  showEntry(pool[randomIdx].id);
}

function navigateEntries(dir) {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (pool.length === 0) return;
  
  const idx = pool.findIndex(x => x.id === window.readerCurrentIndex);
  const newIdx = dir === 'next' ? idx + 1 : idx - 1;
  
  if (newIdx >= 0 && newIdx < pool.length) {
    showEntry(pool[newIdx].id);
  }
}

/* ==========  INITIALIZATION  ========== */
document.addEventListener('DOMContentLoaded', function() {
  debugLog('DOM loaded, starting...');
  loadText();
  
  // Setup filter listeners after a delay (dynamic buttons might not be ready)
  setTimeout(() => {
    setupFilterListeners();
  }, 500);
  
  // Navigation buttons
  if (prevBtn) prevBtn.addEventListener('click', () => navigateEntries('prev'));
  if (nextBtn) nextBtn.addEventListener('click', () => navigateEntries('next'));
  if (randomBtn) randomBtn.addEventListener('click', showRandomEntry);
  if (indexBtn) indexBtn.addEventListener('click', () => {
    isIndexVisible = !isIndexVisible;
    dateNav.classList.toggle('hidden');
    if (isIndexVisible) buildIndex();
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
    
    if (e.key === 'ArrowLeft') navigateEntries('prev');
    if (e.key === 'ArrowRight') navigateEntries('next');
    if (e.key.toLowerCase() === 'r') showRandomEntry();
    if (e.key === 'Escape' && isIndexVisible) {
      dateNav.classList.add('hidden');
      isIndexVisible = false;
    }
  });
});

// Quick test to see file content
async function quickTest() {
  try {
    const res = await fetch(TXT_FILE_URL);
    const text = await res.text();
    const lines = text.split('\n');
    
    // Find lines with common tags
    const tagLines = [];
    lines.forEach((line, i) => {
      const lowerLine = line.toLowerCase();
      if (lowerLine.includes('[sketch]') || lowerLine.includes('[image]') || 
          lowerLine.includes('[dialogue]') || lowerLine.includes('[character]')) {
        tagLines.push(`Line ${i}: ${line.substring(0, 80)}`);
      }
    });
    
    if (tagLines.length > 0) {
      debugLog('Found tagged lines:', tagLines.slice(0, 5));
    } else {
      debugLog('No [tag] notation found in file');
      
      // Look for other patterns
      const sketchLines = lines.filter(l => l.toLowerCase().includes('sketch'));
      const dialogueLines = lines.filter(l => l.toLowerCase().includes('dialogue'));
      
      debugLog('Lines with "sketch":', sketchLines.length);
      debugLog('Lines with "dialogue":', dialogueLines.length);
      
      if (sketchLines.length > 0) {
        debugLog('Example sketch line:', sketchLines[0].substring(0, 100));
      }
    }
  } catch (err) {
    console.error('Quick test failed:', err);
  }
}

// Run quick test
setTimeout(quickTest, 1000);
</script>

<script id="ai-script">
/* ==========  AI CONFIG  ========== */
const NVIDIA_MODELS={
  stable:"meta/llama-3.3-70b-instruct",
  backup:"nvidia/llama-3.1-nemotron-70b-instruct"
};
let currentModel=NVIDIA_MODELS.stable,aiContext='current';
const apiKeyInput=document.getElementById('apiKeyInput');
const aiInput=document.getElementById('aiInput');
const askAiBtn=document.getElementById('askAiBtn');
const aiResponseDiv=document.getElementById('aiResponse');
const contextInfo=document.getElementById('contextInfo');

/* ==========  INIT  ========== */
if(localStorage.getItem('horse_nvidia_key'))apiKeyInput.value=localStorage.getItem('horse_nvidia_key');
apiKeyInput.addEventListener('input',e=>localStorage.setItem('horse_nvidia_key',e.target.value));

/* ==========  TRANSMIT  ========== */
askAiBtn.addEventListener('click',async()=>{
  const key=apiKeyInput.value.trim(),msg=aiInput.value.trim();
  if(!key){aiResponseDiv.innerHTML='<p class="text-red-500">Please enter an NVIDIA API Key.</p>';return;}
  if(!msg)return;
  if(!window.readerEntries?.length){aiResponseDiv.innerHTML='<p class="text-red-500">horse.txt not loaded yet.</p>';return;}
  askAiBtn.disabled=true;askAiBtn.textContent='TRANSMITTING...';
  aiResponseDiv.innerHTML='<p class="animate-pulse" style="color:var(--red)">Consulting Llama...</p>';
  try{
    let ctx='';
    if(aiContext==='current'){
      const e=window.readerEntries.find(x=>x.id===window.readerCurrentIndex);
      if(e)ctx=`CONTEXT (Current ‚Äì ${e.title}):\n${e.content.substring(0,4000)}\n\n---\n`;
    }else if(aiContext==='all'){
      ctx=`CONTEXT (Outline):\n${window.readerEntries.map(x=>`- ${x.title} (${x.tags.join(', ')})`).join('\n')}\n\n---\n`;
    }
    const proxy='https://corsproxy.io/?'+encodeURIComponent('https://integrate.api.nvidia.com/v1/chat/completions');
    const res=await fetch(proxy,{
      method:'POST',
      headers:{Authorization:`Bearer ${key}`,'Content-Type':'application/json'},
      body:JSON.stringify({
        model:currentModel,
        messages:[
          {role:'system',content:'You are an editor for HORSE, a narrative where reality and dreams blur. Analyse via surrealism. Be bold, concise, literary.'},
          {role:'user',content:ctx+'User Question: '+msg}
        ],
        temperature:.6,top_p:1,max_tokens:1024
      })
    });
    if(!res.ok){if(res.status===404)throw new Error('404 Switch');const t=await res.text();let m=t;try{m=JSON.parse(t).error?.message||t;}catch{e}throw new Error(m);}
    const data=await res.json();
    let txt=data.choices[0].message.content;
    txt=txt.replace(/\*\*(.*?)\*\*/g,'<strong style="color:var(--red)">$1</strong>').replace(/\n/g,'<br>');
    aiResponseDiv.innerHTML=txt;
  }catch(err){
    console.error(err);
    if(err.message.includes('404')||err.message.includes('Switch')){
      currentModel=NVIDIA_MODELS.backup;
      aiResponseDiv.innerHTML='<p style="color:#888">Primary model unavailable. Switched to Backup.<br><strong>Please click Transmit again.</strong></p>';
    }else{
      aiResponseDiv.innerHTML=`<p style="color:var(--red)">Error: ${err.message}</p>`;
    }
  }finally{askAiBtn.disabled=false;askAiBtn.textContent='TRANSMIT';}
});

/* ==========  CONTEXT BUTTONS  ========== */
document.addEventListener('click',e=>{
  if(!e.target.classList.contains('context-btn'))return;
  document.querySelectorAll('.context-btn').forEach(b=>{b.style.background='var(--dark-grey)';b.style.color='#888';b.style.borderColor='#333';});
  e.target.style.background='var(--red)';e.target.style.color='black';e.target.style.borderColor='var(--red)';
  aiContext=e.target.dataset.context;
  contextInfo.textContent=`Context: ${aiContext.toUpperCase()} (${aiContext==='current'?'Reading current entry':aiContext==='all'?'Reading all titles':'No context'})`;
});
</script>
</body>
</html>
