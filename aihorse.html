<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>reader/horse ai is under re-construction... </title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

  <style>
    :root {
      --red: #ff0033;
      --black: #0a0a0a;
      --dark-grey: #121212;
      --white: #d1d1d1;
    }
    ::selection {
      background: var(--red);
      color: var(--black);
      text-shadow: none;
    }
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: 'Nova Mono', monospace;
      background: var(--black);
      color: var(--white);
      margin: 0;
      touch-action: manipulation;
    }
    /* CRT scanlines */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,.15) 50%),
                  linear-gradient(90deg, rgba(255,0,0,.04), rgba(0,255,0,.02), rgba(0,0,255,.04));
      background-size: 100% 3px, 3px 100%;
      z-index: 999;
      pointer-events: none;
    }
    .highlight {
      background: var(--red);
      color: var(--black);
      padding: 1px 3px;
    }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: var(--black); }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--red); border-radius: 3px; }
    input, textarea, button { font-family: 'Nova Mono', monospace; }
    button { user-select: none; cursor: pointer; }
    .special-elite { font-family: 'Special Elite', serif; }
  </style>
</head>

<body class="bg-black text-gray-300">
<!-- HEADER -->
<div class="sticky top-0 z-50 w-full pt-4 pb-4 px-4 sm:px-6 md:px-8 border-b border-red-800 bg-black">
  <div class="flex justify-between items-center max-w-full">
    <h1 class="text-3xl font-bold special-elite" style="color: var(--red);">‚ö° horse reader ai is being rebuilt...‚ö°</h1>
    <a href="https://inkrealm.info"
       class="text-xs font-mono border border-gray-600 px-3 py-1 hover:bg-red-600 hover:text-black hover:border-red-600 transition-all duration-300 uppercase tracking-widest no-underline text-gray-400">
      Return to Realm
    </a>
  </div>
</div>

<!-- TWO-COLUMN LAYOUT -->
<div id="horse-layout" class="flex flex-col md:flex-row w-full h-[calc(100vh-80px)] overflow-hidden bg-black">
  <!-- LEFT: READER -->
  <div class="flex-1 flex flex-col h-full border-r border-gray-800 relative min-w-0">
    <div id="loading" class="absolute inset-0 flex items-center justify-center text-xl" style="color: var(--red);">
      Loading horse.txt ...
    </div>
    <div id="content" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-10 text-base md:text-lg leading-relaxed whitespace-pre-wrap special-elite custom-scrollbar" style="display:none;"></div>
    <div id="entryInfo" class="p-3 border-t border-gray-800 text-xs text-gray-500 bg-black flex-shrink-0"></div>
  </div>
  
  <!-- RIGHT: IMAGES SIDEBAR (Hidden by default, shows for sketches) -->
  <div id="imagesSidebar" class="hidden md:w-80 lg:w-96 border-l border-gray-800 bg-black overflow-y-auto">
    <!-- Content will be populated by JavaScript -->
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="w-full md:w-[400px] flex flex-col h-full bg-[#0a0a0a] border-l border-gray-800 flex-shrink-0">
    <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">
      <!-- NAV -->
      <div class="flex items-center justify-between mb-6 gap-2">
        <button id="prevBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚Üê Prev</button>
        <button id="randomBtn" class="px-4 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚ö°</button>
        <button id="nextBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">Next ‚Üí</button>
      </div>

      <!-- SEARCH -->
      <div class="mb-6">
        <input type="text" id="searchBox" class="w-full bg-[#111] border border-gray-700 p-3 text-white focus:border-red-500 focus:outline-none transition-colors" placeholder="Search text...">
        <div class="flex justify-between items-center mt-2">
          <div id="searchStats" class="text-xs text-gray-500 h-4"></div>
          <button id="indexBtn" class="text-xs text-gray-500 hover:text-red-500 uppercase tracking-widest border-b border-transparent hover:border-red-500">Toggle Index</button>
        </div>
      </div>

      <!-- FILTERS -->
      <div id="filterBtns" class="flex flex-wrap gap-2 mb-6 pb-6 border-b border-gray-800">
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="all">All</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="fragments">Fragments</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="passages">Passages</button>
       <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sections">Sections</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sketches">Sketches</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="characters">Characters</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="dialogue">Dialogue</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="scenes">Scenes</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="settings">Settings</button>
      </div>

      <!-- INDEX -->
      <div id="dateNav" class="hidden mb-6 max-h-60 overflow-y-auto border border-gray-800 bg-[#111] custom-scrollbar"></div>

      <!-- NVIDIA AI -->
      <div class="mt-2">
        <h2 class="text-xl font-bold mb-4 text-gray-600 special-elite">AI EDITOR</h2>
        <input type="password" id="apiKeyInput" class="w-full bg-black border border-gray-800 p-2 text-xs text-red-500 font-mono mb-4 focus:outline-none focus:border-red-900" placeholder="NVIDIA API KEY...">
        <div class="flex gap-2 mb-2">
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="current">Current</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="all">Outline</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="none">None</button>
        </div>
        <p id="contextInfo" class="text-[10px] text-gray-600 mb-3 text-right">Target: Current Entry</p>
        <textarea id="aiInput" class="w-full bg-[#111] border border-gray-800 p-3 text-sm text-gray-300 focus:border-red-500 focus:outline-none min-h-[80px] mb-2" placeholder="Enter prompt..."></textarea>
        <button id="askAiBtn" class="w-full bg-red-900/20 hover:bg-red-900/40 border border-red-900 text-red-500 py-2 text-xs font-bold tracking-widest transition-all">TRANSMIT</button>
        <div id="aiResponse" class="mt-4 p-3 bg-black border border-gray-800 text-sm text-gray-400 min-h-[100px] whitespace-pre-wrap special-elite font-mono custom-scrollbar"><span class="opacity-30">:: Awaiting Input ::</span></div>
      </div>
    </div>
  </div>
</div>

<!-- ============  SCRIPTS  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<script id="reader-script">
/* ==========  CONFIG  ========== */
const TXT_FILE_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/horse.txt';
const IMAGES_JSON_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/your-images.json';

// Markdown pattern - captures headings (#, ##, ###) and their content
const ENTRY_PATTERN = /^(#{1,3})\s+(.+)$/;

// Updated for novel structure - with better regex patterns
const TAG_PATTERNS = {
  all: /.*/,
  fragments: /\bfragment(s)?\b|\[fragment\]/i,
  passages: /\bpassage(s)?\b|\[passage\]/i,
  sections: /\bsection(s)?\b|\[section\]/i,
  sketches: /\bsketch(es)?\b|\[sketch\]|\[image\]/i,
  characters: /\bcharacter(s)?\b|\[character\]|\[char\]/i,    // Changed vignettes to characters
  dialogue: /\bdialogue\b|\[dialogue\]|\[dialog\]|\[speech\]/i, // New novel tag
  scenes: /\bscene(s)?\b|\[scene\]/i,                         // New novel tag
  settings: /\bsetting(s)?\b|\[setting\]|\[location\]/i        // New novel tag
};

/* ==========  STATE  ========== */
window.readerEntries = [];
window.readerCurrentIndex = 0;
let currentFilter = 'all';
let searchQuery = '';
let searchResults = [];
let isSearching = false;
let isIndexVisible = false;
let searchTimeout = null;
let imagesData = [];

/* ==========  DOM  ========== */
const searchBox = document.getElementById('searchBox');
const searchStats = document.getElementById('searchStats');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const randomBtn = document.getElementById('randomBtn');
const indexBtn = document.getElementById('indexBtn');
const dateNav = document.getElementById('dateNav');
const entryInfo = document.getElementById('entryInfo');
const loadingDiv = document.getElementById('loading');
const contentDiv = document.getElementById('content');

/* ==========  INITIALIZATION  ========== */
function initializeDOMReferences() {
  // Ensure all DOM elements are properly referenced
  window.searchBox = document.getElementById('searchBox') || searchBox;
  window.searchStats = document.getElementById('searchStats') || searchStats;
  window.prevBtn = document.getElementById('prevBtn') || prevBtn;
  window.nextBtn = document.getElementById('nextBtn') || nextBtn;
  window.randomBtn = document.getElementById('randomBtn') || randomBtn;
  window.indexBtn = document.getElementById('indexBtn') || indexBtn;
  window.dateNav = document.getElementById('dateNav') || dateNav;
  window.entryInfo = document.getElementById('entryInfo') || entryInfo;
  window.loadingDiv = document.getElementById('loading') || loadingDiv;
  window.contentDiv = document.getElementById('content') || contentDiv;
}

/* ==========  SEARCH UTILITIES - FIXED ========== */
function parseSearchQuery(q) {
  const terms = { and: [], or: [], not: [], exact: [] };
  if (!q) return terms;
  
  // Extract exact matches "like this"
  const exactMatches = q.match(/"[^"]+"/g);
  if (exactMatches) {
    exactMatches.forEach(m => {
      terms.exact.push(m.replace(/"/g, '').toLowerCase());
      q = q.replace(m, '');
    });
  }
  
  let op = 'and';
  const words = q.toLowerCase().split(/\s+/).filter(w => w.trim() && w !== 'and' && w !== 'or');
  
  words.forEach(w => {
    if (w === 'and') op = 'and';
    else if (w === 'or') op = 'or';
    else if (w.startsWith('-')) terms.not.push(w.slice(1));
    else terms[op].push(w);
  });
  
  return terms;
}

function matchesSearch(e, terms) {
  const txt = (e.content + ' ' + e.title).toLowerCase();
  
  // NOT terms - if any NOT term is found, exclude
  if (terms.not.some(x => txt.includes(x))) return false;
  
  // EXACT phrases - all must be present
  if (terms.exact.length > 0 && !terms.exact.every(x => txt.includes(x))) return false;
  
  // AND terms - all must be present
  if (terms.and.length > 0 && !terms.and.every(x => txt.includes(x))) return false;
  
  // OR terms - at least one must be present (if OR terms exist)
  if (terms.or.length > 0 && !terms.or.some(x => txt.includes(x))) return false;
  
  // If no search terms (after filtering), return true
  return !(terms.exact.length === 0 && terms.and.length === 0 && terms.or.length === 0);
}

function highlightText(text, query) {
  if (!query || !query.trim()) return text;
  
  const terms = parseSearchQuery(query);
  const allTerms = [...terms.exact, ...terms.and, ...terms.or]
    .filter((v, i, a) => a.indexOf(v) === i && v.length > 0);
  
  if (allTerms.length === 0) return text;
  
  let result = text;
  allTerms.sort((a, b) => b.length - a.length).forEach(t => {
    const safe = t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${safe})`, 'gi');
    result = result.replace(regex, '<span class="highlight" style="background:var(--red); color:black; padding:0 2px;">$1</span>');
  });
  
  return result;
}

function debounce(func, delay) {
  return function(...args) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => func.apply(this, args), delay);
  };
}

/* ==========  LOAD DATA  ========== */
async function loadText() {
  try {
    initializeDOMReferences();
    
    // Load text first, then images
    const textRes = await fetch(TXT_FILE_URL);
    if (!textRes.ok) throw new Error('Text file not found');
    
    let text = await textRes.text();
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    parseEntries(text);
    
    // Try to load images, but don't fail if it doesn't work
    try {
      const imagesRes = await fetch(IMAGES_JSON_URL);
      if (imagesRes.ok) {
        imagesData = await imagesRes.json();
        console.log('Images data loaded:', imagesData);
      }
    } catch (imageError) {
      console.warn('Could not load images:', imageError);
    }
    
    loadingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    
    if (window.readerEntries.length > 0) {
      showEntry(window.readerEntries[0].id);
    }
    
    // Set "All" button active
    const allBtn = document.querySelector('.filter-btn[data-filter="all"]');
    if (allBtn) styleActiveFilter(allBtn);
    
    // Setup event listeners
    setupEventListeners();
    
    buildIndex();
    updateUIState();
    
  } catch (err) {
    console.error('Load error:', err);
    loadingDiv.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  }
}

/* ==========  EVENT LISTENERS SETUP ========== */
function setupEventListeners() {
  // Remove any existing listeners first
  const newSearchBox = searchBox.cloneNode(true);
  searchBox.parentNode.replaceChild(newSearchBox, searchBox);
  window.searchBox = newSearchBox;
  
  // Setup search with debounce
  searchBox.addEventListener('input', debounce(function(e) {
    console.log('Search input:', e.target.value);
    performSearch(e.target.value);
  }, 300));
  
  // Setup filter buttons
  const filterContainer = document.getElementById('filterBtns');
  if (filterContainer) {
    filterContainer.addEventListener('click', function(e) {
      if (e.target.classList.contains('filter-btn')) {
        console.log('Filter clicked:', e.target.dataset.filter);
        handleFilterClick(e.target);
      }
    });
  }
  
  // Setup navigation buttons (already working)
  if (prevBtn) prevBtn.addEventListener('click', () => navigateEntries('prev'));
  if (nextBtn) nextBtn.addEventListener('click', () => navigateEntries('next'));
  if (randomBtn) randomBtn.addEventListener('click', showRandomEntry);
  if (indexBtn) indexBtn.addEventListener('click', toggleIndex);
  
  // Keyboard navigation
  document.addEventListener('keydown', handleKeyboardNavigation);
}

function handleFilterClick(button) {
  styleActiveFilter(button);
  currentFilter = button.dataset.filter;
  
  // Clear search when switching filters
  searchBox.value = '';
  isSearching = false;
  updateUIState();
  
  const filtered = getFilteredEntries();
  console.log(`${currentFilter} filter: ${filtered.length} entries`);
  
  if (filtered.length > 0) {
    showEntry(filtered[0].id);
  } else {
    contentDiv.innerHTML = '<div class="text-center mt-10 text-gray-500">No entries with this tag.</div>';
    entryInfo.innerHTML = '';
  }
}

function toggleIndex() {
  isIndexVisible = !isIndexVisible;
  dateNav.classList.toggle('hidden');
  if (isIndexVisible) buildIndex();
}

function handleKeyboardNavigation(e) {
  if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
  
  if (e.key === 'ArrowLeft') {
    e.preventDefault();
    navigateEntries('prev');
  }
  if (e.key === 'ArrowRight') {
    e.preventDefault();
    navigateEntries('next');
  }
  if (e.key.toLowerCase() === 'r') {
    e.preventDefault();
    showRandomEntry();
  }
  if (e.key === 'Escape' && isIndexVisible) {
    dateNav.classList.add('hidden');
    isIndexVisible = false;
  }
}

/* ==========  PARSE ENTRIES  ========== */
function parseEntries(text) {
  const lines = text.split('\n');
  let current = null;
  let id = 0;
  
  lines.forEach((line) => {
    const m = line.match(ENTRY_PATTERN);
    if (m) {
      // Save previous entry if exists
      if (current && current.content.trim()) {
        detectTags(current);
        window.readerEntries.push(current);
      }
      
      // Start new entry
      current = {
        id: ++id,
        title: m[2].trim(),
        headingLevel: m[1].length,
        content: line + '\n',
        tags: [],
        images: []
      };
    } else if (current) {
      // Continue current entry
      current.content += line + '\n';
    }
  });
  
  // Don't forget the last entry
  if (current && current.content.trim()) {
    detectTags(current);
    window.readerEntries.push(current);
  }
  
  console.log(`Parsed ${window.readerEntries.length} entries with tags:`, 
    window.readerEntries.map(e => ({ title: e.title, tags: e.tags })));
}

function detectTags(e) {
  const detectedTags = [];
  
  for (const [tag, pattern] of Object.entries(TAG_PATTERNS)) {
    if (tag !== 'all' && pattern.test(e.content)) {
      detectedTags.push(tag);
    }
  }
  
  e.tags = detectedTags;
  
  // Special handling for sketches - find associated images
  if (detectedTags.includes('sketches') && imagesData.length > 0) {
    e.images = findImagesForEntry(e);
    if (e.images.length > 0) {
      console.log(`Found ${e.images.length} images for sketch: ${e.title}`);
    }
  }
}

function findImagesForEntry(entry) {
  if (!imagesData || imagesData.length === 0) return [];
  
  const foundImages = [];
  const entryText = (entry.title + ' ' + entry.content).toLowerCase();
  
  // Try different matching strategies
  imagesData.forEach((img, index) => {
    // Check if image has a title/description that matches entry
    const imgText = (img.title || img.description || img.filename || '').toLowerCase();
    
    // Simple keyword matching
    if (imgText && entryText.includes(imgText.substring(0, 20))) {
      foundImages.push({
        url: img.url || img.path || `image_${index}.jpg`,
        title: img.title || `Image ${index + 1}`,
        description: img.description || ''
      });
    }
  });
  
  // If no matches found, you might want to associate images by index
  // For example, first sketch gets first image, etc.
  const sketchEntries = window.readerEntries.filter(e => e.tags.includes('sketches'));
  const sketchIndex = sketchEntries.findIndex(e => e.id === entry.id);
  
  if (foundImages.length === 0 && sketchIndex < imagesData.length) {
    const img = imagesData[sketchIndex];
    foundImages.push({
      url: img.url || img.path || `image_${sketchIndex}.jpg`,
      title: img.title || `Sketch Image ${sketchIndex + 1}`,
      description: img.description || `Associated with: ${entry.title}`
    });
  }
  
  return foundImages;
}

function getFilteredEntries() {
  let entries = window.readerEntries;
  
  if (currentFilter !== 'all') {
    entries = entries.filter(e => e.tags.includes(currentFilter));
  }
  
  return entries;
}

/* ==========  DISPLAY FUNCTIONS  ========== */
function showEntry(entryId) {
  const e = window.readerEntries.find(x => x.id === entryId);
  if (!e) {
    console.error('Entry not found:', entryId);
    return;
  }
  
  window.readerCurrentIndex = entryId;
  
  let displayContent = e.content;
  
  // Apply highlighting if searching
  if (isSearching && searchQuery) {
    displayContent = highlightText(displayContent, searchQuery);
  }
  
  // Process markdown formatting for display
  const html = displayContent.split('\n').map(line => {
    const trimmed = line.trim();
    if (!trimmed) return '<br>';
    
    // Check if this line is a markdown heading
    const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const headingText = headingMatch[2];
      const headingClass = level === 1 ? 'text-2xl font-bold mt-6 mb-4' :
                          level === 2 ? 'text-xl font-bold mt-5 mb-3' :
                          'text-lg font-bold mt-4 mb-2';
      return `<h${level} class="${headingClass} special-elite" style="color:var(--red)">${headingText}</h${level}>`;
    }
    
    // Regular paragraph
    return `<p class="mb-4 leading-relaxed">${trimmed}</p>`;
  }).join('');
  
  // Add images if this entry has them
  let imagesHtml = '';
  if (e.images && e.images.length > 0) {
    imagesHtml = e.images.map(img => `
      <div class="my-6 p-4 border border-gray-700 rounded-lg bg-gray-900">
        <img src="${img.url}" 
             alt="${img.description || img.title}" 
             class="w-full h-64 object-cover rounded mb-2"
             loading="lazy"
             onerror="this.onerror=null; this.src='https://placehold.co/600x400/111/666?text=Image+Not+Found';">
        <div class="text-xs text-gray-400 mt-2">
          <strong class="text-gray-300">${img.title || 'Untitled'}</strong>
          ${img.description ? `<br>${img.description}` : ''}
        </div>
      </div>
    `).join('');
  }
  
  contentDiv.innerHTML = html + imagesHtml;
  
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === entryId);
  const words = e.content.replace(/<[^>]*>/g, '').trim().split(/\s+/).length;
  
  // Tag color mapping - updated for new tags
  const tagStyles = {
    'fragments': 'border-red-400 text-red-400',
    'passages': 'border-red-500 text-red-500', 
    'sections': 'border-red-600 text-red-600',
    'sketches': 'border-red-700 text-red-700 bg-red-900/20',
    'characters': 'border-purple-500 text-purple-400',    // Updated
    'dialogue': 'border-blue-500 text-blue-400',         // New
    'scenes': 'border-green-500 text-green-400',         // New
    'settings': 'border-yellow-500 text-yellow-400'      // New
  };
  
  entryInfo.innerHTML = `
    <div class="flex flex-col gap-1">
      <div>
        <span class="text-xs text-gray-500 uppercase tracking-widest">HORSE ARCHIVE</span>
        <span class="ml-2 font-bold text-xl special-elite" style="color:var(--red)">${e.title}</span>
      </div>
      <div class="text-xs text-gray-400 flex items-center gap-2 flex-wrap">
        ${isSearching ? `Result ${idx + 1}/${searchResults.length}` : `Entry ${idx + 1}/${pool.length}`}
        <span>‚Ä¢</span>${words} words
        ${e.tags.length > 0 ? `<span class="ml-2 flex gap-1 flex-wrap">
          ${e.tags.map(t => {
            const style = tagStyles[t] || 'border-gray-600 text-gray-600';
            const icon = t === 'sketches' && e.images?.length ? ` (${e.images.length}üì∑)` : '';
            return `<span class="px-2 py-1 border text-[10px] uppercase ${style}">${t}${icon}</span>`;
          }).join('')}
        </span>` : ''}
      </div>
    </div>`;
  
  // Update button states
  updateNavigationButtons(pool, idx);
  
  contentDiv.scrollTop = 0;
  if (isIndexVisible) buildIndex();
}

function updateNavigationButtons(pool, currentIndex) {
  if (prevBtn) {
    prevBtn.disabled = currentIndex <= 0;
    prevBtn.style.opacity = currentIndex <= 0 ? '0.5' : '1';
    prevBtn.style.cursor = currentIndex <= 0 ? 'not-allowed' : 'pointer';
  }
  
  if (nextBtn) {
    nextBtn.disabled = currentIndex >= pool.length - 1;
    nextBtn.style.opacity = currentIndex >= pool.length - 1 ? '0.5' : '1';
    nextBtn.style.cursor = currentIndex >= pool.length - 1 ? 'not-allowed' : 'pointer';
  }
}

function showRandomEntry() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (!pool.length) return;
  
  let randomIdx;
  do {
    randomIdx = Math.floor(Math.random() * pool.length);
  } while (pool[randomIdx].id === window.readerCurrentIndex && pool.length > 1);
  
  showEntry(pool[randomIdx].id);
}

function navigateEntries(dir) {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (pool.length === 0) return;
  
  const idx = pool.findIndex(x => x.id === window.readerCurrentIndex);
  const newIdx = dir === 'next' ? idx + 1 : idx - 1;
  
  if (newIdx >= 0 && newIdx < pool.length) {
    showEntry(pool[newIdx].id);
  }
}

/* ==========  SEARCH FUNCTIONS - FIXED ========== */
function performSearch(q) {
  console.log('Performing search for:', q);
  searchQuery = q.trim();
  
  if (!searchQuery) {
    console.log('Clearing search');
    isSearching = false;
    searchResults = [];
    updateUIState();
    
    // Show current entry or first entry
    if (window.readerCurrentIndex > 0) {
      showEntry(window.readerCurrentIndex);
    } else if (window.readerEntries.length > 0) {
      showEntry(window.readerEntries[0].id);
    }
    return;
  }
  
  isSearching = true;
  const pool = getFilteredEntries();
  const terms = parseSearchQuery(searchQuery);
  
  console.log('Search terms:', terms);
  console.log('Pool size:', pool.length);
  
  searchResults = pool.filter(e => matchesSearch(e, terms));
  console.log('Search results:', searchResults.length);
  
  updateUIState();
  
  if (searchResults.length > 0) {
    showEntry(searchResults[0].id);
  } else {
    contentDiv.innerHTML = '<div class="text-center mt-10 text-gray-500">No matches found for "' + searchQuery + '".</div>';
    entryInfo.innerHTML = '<div class="text-xs text-gray-500">No matches found</div>';
  }
}

/* ==========  UI FUNCTIONS  ========== */
function updateUIState() {
  if (isSearching) {
    searchStats.textContent = `${searchResults.length} match${searchResults.length !== 1 ? 'es' : ''}`;
  } else {
    const count = getFilteredEntries().length;
    searchStats.textContent = currentFilter !== 'all' ? `${count} ${currentFilter}` : `${count} total`;
  }
  
  if (isIndexVisible) {
    buildIndex();
  }
}

function buildIndex() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  dateNav.innerHTML = '';
  
  if (pool.length === 0) {
    dateNav.innerHTML = '<div class="p-3 text-gray-500 text-sm">No entries to display</div>';
    return;
  }
  
  pool.forEach(e => {
    const div = document.createElement('div');
    div.className = 'p-3 border-b border-gray-700 cursor-pointer hover:bg-gray-900 transition-colors';
    
    if (e.id === window.readerCurrentIndex) {
      div.style.background = '#1a1a1a';
      div.style.borderLeft = '3px solid var(--red)';
    }
    
    const preview = e.content.replace(/<[^>]*>/g, '').substring(0, 60).replace(/\n/g, ' ') + '...';
    const imageCount = e.images?.length ? ` üì∑${e.images.length}` : '';
    const tagsPreview = e.tags.length > 0 ? 
      e.tags.slice(0, 2).map(t => `<span class="text-[9px] text-gray-500">${t}</span>`).join(' ') : '';
    
    div.innerHTML = `
      <div class="text-sm font-bold text-gray-300 mb-1 truncate special-elite">
        ${e.title}${imageCount}
      </div>
      <div class="text-xs text-gray-600 font-mono truncate">${preview}</div>
      ${tagsPreview ? `<div class="mt-1 flex gap-1">${tagsPreview}</div>` : ''}
    `;
    
    div.addEventListener('click', () => {
      showEntry(e.id);
      if (window.innerWidth < 768) {
        dateNav.classList.add('hidden');
        isIndexVisible = false;
      }
    });
    dateNav.appendChild(div);
  });
}

function styleActiveFilter(btn) {
  document.querySelectorAll('.filter-btn').forEach(b => {
    b.style.background = 'transparent';
    b.style.borderColor = '#333';
    b.style.color = '#666';
  });
  
  btn.style.background = 'var(--red)';
  btn.style.color = 'black';
  btn.style.borderColor = 'var(--red)';
}

/* ==========  INITIALIZE  ========== */
document.addEventListener('DOMContentLoaded', loadText);
</script>

<script id="ai-script">
/* ==========  AI CONFIG  ========== */
const NVIDIA_MODELS={
  stable:"meta/llama-3.3-70b-instruct",
  backup:"nvidia/llama-3.1-nemotron-70b-instruct"
};
let currentModel=NVIDIA_MODELS.stable,aiContext='current';
const apiKeyInput=document.getElementById('apiKeyInput');
const aiInput=document.getElementById('aiInput');
const askAiBtn=document.getElementById('askAiBtn');
const aiResponseDiv=document.getElementById('aiResponse');
const contextInfo=document.getElementById('contextInfo');

/* ==========  INIT  ========== */
if(localStorage.getItem('horse_nvidia_key'))apiKeyInput.value=localStorage.getItem('horse_nvidia_key');
apiKeyInput.addEventListener('input',e=>localStorage.setItem('horse_nvidia_key',e.target.value));

/* ==========  TRANSMIT  ========== */
askAiBtn.addEventListener('click',async()=>{
  const key=apiKeyInput.value.trim(),msg=aiInput.value.trim();
  if(!key){aiResponseDiv.innerHTML='<p class="text-red-500">Please enter an NVIDIA API Key.</p>';return;}
  if(!msg)return;
  if(!window.readerEntries?.length){aiResponseDiv.innerHTML='<p class="text-red-500">horse.txt not loaded yet.</p>';return;}
  askAiBtn.disabled=true;askAiBtn.textContent='TRANSMITTING...';
  aiResponseDiv.innerHTML='<p class="animate-pulse" style="color:var(--red)">Consulting Llama...</p>';
  try{
    let ctx='';
    if(aiContext==='current'){
      const e=window.readerEntries.find(x=>x.id===window.readerCurrentIndex);
      if(e)ctx=`CONTEXT (Current ‚Äì ${e.title}):\n${e.content.substring(0,4000)}\n\n---\n`;
    }else if(aiContext==='all'){
      ctx=`CONTEXT (Outline):\n${window.readerEntries.map(x=>`- ${x.title} (${x.tags.join(', ')})`).join('\n')}\n\n---\n`;
    }
    const proxy='https://corsproxy.io/?'+encodeURIComponent('https://integrate.api.nvidia.com/v1/chat/completions');
    const res=await fetch(proxy,{
      method:'POST',
      headers:{Authorization:`Bearer ${key}`,'Content-Type':'application/json'},
      body:JSON.stringify({
        model:currentModel,
        messages:[
          {role:'system',content:'You are an editor for HORSE, a narrative where reality and dreams blur. Analyse via surrealism. Be bold, concise, literary.'},
          {role:'user',content:ctx+'User Question: '+msg}
        ],
        temperature:.6,top_p:1,max_tokens:1024
      })
    });
    if(!res.ok){if(res.status===404)throw new Error('404 Switch');const t=await res.text();let m=t;try{m=JSON.parse(t).error?.message||t;}catch{e}throw new Error(m);}
    const data=await res.json();
    let txt=data.choices[0].message.content;
    txt=txt.replace(/\*\*(.*?)\*\*/g,'<strong style="color:var(--red)">$1</strong>').replace(/\n/g,'<br>');
    aiResponseDiv.innerHTML=txt;
  }catch(err){
    console.error(err);
    if(err.message.includes('404')||err.message.includes('Switch')){
      currentModel=NVIDIA_MODELS.backup;
      aiResponseDiv.innerHTML='<p style="color:#888">Primary model unavailable. Switched to Backup.<br><strong>Please click Transmit again.</strong></p>';
    }else{
      aiResponseDiv.innerHTML=`<p style="color:var(--red)">Error: ${err.message}</p>`;
    }
  }finally{askAiBtn.disabled=false;askAiBtn.textContent='TRANSMIT';}
});

/* ==========  CONTEXT BUTTONS  ========== */
document.addEventListener('click',e=>{
  if(!e.target.classList.contains('context-btn'))return;
  document.querySelectorAll('.context-btn').forEach(b=>{b.style.background='var(--dark-grey)';b.style.color='#888';b.style.borderColor='#333';});
  e.target.style.background='var(--red)';e.target.style.color='black';e.target.style.borderColor='var(--red)';
  aiContext=e.target.dataset.context;
  contextInfo.textContent=`Context: ${aiContext.toUpperCase()} (${aiContext==='current'?'Reading current entry':aiContext==='all'?'Reading all titles':'No context'})`;
});
</script>
</body>
</html>
