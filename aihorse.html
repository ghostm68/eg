<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>reader/horse ai is under re-construction... </title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

  <style>
    :root {
      --red: #ff0033;
      --black: #0a0a0a;
      --dark-grey: #121212;
      --white: #d1d1d1;
    }
    ::selection {
      background: var(--red);
      color: var(--black);
      text-shadow: none;
    }
    * { -webkit-tap-highlight-color: transparent; }
    body {
      font-family: 'Nova Mono', monospace;
      background: var(--black);
      color: var(--white);
      margin: 0;
      touch-action: manipulation;
    }
    /* CRT scanlines */
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background: linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,.15) 50%),
                  linear-gradient(90deg, rgba(255,0,0,.04), rgba(0,255,0,.02), rgba(0,0,255,.04));
      background-size: 100% 3px, 3px 100%;
      z-index: 999;
      pointer-events: none;
    }
    .highlight {
      background: var(--red);
      color: var(--black);
      padding: 1px 3px;
    }
    .custom-scrollbar::-webkit-scrollbar { width: 6px; }
    .custom-scrollbar::-webkit-scrollbar-track { background: var(--black); }
    .custom-scrollbar::-webkit-scrollbar-thumb { background: var(--red); border-radius: 3px; }
    input, textarea, button { font-family: 'Nova Mono', monospace; }
    button { user-select: none; cursor: pointer; }
    .special-elite { font-family: 'Special Elite', serif; }
  </style>
</head>

<body class="bg-black text-gray-300">
<!-- HEADER -->
<div class="sticky top-0 z-50 w-full pt-4 pb-4 px-4 sm:px-6 md:px-8 border-b border-red-800 bg-black">
  <div class="flex justify-between items-center max-w-full">
    <h1 class="text-3xl font-bold special-elite" style="color: var(--red);">‚ö° horse reader ai is being rebuilt...‚ö°</h1>
    <a href="https://inkrealm.info"
       class="text-xs font-mono border border-gray-600 px-3 py-1 hover:bg-red-600 hover:text-black hover:border-red-600 transition-all duration-300 uppercase tracking-widest no-underline text-gray-400">
      Return to Realm
    </a>
  </div>
</div>

<!-- TWO-COLUMN LAYOUT -->
<div id="horse-layout" class="flex flex-col md:flex-row w-full h-[calc(100vh-80px)] overflow-hidden bg-black">
  <!-- LEFT: READER -->
  <div class="flex-1 flex flex-col h-full border-r border-gray-800 relative min-w-0">
    <div id="loading" class="absolute inset-0 flex items-center justify-center text-xl" style="color: var(--red);">
      Loading horse.txt ...
    </div>
    <div id="content" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-10 text-base md:text-lg leading-relaxed whitespace-pre-wrap special-elite custom-scrollbar" style="display:none;"></div>
    <div id="entryInfo" class="p-3 border-t border-gray-800 text-xs text-gray-500 bg-black flex-shrink-0"></div>
  </div>
  
  <!-- RIGHT: IMAGES SIDEBAR (Hidden by default, shows for sketches) -->
  <div id="imagesSidebar" class="hidden md:w-80 lg:w-96 border-l border-gray-800 bg-black overflow-y-auto">
    <!-- Content will be populated by JavaScript -->
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="w-full md:w-[400px] flex flex-col h-full bg-[#0a0a0a] border-l border-gray-800 flex-shrink-0">
    <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">
      <!-- NAV -->
      <div class="flex items-center justify-between mb-6 gap-2">
        <button id="prevBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚Üê Prev</button>
        <button id="randomBtn" class="px-4 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚ö°</button>
        <button id="nextBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">Next ‚Üí</button>
      </div>

      <!-- SEARCH -->
      <div class="mb-6">
        <input type="text" id="searchBox" class="w-full bg-[#111] border border-gray-700 p-3 text-white focus:border-red-500 focus:outline-none transition-colors" placeholder="Search text...">
        <div class="flex justify-between items-center mt-2">
          <div id="searchStats" class="text-xs text-gray-500 h-4"></div>
          <button id="indexBtn" class="text-xs text-gray-500 hover:text-red-500 uppercase tracking-widest border-b border-transparent hover:border-red-500">Toggle Index</button>
        </div>
      </div>

      <!-- FILTERS -->
      <div id="filterBtns" class="flex flex-wrap gap-2 mb-6 pb-6 border-b border-gray-800">
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="all">All</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="fragments">Fragments</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="passages">Passages</button>
       <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sections">Sections</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="sketches">Sketches</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="characters">Characters</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="dialogue">Dialogue</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="scenes">Scenes</button>
  <button class="filter-btn px-3 py-1 border text-xs uppercase" data-filter="settings">Settings</button>
      </div>

      <!-- INDEX -->
      <div id="dateNav" class="hidden mb-6 max-h-60 overflow-y-auto border border-gray-800 bg-[#111] custom-scrollbar"></div>

      <!-- NVIDIA AI -->
      <div class="mt-2">
        <h2 class="text-xl font-bold mb-4 text-gray-600 special-elite">AI EDITOR</h2>
        <input type="password" id="apiKeyInput" class="w-full bg-black border border-gray-800 p-2 text-xs text-red-500 font-mono mb-4 focus:outline-none focus:border-red-900" placeholder="NVIDIA API KEY...">
        <div class="flex gap-2 mb-2">
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="current">Current</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="all">Outline</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="none">None</button>
        </div>
        <p id="contextInfo" class="text-[10px] text-gray-600 mb-3 text-right">Target: Current Entry</p>
        <textarea id="aiInput" class="w-full bg-[#111] border border-gray-800 p-3 text-sm text-gray-300 focus:border-red-500 focus:outline-none min-h-[80px] mb-2" placeholder="Enter prompt..."></textarea>
        <button id="askAiBtn" class="w-full bg-red-900/20 hover:bg-red-900/40 border border-red-900 text-red-500 py-2 text-xs font-bold tracking-widest transition-all">TRANSMIT</button>
        <div id="aiResponse" class="mt-4 p-3 bg-black border border-gray-800 text-sm text-gray-400 min-h-[100px] whitespace-pre-wrap special-elite font-mono custom-scrollbar"><span class="opacity-30">:: Awaiting Input ::</span></div>
      </div>
    </div>
  </div>
</div>

<!-- ============  SCRIPTS  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<script id="reader-script">
/* ==========  CONFIG  ========== */
const TXT_FILE_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/horse.txt';
const IMAGES_JSON_URL = 'https://raw.githubusercontent.com/ghostm68/eg/refs/heads/main/your-images.json';

// Markdown pattern
const ENTRY_PATTERN = /^(#{1,3})\s+(.+)$/;

// SIMPLIFIED TAG PATTERNS for testing - let's start with basics
const TAG_PATTERNS = {
  all: /.*/,
  fragments: /\bfragment(s)?\b|\[fragment\]/i,
  passages: /\bpassage(s)?\b|\[passage\]/i,
  sections: /\bsection(s)?\b|\[section\]/i,
  sketches: /\bsketch(es)?\b|\[sketch\]/i,
  characters: /\bcharacter(s)?\b/i,
  dialogue: /\bdialogue\b/i,
  scenes: /\bscene(s)?\b/i,
  settings: /\bsetting(s)?\b/i
};

/* ==========  STATE  ========== */
window.readerEntries = [];
window.readerCurrentIndex = 0;
let currentFilter = 'all';
let searchQuery = '';
let searchResults = [];
let isSearching = false;
let isIndexVisible = false;
let searchTimeout = null;
let imagesData = [];

/* ==========  DEBUG FUNCTIONS  ========== */
function debugLog(message, data = null) {
  console.log(`[DEBUG] ${message}`, data || '');
}

function showAllTagsInContent() {
  debugLog('=== CONTENT TAGS ANALYSIS ===');
  window.readerEntries.forEach((entry, index) => {
    const foundTags = [];
    for (const [tag, pattern] of Object.entries(TAG_PATTERNS)) {
      if (tag !== 'all' && pattern.test(entry.content)) {
        foundTags.push(tag);
      }
    }
    if (foundTags.length > 0) {
      debugLog(`Entry ${index}: "${entry.title.substring(0, 30)}..."`, foundTags);
    }
  });
}

/* ==========  DOM  ========== */
const searchBox = document.getElementById('searchBox');
const searchStats = document.getElementById('searchStats');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const randomBtn = document.getElementById('randomBtn');
const indexBtn = document.getElementById('indexBtn');
const dateNav = document.getElementById('dateNav');
const entryInfo = document.getElementById('entryInfo');
const loadingDiv = document.getElementById('loading');
const contentDiv = document.getElementById('content');

/* ==========  LOAD DATA  ========== */
async function loadText() {
  try {
    debugLog('Starting load...');
    
    // Load text
    const textRes = await fetch(TXT_FILE_URL);
    if (!textRes.ok) throw new Error('Text file not found');
    
    let text = await textRes.text();
    debugLog('Text loaded, length:', text.length);
    
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    parseEntries(text);
    
    // Try to load images
    try {
      const imagesRes = await fetch(IMAGES_JSON_URL);
      if (imagesRes.ok) {
        imagesData = await imagesRes.json();
        debugLog('Images JSON loaded:', typeof imagesData);
        debugLog('Images data sample:', Array.isArray(imagesData) ? 
          imagesData.slice(0, 3) : 
          Object.keys(imagesData).slice(0, 3));
      } else {
        debugLog('Images JSON not found or error:', imagesRes.status);
      }
    } catch (imageError) {
      debugLog('Image load error:', imageError.message);
    }
    
    loadingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    
    debugLog(`Parsed ${window.readerEntries.length} entries`);
    
    if (window.readerEntries.length > 0) {
      showEntry(window.readerEntries[0].id);
    }
    
    // Show debug info about tags
    showAllTagsInContent();
    
    // Setup UI
    styleActiveFilter(document.querySelector('.filter-btn[data-filter="all"]'));
    buildIndex();
    updateUIState();
    
    // Setup search listener
    setupSearchListener();
    
  } catch (err) {
    console.error('Load error:', err);
    loadingDiv.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  }
}

/* ==========  SEARCH - SIMPLIFIED ========== */
function setupSearchListener() {
  searchBox.addEventListener('input', function(e) {
    const query = e.target.value.trim();
    debugLog('Search input:', query);
    
    if (!query) {
      isSearching = false;
      searchResults = [];
      updateUIState();
      if (window.readerEntries.length > 0) {
        showEntry(window.readerEntries[0].id);
      }
      return;
    }
    
    isSearching = true;
    
    // SIMPLE SEARCH - just check if text contains query
    const pool = getFilteredEntries();
    searchResults = pool.filter(entry => {
      const searchText = (entry.content + ' ' + entry.title).toLowerCase();
      return searchText.includes(query.toLowerCase());
    });
    
    debugLog(`Simple search for "${query}": ${searchResults.length} results`);
    
    updateUIState();
    
    if (searchResults.length > 0) {
      showEntry(searchResults[0].id);
    } else {
      contentDiv.innerHTML = `<div class="text-center mt-10 text-gray-500">No matches found for "${query}"</div>`;
      entryInfo.innerHTML = `<div class="text-xs text-gray-500">Search: "${query}" - 0 results</div>`;
    }
  });
}

function highlightText(text, query) {
  if (!query) return text;
  
  const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
  return text.replace(regex, '<span class="highlight" style="background:var(--red); color:black; padding:0 2px;">$1</span>');
}

/* ==========  PARSE ENTRIES  ========== */
function parseEntries(text) {
  const lines = text.split('\n');
  let current = null;
  let id = 0;
  
  debugLog('Parsing lines:', lines.length);
  
  lines.forEach((line, lineNum) => {
    const m = line.match(ENTRY_PATTERN);
    if (m) {
      // Save previous entry if exists
      if (current && current.content.trim()) {
        detectTags(current);
        window.readerEntries.push(current);
      }
      
      // Start new entry
      current = {
        id: ++id,
        title: m[2].trim(),
        headingLevel: m[1].length,
        content: line + '\n',
        tags: [],
        images: []
      };
      
      debugLog(`New entry at line ${lineNum}: "${current.title}"`);
    } else if (current) {
      // Continue current entry
      current.content += line + '\n';
    }
  });
  
  // Don't forget the last entry
  if (current && current.content.trim()) {
    detectTags(current);
    window.readerEntries.push(current);
  }
  
  debugLog(`Total entries parsed: ${window.readerEntries.length}`);
}

function detectTags(entry) {
  const detectedTags = [];
  const contentLower = entry.content.toLowerCase();
  
  // DEBUG: Check what's actually in the content
  if (contentLower.includes('sketch')) {
    debugLog(`Found "sketch" in entry: "${entry.title.substring(0, 30)}..."`);
  }
  if (contentLower.includes('dialogue')) {
    debugLog(`Found "dialogue" in entry: "${entry.title.substring(0, 30)}..."`);
  }
  if (contentLower.includes('fragment')) {
    debugLog(`Found "fragment" in entry: "${entry.title.substring(0, 30)}..."`);
  }
  
  // Check each tag pattern
  for (const [tag, pattern] of Object.entries(TAG_PATTERNS)) {
    if (tag !== 'all') {
      // Test the pattern
      const matches = pattern.test(entry.content);
      if (matches) {
        detectedTags.push(tag);
        debugLog(`Tag "${tag}" matched for entry: "${entry.title.substring(0, 30)}..."`);
      }
    }
  }
  
  entry.tags = detectedTags;
  
  // Find images for sketches
  if (detectedTags.includes('sketches') && imagesData) {
    entry.images = findImagesForEntry(entry);
    if (entry.images.length > 0) {
      debugLog(`Found ${entry.images.length} images for sketch: "${entry.title}"`);
    }
  }
}

function findImagesForEntry(entry) {
  if (!imagesData || (Array.isArray(imagesData) && imagesData.length === 0)) {
    return [];
  }
  
  const foundImages = [];
  
  // Try different JSON structures
  if (Array.isArray(imagesData)) {
    // Array structure: [{url: "...", title: "...", description: "..."}]
    debugLog('Images data is an array, length:', imagesData.length);
    
    // Simple assignment: first sketch gets first image, etc.
    const sketchEntries = window.readerEntries.filter(e => e.tags.includes('sketches'));
    const sketchIndex = sketchEntries.findIndex(e => e.id === entry.id);
    
    if (sketchIndex < imagesData.length) {
      const img = imagesData[sketchIndex];
      foundImages.push({
        url: img.url || img.src || img.path || img.filename || `image_${sketchIndex}.jpg`,
        title: img.title || img.caption || `Sketch ${sketchIndex + 1}`,
        description: img.description || img.alt || `Associated with: ${entry.title}`
      });
    }
  } else if (typeof imagesData === 'object') {
    // Object structure: {"key": {url: "...", ...}}
    debugLog('Images data is an object, keys:', Object.keys(imagesData).slice(0, 3));
    
    Object.entries(imagesData).forEach(([key, img], index) => {
      if (index < 5) { // Limit to first 5 for testing
        foundImages.push({
          url: img.url || img.src || img.path || key,
          title: img.title || img.caption || key,
          description: img.description || img.alt || ''
        });
      }
    });
  }
  
  return foundImages;
}

function getFilteredEntries() {
  let entries = window.readerEntries;
  
  if (currentFilter !== 'all') {
    const filtered = entries.filter(e => e.tags.includes(currentFilter));
    debugLog(`Filter "${currentFilter}": ${filtered.length} of ${entries.length} entries`);
    return filtered;
  }
  
  return entries;
}

/* ==========  DISPLAY FUNCTIONS  ========== */
function showEntry(entryId) {
  const entry = window.readerEntries.find(x => x.id === entryId);
  if (!entry) return;
  
  window.readerCurrentIndex = entryId;
  
  debugLog(`Showing entry ${entryId}: "${entry.title}"`, {
    tags: entry.tags,
    hasImages: entry.images?.length || 0
  });
  
  let displayContent = entry.content;
  
  // Apply highlighting if searching
  if (isSearching && searchQuery) {
    displayContent = highlightText(displayContent, searchQuery);
  }
  
  // Process markdown formatting
  const html = displayContent.split('\n').map(line => {
    const trimmed = line.trim();
    if (!trimmed) return '<br>';
    
    const headingMatch = line.match(/^(#{1,3})\s+(.+)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const headingText = headingMatch[2];
      const headingClass = level === 1 ? 'text-2xl font-bold mt-6 mb-4' :
                          level === 2 ? 'text-xl font-bold mt-5 mb-3' :
                          'text-lg font-bold mt-4 mb-2';
      return `<h${level} class="${headingClass} special-elite" style="color:var(--red)">${headingText}</h${level}>`;
    }
    
    return `<p class="mb-4 leading-relaxed">${trimmed}</p>`;
  }).join('');
  
  // Add images if available
  let imagesHtml = '';
  if (entry.images && entry.images.length > 0) {
    imagesHtml = entry.images.map(img => `
      <div class="my-6 p-4 border border-gray-700 rounded-lg bg-gray-900">
        <img src="${img.url}" 
             alt="${img.description || img.title}" 
             class="w-full h-64 object-cover rounded mb-2"
             loading="lazy"
             onerror="console.error('Image failed to load:', this.src); this.src='https://placehold.co/600x400/111/666?text=Image+Error';">
        <div class="text-xs text-gray-400 mt-2">
          <strong class="text-gray-300">${img.title || 'Untitled'}</strong>
          ${img.description ? `<br>${img.description}` : ''}
        </div>
      </div>
    `).join('');
  }
  
  contentDiv.innerHTML = html + imagesHtml;
  
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === entryId);
  const words = entry.content.replace(/<[^>]*>/g, '').trim().split(/\s+/).length;
  
  // Tag styling
  const tagStyles = {
    'fragments': 'border-red-400 text-red-400',
    'passages': 'border-red-500 text-red-500', 
    'sections': 'border-red-600 text-red-600',
    'sketches': 'border-red-700 text-red-700 bg-red-900/20',
    'characters': 'border-purple-500 text-purple-400',
    'dialogue': 'border-blue-500 text-blue-400',
    'scenes': 'border-green-500 text-green-400',
    'settings': 'border-yellow-500 text-yellow-400'
  };
  
  entryInfo.innerHTML = `
    <div class="flex flex-col gap-1">
      <div>
        <span class="text-xs text-gray-500 uppercase tracking-widest">HORSE ARCHIVE</span>
        <span class="ml-2 font-bold text-xl special-elite" style="color:var(--red)">${entry.title}</span>
      </div>
      <div class="text-xs text-gray-400 flex items-center gap-2 flex-wrap">
        ${isSearching ? `Search result ${idx + 1}/${searchResults.length}` : `Entry ${idx + 1}/${pool.length}`}
        <span>‚Ä¢</span>${words} words
        ${entry.tags.length > 0 ? `<span class="ml-2 flex gap-1 flex-wrap">
          ${entry.tags.map(t => {
            const style = tagStyles[t] || 'border-gray-600 text-gray-600';
            const icon = t === 'sketches' && entry.images?.length ? ` (${entry.images.length}üì∑)` : '';
            return `<span class="px-2 py-1 border text-[10px] uppercase ${style}">${t}${icon}</span>`;
          }).join('')}
        </span>` : ''}
      </div>
    </div>`;
  
  // Update navigation buttons
  if (prevBtn) {
    prevBtn.disabled = idx <= 0;
    prevBtn.style.opacity = idx <= 0 ? '0.5' : '1';
  }
  if (nextBtn) {
    nextBtn.disabled = idx >= pool.length - 1;
    nextBtn.style.opacity = idx >= pool.length - 1 ? '0.5' : '1';
  }
  
  contentDiv.scrollTop = 0;
  if (isIndexVisible) buildIndex();
}

/* ==========  FILTER HANDLING  ========== */
function setupFilterListeners() {
  const filterContainer = document.getElementById('filterBtns');
  if (!filterContainer) {
    console.error('Filter container not found!');
    return;
  }
  
  filterContainer.addEventListener('click', function(e) {
    if (e.target.classList.contains('filter-btn')) {
      const filter = e.target.dataset.filter;
      debugLog(`Filter clicked: ${filter}`);
      handleFilterChange(filter, e.target);
    }
  });
}

function handleFilterChange(filter, button) {
  currentFilter = filter;
  
  // Style the active button
  document.querySelectorAll('.filter-btn').forEach(btn => {
    btn.style.background = 'transparent';
    btn.style.borderColor = '#333';
    btn.style.color = '#666';
  });
  
  button.style.background = 'var(--red)';
  button.style.color = 'black';
  button.style.borderColor = 'var(--red)';
  
  // Clear search
  searchBox.value = '';
  isSearching = false;
  
  const filtered = getFilteredEntries();
  debugLog(`Filter "${filter}" applied: ${filtered.length} entries`);
  
  updateUIState();
  
  if (filtered.length > 0) {
    showEntry(filtered[0].id);
  } else {
    contentDiv.innerHTML = `<div class="text-center mt-10 text-gray-500">
      No entries tagged as "${filter}".<br>
      <span class="text-sm text-gray-600">Try another filter or check if entries contain "${filter}" in their content.</span>
    </div>`;
    entryInfo.innerHTML = `<div class="text-xs text-gray-500">Filter: ${filter} - 0 entries</div>`;
  }
}

/* ==========  UI FUNCTIONS  ========== */
function updateUIState() {
  if (isSearching) {
    searchStats.textContent = `${searchResults.length} match${searchResults.length !== 1 ? 'es' : ''}`;
  } else {
    const count = getFilteredEntries().length;
    searchStats.textContent = currentFilter !== 'all' ? `${count} ${currentFilter}` : `${count} total`;
  }
  
  if (isIndexVisible) {
    buildIndex();
  }
}

function buildIndex() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  dateNav.innerHTML = '';
  
  if (pool.length === 0) {
    dateNav.innerHTML = '<div class="p-3 text-gray-500 text-sm">No entries to display</div>';
    return;
  }
  
  pool.forEach(entry => {
    const div = document.createElement('div');
    div.className = 'p-3 border-b border-gray-700 cursor-pointer hover:bg-gray-900 transition-colors';
    
    if (entry.id === window.readerCurrentIndex) {
      div.style.background = '#1a1a1a';
      div.style.borderLeft = '3px solid var(--red)';
    }
    
    const preview = entry.content.replace(/<[^>]*>/g, '').substring(0, 60).replace(/\n/g, ' ') + '...';
    const imageCount = entry.images?.length ? ` üì∑${entry.images.length}` : '';
    
    div.innerHTML = `
      <div class="text-sm font-bold text-gray-300 mb-1 truncate special-elite">
        ${entry.title}${imageCount}
      </div>
      <div class="text-xs text-gray-600 font-mono truncate">${preview}</div>
      ${entry.tags.length > 0 ? 
        `<div class="mt-1 flex gap-1 flex-wrap">
          ${entry.tags.slice(0, 3).map(t => 
            `<span class="text-[9px] px-1 py-0.5 border border-gray-700 text-gray-500">${t}</span>`
          ).join('')}
        </div>` : ''}
    `;
    
    div.addEventListener('click', () => showEntry(entry.id));
    dateNav.appendChild(div);
  });
}

function styleActiveFilter(btn) {
  if (!btn) return;
  document.querySelectorAll('.filter-btn').forEach(b => {
    b.style.background = 'transparent';
    b.style.borderColor = '#333';
    b.style.color = '#666';
  });
  
  btn.style.background = 'var(--red)';
  btn.style.color = 'black';
  btn.style.borderColor = 'var(--red)';
}

/* ==========  NAVIGATION  ========== */
function showRandomEntry() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (!pool.length) return;
  
  let randomIdx;
  do {
    randomIdx = Math.floor(Math.random() * pool.length);
  } while (pool[randomIdx].id === window.readerCurrentIndex && pool.length > 1);
  
  showEntry(pool[randomIdx].id);
}

function navigateEntries(dir) {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (pool.length === 0) return;
  
  const idx = pool.findIndex(x => x.id === window.readerCurrentIndex);
  const newIdx = dir === 'next' ? idx + 1 : idx - 1;
  
  if (newIdx >= 0 && newIdx < pool.length) {
    showEntry(pool[newIdx].id);
  }
}

/* ==========  INITIALIZATION  ========== */
document.addEventListener('DOMContentLoaded', function() {
  debugLog('DOM loaded, starting...');
  loadText();
  setupFilterListeners();
  
  // Navigation buttons
  if (prevBtn) prevBtn.addEventListener('click', () => navigateEntries('prev'));
  if (nextBtn) nextBtn.addEventListener('click', () => navigateEntries('next'));
  if (randomBtn) randomBtn.addEventListener('click', showRandomEntry);
  if (indexBtn) indexBtn.addEventListener('click', () => {
    isIndexVisible = !isIndexVisible;
    dateNav.classList.toggle('hidden');
    if (isIndexVisible) buildIndex();
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', function(e) {
    if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
    
    if (e.key === 'ArrowLeft') navigateEntries('prev');
    if (e.key === 'ArrowRight') navigateEntries('next');
    if (e.key.toLowerCase() === 'r') showRandomEntry();
    if (e.key === 'Escape' && isIndexVisible) {
      dateNav.classList.add('hidden');
      isIndexVisible = false;
    }
  });
});

// Test function to check your text file content
async function testFileContent() {
  try {
    const res = await fetch(TXT_FILE_URL);
    const text = await res.text();
    const first1000 = text.substring(0, 1000);
    debugLog('First 1000 chars of file:', first1000);
    
    // Look for sketch/dialogue mentions
    const lines = text.split('\n');
    lines.forEach((line, i) => {
      if (line.toLowerCase().includes('sketch') || line.toLowerCase().includes('dialogue')) {
        debugLog(`Line ${i}: "${line.substring(0, 50)}..."`);
      }
    });
  } catch (err) {
    console.error('Test failed:', err);
  }
}

// Uncomment to run test
// testFileContent();
</script>

<script id="ai-script">
/* ==========  AI CONFIG  ========== */
const NVIDIA_MODELS={
  stable:"meta/llama-3.3-70b-instruct",
  backup:"nvidia/llama-3.1-nemotron-70b-instruct"
};
let currentModel=NVIDIA_MODELS.stable,aiContext='current';
const apiKeyInput=document.getElementById('apiKeyInput');
const aiInput=document.getElementById('aiInput');
const askAiBtn=document.getElementById('askAiBtn');
const aiResponseDiv=document.getElementById('aiResponse');
const contextInfo=document.getElementById('contextInfo');

/* ==========  INIT  ========== */
if(localStorage.getItem('horse_nvidia_key'))apiKeyInput.value=localStorage.getItem('horse_nvidia_key');
apiKeyInput.addEventListener('input',e=>localStorage.setItem('horse_nvidia_key',e.target.value));

/* ==========  TRANSMIT  ========== */
askAiBtn.addEventListener('click',async()=>{
  const key=apiKeyInput.value.trim(),msg=aiInput.value.trim();
  if(!key){aiResponseDiv.innerHTML='<p class="text-red-500">Please enter an NVIDIA API Key.</p>';return;}
  if(!msg)return;
  if(!window.readerEntries?.length){aiResponseDiv.innerHTML='<p class="text-red-500">horse.txt not loaded yet.</p>';return;}
  askAiBtn.disabled=true;askAiBtn.textContent='TRANSMITTING...';
  aiResponseDiv.innerHTML='<p class="animate-pulse" style="color:var(--red)">Consulting Llama...</p>';
  try{
    let ctx='';
    if(aiContext==='current'){
      const e=window.readerEntries.find(x=>x.id===window.readerCurrentIndex);
      if(e)ctx=`CONTEXT (Current ‚Äì ${e.title}):\n${e.content.substring(0,4000)}\n\n---\n`;
    }else if(aiContext==='all'){
      ctx=`CONTEXT (Outline):\n${window.readerEntries.map(x=>`- ${x.title} (${x.tags.join(', ')})`).join('\n')}\n\n---\n`;
    }
    const proxy='https://corsproxy.io/?'+encodeURIComponent('https://integrate.api.nvidia.com/v1/chat/completions');
    const res=await fetch(proxy,{
      method:'POST',
      headers:{Authorization:`Bearer ${key}`,'Content-Type':'application/json'},
      body:JSON.stringify({
        model:currentModel,
        messages:[
          {role:'system',content:'You are an editor for HORSE, a narrative where reality and dreams blur. Analyse via surrealism. Be bold, concise, literary.'},
          {role:'user',content:ctx+'User Question: '+msg}
        ],
        temperature:.6,top_p:1,max_tokens:1024
      })
    });
    if(!res.ok){if(res.status===404)throw new Error('404 Switch');const t=await res.text();let m=t;try{m=JSON.parse(t).error?.message||t;}catch{e}throw new Error(m);}
    const data=await res.json();
    let txt=data.choices[0].message.content;
    txt=txt.replace(/\*\*(.*?)\*\*/g,'<strong style="color:var(--red)">$1</strong>').replace(/\n/g,'<br>');
    aiResponseDiv.innerHTML=txt;
  }catch(err){
    console.error(err);
    if(err.message.includes('404')||err.message.includes('Switch')){
      currentModel=NVIDIA_MODELS.backup;
      aiResponseDiv.innerHTML='<p style="color:#888">Primary model unavailable. Switched to Backup.<br><strong>Please click Transmit again.</strong></p>';
    }else{
      aiResponseDiv.innerHTML=`<p style="color:var(--red)">Error: ${err.message}</p>`;
    }
  }finally{askAiBtn.disabled=false;askAiBtn.textContent='TRANSMIT';}
});

/* ==========  CONTEXT BUTTONS  ========== */
document.addEventListener('click',e=>{
  if(!e.target.classList.contains('context-btn'))return;
  document.querySelectorAll('.context-btn').forEach(b=>{b.style.background='var(--dark-grey)';b.style.color='#888';b.style.borderColor='#333';});
  e.target.style.background='var(--red)';e.target.style.color='black';e.target.style.borderColor='var(--red)';
  aiContext=e.target.dataset.context;
  contextInfo.textContent=`Context: ${aiContext.toUpperCase()} (${aiContext==='current'?'Reading current entry':aiContext==='all'?'Reading all titles':'No context'})`;
});
</script>
</body>
</html>
