<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"> 
  <meta name="viewport" content="width=1024">
  <title>dreamweaver reader is under re-construction...</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- new fonts -->
  <link href="https://fonts.cdnfonts.com/css/voodoo" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">

  <style>
    :root{--red:#ff0033;--black:#0a0a0a;--dark-grey:#121212;--white:#d1d1d1;}
    ::selection{background:var(--red);color:var(--black);text-shadow:none;}
    *{-webkit-tap-highlight-color:transparent;}
    body{font-family:'Special Elite',serif;background:var(--black);color:var(--white);margin:0;touch-action:manipulation;}
    body::after{content:"";position:fixed;inset:0;background:linear-gradient(rgba(18,16,16,0) 50%,rgba(0,0,0,.15) 50%),linear-gradient(90deg,rgba(255,0,0,.04),rgba(0,255,0,.02),rgba(0,0,255,.04));background-size:100% 3px,3px 100%;z-index:999;pointer-events:none;}
    .highlight{background:var(--red);color:var(--black);padding:1px 3px;}
    .custom-scrollbar::-webkit-scrollbar{width:6px;}.custom-scrollbar::-webkit-scrollbar-track{background:var(--black);}.custom-scrollbar::-webkit-scrollbar-thumb{background:var(--red);border-radius:3px;}
    input,textarea,button{font-family:'Special Elite',serif;}
    button{user-select:none;cursor:pointer;}
    /* headings in voodoo */
    .voodoo{font-family:'Voodoo',sans-serif;}
  </style>
</head>

<body class="bg-black text-gray-300">
<!-- HEADER -->
<div class="sticky top-0 z-50 w-full pt-4 pb-4 px-4 sm:px-6 md:px-8 border-b border-red-800 bg-black">
  <div class="flex justify-between items-center max-w-full">
    <h1 class="text-3xl font-bold voodoo" style="color:var(--red)">⚡ dreamweaver reader is being rebuilt...⚡</h1>
    <a href="https://inkrealm.info" class="text-xs font-mono border border-gray-600 px-3 py-1 hover:bg-red-600 hover:text-black hover:border-red-600 transition-all duration-300 uppercase tracking-widest no-underline text-gray-400">Return to Realm</a>
  </div>
</div>

<!-- TWO-COLUMN LAYOUT -->
<div id="brim-layout" class="flex flex-col md:flex-row w-full h-[calc(100vh-80px)] overflow-hidden bg-black">
  <!-- LEFT: READER -->
  <div class="flex-1 flex flex-col h-full border-r border-gray-800 relative min-w-0">
    <div id="loading" class="absolute inset-0 flex items-center justify-center text-xl" style="color:var(--red)">Loading dreamweaver.txt …</div>
    <div id="content" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-10 text-base md:text-lg leading-relaxed whitespace-pre-wrap custom-scrollbar" style="display:none;"></div>
    <div id="entryInfo" class="p-3 border-t border-gray-800 text-xs text-gray-500 bg-black flex-shrink-0"></div>
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="w-full md:w-[400px] flex flex-col h-full bg-[#0a0a0a] border-l border-gray-800 flex-shrink-0">
    <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">
      <!-- NAV -->
      <div class="flex items-center justify-between mb-6 gap-2">
        <button id="prevBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">← Prev</button>
        <button id="randomBtn" class="px-4 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">⚡</button>
        <button id="nextBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">Next →</button>
      </div>

      <!-- SEARCH -->
      <div class="mb-6">
        <input type="text" id="searchBox" class="w-full bg-[#111] border border-gray-700 p-3 text-white focus:border-red-500 focus:outline-none transition-colors" placeholder="Search text...">
        <div class="flex justify-between items-center mt-2">
          <div id="searchStats" class="text-xs text-gray-500 h-4"></div>
          <button id="indexBtn" class="text-xs text-gray-500 hover:text-red-500 uppercase tracking-widest border-b border-transparent hover:border-red-500">Toggle Index</button>
        </div>
      </div>

      <!-- FILTERS -->
      <div id="filterBtns" class="flex flex-wrap gap-2 mb-6 pb-6 border-b border-gray-800">
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="all">All</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="lyric">Lyric</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="poem">Poem</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="film">Film</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="book">Book</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="dream">Dream</button>
      </div>

      <!-- INDEX -->
      <div id="dateNav" class="hidden mb-6 max-h-60 overflow-y-auto border border-gray-800 bg-[#111] custom-scrollbar"></div>

      <!-- NVIDIA AI -->
      <div class="mt-2">
        <h2 class="text-xl font-bold mb-4 text-gray-600 voodoo">AI EDITOR</h2>
        <input type="password" id="apiKeyInput" class="w-full bg-black border border-gray-800 p-2 text-xs text-red-500 font-mono mb-4 focus:outline-none focus:border-red-900" placeholder="NVIDIA API KEY...">
        <div class="flex gap-2 mb-2">
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="current">Current</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="all">Outline</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="none">None</button>
        </div>
        <p id="contextInfo" class="text-[10px] text-gray-600 mb-3 text-right">Target: Current Entry</p>
        <textarea id="aiInput" class="w-full bg-[#111] border border-gray-800 p-3 text-sm text-gray-300 focus:border-red-500 focus:outline-none min-h-[80px] mb-2" placeholder="Enter prompt..."></textarea>
        <button id="askAiBtn" class="w-full bg-red-900/20 hover:bg-red-900/40 border border-red-900 text-red-500 py-2 text-xs font-bold tracking-widest transition-all">TRANSMIT</button>
        <div id="aiResponse" class="mt-4 p-3 bg-black border border-gray-800 text-sm text-gray-400 min-h-[100px] whitespace-pre-wrap font-mono custom-scrollbar"><span class="opacity-30">:: Awaiting Input ::</span></div>
      </div>
    </div>
  </div>
</div>

<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT  ============ -->
<!-- ============  READER SCRIPT (FIXED)  ============ -->
<script id="reader-script">
/* ----------  CONFIG  ---------- */

const TXT_FILE_URL = 'dreamweaver.txt';

// REGEX: Matches dates like:
// 12.12.23 | 2024-01-01 | Jan 12, 2024 | 12 Jan 2024
const ENTRY_PATTERN = /^(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}|\d{4}[-\/]\d{1,2}[-\/]\d{1,2}|(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}|\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4})/i;

// KEYWORDS: This is how the code knows which tab a text belongs to.
const TAG_PATTERNS = {
  all: /.*/,
  
  lyric: new RegExp([
    // Direct music indicators
    /\b(?:lyrics?|song|track|release|chords|verse|chorus|hook|bridge|outro|intro)\b/i,
    // Music production terms
    /\b(?:key of [a-g][#b]?(?: minor| major)?|in [a-g][#b]?|tempo|beat|rhythm|melody)\b/i,
    // Band/artist references
    /\b(?:two skinny girls|ain'?t no wifey records|special thanks|entitled)\b/i,
    // Lyrics formatting
    /-{3,}[\s\S]*?chords?[\s\S]*?-{3,}/i,
    // Repetitive lyrical patterns
    /\b(?:yeah{2,}|nah|oh{2,}|vanish|breakdown)\b.*\b(?:yeah{2,}|nah|oh{2,}|vanish|breakdown)\b/i
  ].map(r => r.source).join('|'), 'i'),
  
  poem: new RegExp([
    // Poetic structure
    /\b(?:stanza|line break|enjambment|caesura|meter|rhyme|rhythm)\b/i,
    // Poetic forms
    /\b(?:haiku|sonnet|villanelle|ode|elegy|free verse|blank verse)\b/i,
    // Poetic devices
    /\b(?:metaphor|simile|imagery|symbolism|alliteration|assonance)\b/i,
    // Visual poetry indicators
    /\n\n\s*\S+\s*\n\n\s*\S+\s*\n\n/i,  // Short lines with breaks
    // Lowercase poetic style
    /^[a-z][^\.\!\?]*\n[a-z][^\.\!\?]*$/m  // Multiple lowercase lines
  ].map(r => r.source).join('|'), 'i'),
  
  film: new RegExp([
    // Film production
    /\b(?:film|movie|cinema|screenplay|script|scene|shot|frame|director|producer)\b/i,
    // Viewing actions
    /\b(?:watch(?:ing|ed)?|view(?:ing|ed)?|screen(?:ing|ed)?)\b/i,
    // Visual media
    /\b(?:visual|camera|lens|focus|zoom|pan|cut|edit(?:ing)?)\b/i,
    // TV/media
    /\b(?:tv|television|broadcast|channel|station|network)\b/i,
    // Specific film refs
    /\b(?:rick and morty|spongebob|trump|kennedy|jfk|debate)\b/i
  ].map(r => r.source).join('|'), 'i'),
  
  book: new RegExp([
    // Reading/writing
    /\b(?:book|novel|story|narrative|text|page|chapter|author|writer|writing|wrote|reading|read)\b/i,
    // Literary terms
    /\b(?:literature|prose|essay|journal|diary|memoir|biography)\b/i,
    // Publication
    /\b(?:publish(?:ed|ing)?|print(?:ed|ing)?|edition|volume|issue)\b/i,
    // Art references (from your content)
    /\b(?:burne jones|painting|the depths of the sea)\b/i
  ].map(r => r.source).join('|'), 'i'),
  
  dream: new RegExp([
    // Sleep/dream states
    /\b(?:dream(?:t|ing|ed)?|nightmare|sleep(?:ing|ed)?|slumber|awake|waking|woke|unconscious)\b/i,
    // Dream characteristics
    /\b(?:surreal|subconscious|vision|hallucination|trance|hypnotic)\b/i,
    // Time confusion (common in dreams)
    /\b(?:everyday.*felt.*sunday|sunday.*week|midnight.*hour)\b/i,
    // Underwater/submerged (common dream theme)
    /\b(?:underwater|submerged|depths|drowning|swimming)\b/i
  ].map(r => r.source).join('|'), 'i')
};

// Enhanced classification function
function classifyEntry(entry) {
  const content = (entry.content + ' ' + (entry.title || '')).toLowerCase();
  const tags = [];
  
  // Check each pattern
  Object.entries(TAG_PATTERNS).forEach(([tag, pattern]) => {
    if (tag !== 'all' && pattern.test(content)) {
      tags.push(tag);
    }
  });
  
  // Additional heuristics
  if (content.includes('----') && content.includes('chords')) {
    if (!tags.includes('lyric')) tags.push('lyric');
  }
  
  if (content.match(/\([^\)]*dream[^\)]*\)/i)) {
    if (!tags.includes('dream')) tags.push('dream');
  }
  
  return tags.length ? tags : ['uncategorized'];
}

// Usage example:
// const entryTags = classifyEntry(entry);

/* ----------  STATE  ---------- */
window.readerEntries = [];
window.readerCurrentIndex = 0;
let currentFilter = 'all';
let searchQuery = '';
let searchResults = [];
let isSearching = false;
let isIndexVisible = false;
let searchTimeout = null;

/* ----------  DOM  ---------- */
const searchBox = document.getElementById('searchBox');
const searchStats = document.getElementById('searchStats');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const randomBtn = document.getElementById('randomBtn');
const indexBtn = document.getElementById('indexBtn');
const dateNav = document.getElementById('dateNav');
const entryInfo = document.getElementById('entryInfo');
const loadingDiv = document.getElementById('loading');
const contentDiv = document.getElementById('content');

/* ----------  SEARCH UTILS  ---------- */
function parseSearchQuery(q) {
  const terms = { and: [], or: [], not: [], exact: [] };
  const exactMatches = q.match(/"[^"]+"/g);
  if (exactMatches) {
    exactMatches.forEach(match => {
      terms.exact.push(match.replace(/"/g, '').toLowerCase());
      q = q.replace(match, '');
    });
  }
  let op = 'and';
  q.toLowerCase().split(/\s+/).filter(Boolean).forEach(w => {
    if (w === 'and') op = 'and';
    else if (w === 'or') op = 'or';
    else if (w.startsWith('-')) terms.not.push(w.slice(1));
    else terms[op].push(w);
  });
  return terms;
}

function matchesSearch(e, terms) {
  const txt = (e.content + ' ' + e.title).toLowerCase();
  if (terms.not.some(x => txt.includes(x))) return false;
  if (terms.exact.length && !terms.exact.every(x => txt.includes(x))) return false;
  if (terms.and.length && !terms.and.every(x => txt.includes(x))) return false;
  if (terms.or.length && !terms.or.some(x => txt.includes(x))) return false;
  return true;
}

function highlightText(text, query) {
  if (!query.trim()) return text;
  const terms = parseSearchQuery(query);
  const allTerms = [...terms.exact, ...terms.and, ...terms.or]
    .filter((v, i, a) => a.indexOf(v) === i);
  
  let result = text;
  // Sort by length to highlight longest phrases first
  allTerms.sort((a, b) => b.length - a.length).forEach(t => {
    const safe = t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    result = result.replace(new RegExp(`(${safe})`, 'gi'), '<span class="highlight" style="background:var(--red); color:black; padding:0 2px;">$1</span>');
  });
  return result;
}

function debounce(func, delay) {
  return function(...args) {
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => func.apply(this, args), delay);
  };
}

/* ----------  LOAD & PARSE  ---------- */
async function loadText() {
  try {
    const res = await fetch(TXT_FILE_URL);
    if (!res.ok) throw new Error('File not found');
    let text = await res.text();
    
    // Normalize line endings
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    
    parseEntries(text);
    
    loadingDiv.style.display = 'none';
    contentDiv.style.display = 'block';

    if (window.readerEntries.length > 0) {
      // If we are refreshing, try to stay on the same entry, otherwise go to first
      showEntry(window.readerEntries[0].id);
    }
    
    // Set "All" button active
    const allBtn = document.querySelector('.filter-btn[data-filter="all"]');
    if (allBtn) styleActiveFilter(allBtn);
    
    buildIndex();
    updateUIState();
  } catch (err) {
    loadingDiv.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  }
}

function parseEntries(text) {
  const lines = text.split('\n');
  let current = null;
  let id = 0;

  lines.forEach(line => {
    // TRIM line before checking regex. 
    // This allows dates to have accidental spaces before them.
    const cleanLine = line.trim(); 
    const m = cleanLine.match(ENTRY_PATTERN);
    
    if (m) {
      // Save previous entry if exists
      if (current && current.content.trim()) {
        detectTags(current);
        window.readerEntries.push(current);
      }
      
      // Start new entry
      current = {
        id: ++id,
        title: m[0].trim(), // Use the regex match as the title
        content: line + '\n',
        tags: []
      };
    } else if (current) {
      // Continue current entry
      current.content += line + '\n';
    }
  });

  // Don't forget the last entry
  if (current && current.content.trim()) {
    detectTags(current);
    window.readerEntries.push(current);
  }
  
  console.log(`Parsed ${window.readerEntries.length} entries`);
}

function detectTags(e) {
  const text = e.content.toLowerCase();
  for (const [tag, re] of Object.entries(TAG_PATTERNS)) {
    if (tag !== 'all' && re.test(text)) {
      e.tags.push(tag);
    }
  }
}

function getFilteredEntries() {
  return currentFilter === 'all' 
    ? window.readerEntries 
    : window.readerEntries.filter(e => e.tags.includes(currentFilter));
}

/* ----------  DISPLAY  ---------- */
function showEntry(entryId) {
  const e = window.readerEntries.find(x => x.id === entryId);
  if (!e) return;
  
  window.readerCurrentIndex = entryId;
  
  let displayContent = e.content;
  
  // Apply highlighting if searching
  if (isSearching && searchQuery) {
    displayContent = highlightText(displayContent, searchQuery);
  }
  
  // Format paragraphs
  displayContent = displayContent.split('\n').map(line => {
    const trimmed = line.trim();
    if (!trimmed) return '<br>';
    return `<p class="mb-4 leading-relaxed">${trimmed}</p>`;
  }).join('');
  
  contentDiv.innerHTML = displayContent;
  
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === entryId);
  const words = e.content.replace(/<[^>]*>/g, '').trim().split(/\s+/).length;
  
  // Generate Tags HTML
  const tagsHtml = e.tags.length > 0 
    ? e.tags.map(t => `<span class="px-2 py-1 border text-[10px] uppercase border-gray-600 text-gray-400">${t}</span>`).join('')
    : '<span class="px-2 py-1 border text-[10px] uppercase border-gray-800 text-gray-700">Unclassified</span>';

  entryInfo.innerHTML = `
    <div class="flex flex-col gap-1">
      <div>
        <span class="text-xs text-gray-500 uppercase tracking-widest">DREAMWEAVER ARCHIVE</span>
        <span class="ml-2 font-bold text-xl voodoo" style="color:var(--red)">${e.title}</span>
      </div>
      <div class="text-xs text-gray-400 flex items-center gap-2 flex-wrap">
        ${isSearching ? `Result ${idx + 1}/${searchResults.length}` : `Entry ${idx + 1}/${pool.length}`}
        <span>•</span>${words} words
        <span class="ml-2 flex gap-1 flex-wrap">${tagsHtml}</span>
      </div>
    </div>`;
  
  // Smart button disabling
  prevBtn.disabled = idx <= 0;
  nextBtn.disabled = idx >= pool.length - 1;
  
  // Visual feedback for disabled buttons
  prevBtn.style.opacity = prevBtn.disabled ? '0.3' : '1';
  nextBtn.style.opacity = nextBtn.disabled ? '0.3' : '1';

  contentDiv.scrollTop = 0;
  if (isIndexVisible) buildIndex();
}

function showRandomEntry() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (!pool.length) return;
  
  let randomIdx;
  // Try to find a new one, but don't loop forever if only 1 exists
  let attempts = 0;
  do {
    randomIdx = Math.floor(Math.random() * pool.length);
    attempts++;
  } while (pool[randomIdx].id === window.readerCurrentIndex && pool.length > 1 && attempts < 10);
  
  showEntry(pool[randomIdx].id);
}

function navigateEntries(dir) {
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === window.readerCurrentIndex);
  const newIdx = dir === 'next' ? idx + 1 : idx - 1;
  
  if (newIdx >= 0 && newIdx < pool.length) {
    showEntry(pool[newIdx].id);
  }
}

function buildIndex() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  dateNav.innerHTML = '';
  
  if (pool.length === 0) {
    dateNav.innerHTML = '<div class="p-4 text-xs text-gray-600">No entries found for this filter.</div>';
    return;
  }

  pool.forEach(e => {
    const div = document.createElement('div');
    div.className = 'p-3 border-b border-gray-700 cursor-pointer hover:bg-gray-900 transition-colors';
    
    if (e.id === window.readerCurrentIndex) {
      div.style.background = '#1a1a1a';
      div.style.borderLeft = '3px solid var(--red)';
    }
    
    const preview = e.content.replace(/<[^>]*>/g, '').substring(0, 50).replace(/\n/g, ' ') + '...';
    
    div.innerHTML = `
      <div class="text-sm font-bold text-gray-300 mb-1 truncate voodoo">${e.title}</div>
      <div class="text-xs text-gray-600 font-mono truncate">${preview}</div>
    `;
    
    div.addEventListener('click', () => showEntry(e.id));
    dateNav.appendChild(div);
  });
}

function styleActiveFilter(btn) {
  document.querySelectorAll('.filter-btn').forEach(b => {
    b.style.background = 'transparent';
    b.style.borderColor = '#333';
    b.style.color = '#666';
  });
  
  btn.style.background = 'var(--red)';
  btn.style.color = 'black';
  btn.style.borderColor = 'var(--red)';
}

/* ----------  SEARCH  ---------- */
function performSearch(q) {
  searchQuery = q;
  
  if (!q.trim()) {
    isSearching = false;
    searchResults = [];
    updateUIState();
    // Return to current entry if possible, else random
    showEntry(window.readerCurrentIndex);
    return;
  }
  
  isSearching = true;
  // Search runs against current filter OR all? Usually better to search ALL.
  // But here we search within the current filter for specificity.
  const pool = getFilteredEntries(); 
  const terms = parseSearchQuery(q);
  searchResults = pool.filter(e => matchesSearch(e, terms));
  
  updateUIState();
  
  if (searchResults.length > 0) {
    showEntry(searchResults[0].id);
  } else {
    contentDiv.innerHTML = '<div class="text-center mt-10 text-gray-500 font-mono">No matches found in this timeline.</div>';
    entryInfo.innerHTML = '';
    prevBtn.disabled = true;
    nextBtn.disabled = true;
  }
}

function updateUIState() {
  if (isSearching) {
    searchStats.textContent = `${searchResults.length} matches`;
  } else {
    const count = getFilteredEntries().length;
    searchStats.textContent = currentFilter !== 'all' ? `${count} ${currentFilter}s` : `${count} entries`;
  }
  buildIndex();
}

/* ----------  EVENTS  ---------- */
document.addEventListener('DOMContentLoaded', loadText);

searchBox.addEventListener('input', debounce(e => performSearch(e.target.value), 300));

prevBtn.addEventListener('click', () => navigateEntries('prev'));
nextBtn.addEventListener('click', () => navigateEntries('next'));
randomBtn.addEventListener('click', showRandomEntry);

indexBtn.addEventListener('click', () => {
  isIndexVisible = !isIndexVisible;
  dateNav.classList.toggle('hidden');
  if (isIndexVisible) buildIndex();
});

document.getElementById('filterBtns').addEventListener('click', e => {
  if (!e.target.classList.contains('filter-btn')) return;
  
  styleActiveFilter(e.target);
  currentFilter = e.target.dataset.filter;
  
  // Clear search when switching filters to avoid confusion
  searchBox.value = '';
  isSearching = false;
  
  updateUIState();
  
  // Show first entry of new filter, or random if that feels more "Dreamweaver"
  const filtered = getFilteredEntries();
  if (filtered.length > 0) {
    showEntry(filtered[0].id);
  } else {
    contentDiv.innerHTML = `<div class="text-center mt-20 text-gray-600">No entries found tagged as <span style="color:var(--red)">${currentFilter}</span>.</div>`;
    entryInfo.innerHTML = '';
  }
});

document.addEventListener('keydown', e => {
  if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
  
  if (e.key === 'ArrowLeft') navigateEntries('prev');
  if (e.key === 'ArrowRight') navigateEntries('next');
  if (e.key.toLowerCase() === 'r') showRandomEntry();
  if (e.key === 'Escape' && isIndexVisible) {
    dateNav.classList.add('hidden');
    isIndexVisible = false;
  }
});
</script>

<!-- keep your existing ai-script block here -->
<script id="ai-script">
/* ----------  AI CONFIG  ---------- */
const NVIDIA_MODELS={
  stable:"meta/llama-3.3-70b-instruct",
  backup:"nvidia/llama-3.1-nemotron-70b-instruct"
};
let currentModel=NVIDIA_MODELS.stable,aiContext='current';
const apiKeyInput=document.getElementById('apiKeyInput');
const aiInput=document.getElementById('aiInput');
const askAiBtn=document.getElementById('askAiBtn');
const aiResponseDiv=document.getElementById('aiResponse');
const contextInfo=document.getElementById('contextInfo');

/* ----------  INIT  ---------- */
if(localStorage.getItem('dreamweaver_nvidia_key'))apiKeyInput.value=localStorage.getItem('dreamweaver_nvidia_key');
apiKeyInput.addEventListener('input',e=>localStorage.setItem('dreamweaver_nvidia_key',e.target.value));

/* ----------  TRANSMIT  ---------- */
askAiBtn.addEventListener('click',async()=>{
  const key=apiKeyInput.value.trim(),msg=aiInput.value.trim();
  if(!key){aiResponseDiv.innerHTML='<p class="text-red-500">Please enter an NVIDIA API Key.</p>';return;}
  if(!msg)return;
  if(!window.readerEntries?.length){aiResponseDiv.innerHTML='<p class="text-red-500">dreamweaver.txt not loaded yet.</p>';return;}
  askAiBtn.disabled=true;askAiBtn.textContent='TRANSMITTING...';
  aiResponseDiv.innerHTML='<p class="animate-pulse" style="color:var(--red)">Consulting Llama...</p>';
  try{
    let ctx='';
    if(aiContext==='current'){
      const e=window.readerEntries.find(x=>x.id===window.readerCurrentIndex);
      if(e)ctx=`CONTEXT (Current – ${e.title}):\n${e.content.substring(0,4000)}\n\n---\n`;
    }else if(aiContext==='all'){
      ctx=`CONTEXT (Outline):\n${window.readerEntries.map(x=>`- ${x.title} (${x.tags.join(', ')})`).join('\n')}\n\n---\n`;
    }
    const proxy='https://corsproxy.io/?'+encodeURIComponent('https://integrate.api.nvidia.com/v1/chat/completions');
    const res=await fetch(proxy,{
      method:'POST',
      headers:{Authorization:`Bearer ${key}`,'Content-Type':'application/json'},
      body:JSON.stringify({
        model:currentModel,
        messages:[
          {role:'system',content:'You are an editor for DREAMWEAVER, a narrative where reality and dreams blur. Analyse via surrealism. Be bold, concise, literary.'},
          {role:'user',content:ctx+'User Question: '+msg}
        ],
        temperature:.6,top_p:1,max_tokens:1024
      })
    });
    if(!res.ok){if(res.status===404)throw new Error('404 Switch');const t=await res.text();let m=t;try{m=JSON.parse(t).error?.message||t;}catch{m=t}throw new Error(m);}
    const data=await res.json();
    let txt=data.choices[0].message.content;
    txt=txt.replace(/\*\*(.*?)\*\*/g,'<strong style="color:var(--red)">$1</strong>').replace(/\n/g,'<br>');
    aiResponseDiv.innerHTML=txt;
  }catch(err){
    console.error(err);
    if(err.message.includes('404')||err.message.includes('Switch')){
      currentModel=NVIDIA_MODELS.backup;
      aiResponseDiv.innerHTML='<p style="color:#888">Primary model unavailable. Switched to Backup.<br><strong>Please click Transmit again.</strong></p>';
    }else{
      aiResponseDiv.innerHTML=`<p style="color:var(--red)">Error: ${err.message}</p>`;
    }
  }finally{askAiBtn.disabled=false;askAiBtn.textContent='TRANSMIT';}
});

/* ----------  CONTEXT BUTTONS  ---------- */
document.addEventListener('click',e=>{
  if(!e.target.classList.contains('context-btn'))return;
  document.querySelectorAll('.context-btn').forEach(b=>{b.style.background='var(--dark-grey)';b.style.color='#888';b.style.borderColor='#333';});
  e.target.style.background='var(--red)';e.target.style.color='black';e.target.style.borderColor='var(--red)';
  aiContext=e.target.dataset.context;
  contextInfo.textContent=`Context: ${aiContext.toUpperCase()} (${aiContext==='current'?'Reading current entry':aiContext==='all'?'Reading all titles':'No context'})`;
});
</script>
</body>
</html>
