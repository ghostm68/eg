<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"> 
  <meta name="viewport" content="width=1024">
  <title>dreamweaver reader...</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- new fonts -->
  <link href="https://fonts.cdnfonts.com/css/voodoo" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Special+Elite&display=swap" rel="stylesheet">

  <style>
    :root{--red:#ff0033;--black:#0a0a0a;--dark-grey:#121212;--white:#d1d1d1;}
    ::selection{background:var(--red);color:var(--black);text-shadow:none;}
    *{-webkit-tap-highlight-color:transparent;}
    body{font-family:'Special Elite',serif;background:var(--black);color:var(--white);margin:0;touch-action:manipulation;}
    body::after{content:"";position:fixed;inset:0;background:linear-gradient(rgba(18,16,16,0) 50%,rgba(0,0,0,.15) 50%),linear-gradient(90deg,rgba(255,0,0,.04),rgba(0,255,0,.02),rgba(0,0,255,.04));background-size:100% 3px,3px 100%;z-index:999;pointer-events:none;}
    .highlight{background:var(--red);color:var(--black);padding:1px 3px;}
    .custom-scrollbar::-webkit-scrollbar{width:6px;}.custom-scrollbar::-webkit-scrollbar-track{background:var(--black);}.custom-scrollbar::-webkit-scrollbar-thumb{background:var(--red);border-radius:3px;}
    input,textarea,button{font-family:'Special Elite',serif;}
    button{user-select:none;cursor:pointer;}
    /* headings in voodoo */
    .voodoo{font-family:'Voodoo',sans-serif;}
    
    /* Analytics modal */
    .analytics-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--dark-grey);
      border: 2px solid var(--red);
      padding: 20px;
      z-index: 1000;
      max-width: 80vw;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 0 30px rgba(255, 0, 51, 0.3);
    }
    
    .analytics-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999;
    }
  </style>
  <style>
  /* Add to your existing style block */
  details summary::-webkit-details-marker {
    display: none;
  }
  details summary {
    position: relative;
    padding-right: 15px;
  }
  details summary:after {
    content: "‚ñº";
    position: absolute;
    right: 0;
    top: 0;
    font-size: 8px;
    transition: transform 0.2s;
    opacity: 0.5;
  }
  details[open] summary:after {
    transform: rotate(180deg);
    opacity: 1;
  }
  details > div {
    position: absolute;
    z-index: 100;
  }
</style>
</head>

<body class="bg-black text-gray-300">
<!-- HEADER -->
<div class="sticky top-0 z-50 w-full pt-4 pb-4 px-4 sm:px-6 md:px-8 border-b border-red-800 bg-black">
  <div class="flex justify-between items-center max-w-full">
   <h1 class="text-3xl font-bold voodoo" style="color:var(--red)">‚ö° dreamweaver reader...‚ö°</h1>

<details class="ml-3">
  <summary class="text-xs font-bold text-gray-500 uppercase tracking-widest cursor-pointer hover:text-red-500 transition-colors list-none">
    ‚ö° Search Guide
  </summary>
  <div class="absolute mt-2 p-3 bg-black border border-gray-800 z-50 w-56 text-xs text-gray-400 space-y-2">
    <div><strong class="text-red-500">Filters:</strong> Click tags above ‚Üí search within that category</div>
    <div><strong class="text-red-500">Search:</strong> Type any word or phrase ‚Ä¢ Highlights instantly</div>
    <div><strong class="text-red-500">Navigation:</strong> ‚Üê ‚Üí arrows ‚Ä¢ R for random ‚Ä¢ ESC to close index</div>
    <div class="text-[10px] text-gray-600 italic pt-1 border-t border-gray-800">Clear search box to exit search mode</div>
  </div>
</details>
    <a href="https://inkrealm.info" class="text-xs font-mono border border-gray-600 px-3 py-1 hover:bg-red-600 hover:text-black hover:border-red-600 transition-all duration-300 uppercase tracking-widest no-underline text-gray-400">Return to Realm</a>
  </div>
</div>

<!-- TWO-COLUMN LAYOUT -->
<div id="brim-layout" class="flex flex-col md:flex-row w-full h-[calc(100vh-80px)] overflow-hidden bg-black">
  <!-- LEFT: READER -->
  <div class="flex-1 flex flex-col h-full border-r border-gray-800 relative min-w-0">
    <div id="loading" class="absolute inset-0 flex items-center justify-center text-xl" style="color:var(--red)">Loading dreamweaver.txt ‚Ä¶</div>
    <div id="content" class="flex-1 overflow-y-auto p-6 md:p-8 lg:p-10 text-base md:text-lg leading-relaxed whitespace-pre-wrap custom-scrollbar" style="display:none;"></div>
    <div id="entryInfo" class="p-3 border-t border-gray-800 text-xs text-gray-500 bg-black flex-shrink-0"></div>
  </div>

  <!-- RIGHT: CONTROLS -->
  <div class="w-full md:w-[400px] flex flex-col h-full bg-[#0a0a0a] border-l border-gray-800 flex-shrink-0">
    <div class="flex-1 overflow-y-auto p-5 custom-scrollbar">
      <!-- NAV -->
      <div class="flex items-center justify-between mb-6 gap-2">
        <button id="prevBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚Üê Prev</button>
        <button id="randomBtn" class="px-4 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">‚ö°</button>
        <button id="nextBtn" class="flex-1 border border-gray-700 hover:border-red-500 text-gray-400 hover:text-red-500 py-2 transition-colors">Next ‚Üí</button>
      </div>

      <!-- SEARCH -->
      <div class="mb-6">
        <input type="text" id="searchBox" class="w-full bg-[#111] border border-gray-700 p-3 text-white focus:border-red-500 focus:outline-none transition-colors" placeholder="Search text...">
        <div class="flex justify-between items-center mt-2">
          <div id="searchStats" class="text-xs text-gray-500 h-4"></div>
          <button id="indexBtn" class="text-xs text-gray-500 hover:text-red-500 uppercase tracking-widest border-b border-transparent hover:border-red-500">Toggle Index</button>
        </div>
      </div>

      <!-- ANALYTICS TOOLBAR (NEW) -->
      <div class="mb-6 pb-6 border-b border-gray-800">
        <div class="flex flex-wrap gap-2 mb-2">
          <button onclick="analyzeWordCount()" class="text-xs px-3 py-1 border border-gray-700 hover:border-red-500 hover:text-red-500 transition-colors">üìä Word Count</button>
          <button onclick="checkCharacterNames()" class="text-xs px-3 py-1 border border-gray-700 hover:border-red-500 hover:text-red-500 transition-colors">üë§ Characters</button>
          <button onclick="findRepetitions()" class="text-xs px-3 py-1 border border-gray-700 hover:border-red-500 hover:text-red-500 transition-colors">üîÅ Repetitions</button>
          <button onclick="checkTimeline()" class="text-xs px-3 py-1 border border-gray-700 hover:border-red-500 hover:text-red-500 transition-colors">‚è∞ Timeline</button>
        </div>
        <div id="analyticsStatus" class="text-[10px] text-gray-600 h-4"></div>
      </div>

      <!-- FILTERS -->
      <div id="filterBtns" class="flex flex-wrap gap-2 mb-6 pb-6 border-b border-gray-800">
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="all">All</button>
         <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="book">Book</button>
        <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="film">Film</button>
         <button class="filter-btn px-3 py-1 text-xs border border-gray-700 text-gray-500 hover:border-red-500" data-filter="dream">Dream</button>
      </div>

      <!-- INDEX -->
      <div id="dateNav" class="hidden mb-6 max-h-60 overflow-y-auto border border-gray-800 bg-[#111] custom-scrollbar"></div>

      <!-- NVIDIA AI -->
      <div class="mt-2">
        <h2 class="text-xl font-bold mb-4 text-gray-600 voodoo">AI EDITOR</h2>
        <input type="password" id="apiKeyInput" class="w-full bg-black border border-gray-800 p-2 text-xs text-red-500 font-mono mb-4 focus:outline-none focus:border-red-900" placeholder="NVIDIA API KEY...">
        <div class="flex gap-2 mb-2">
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="current">Current</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="all">Outline</button>
          <button class="context-btn flex-1 py-1 text-[10px] uppercase border border-gray-700 text-gray-500" data-context="none">None</button>
        </div>
        <p id="contextInfo" class="text-[10px] text-gray-600 mb-3 text-right">Target: Current Entry</p>
        <textarea id="aiInput" class="w-full bg-[#111] border border-gray-800 p-3 text-sm text-gray-300 focus:border-red-500 focus:outline-none min-h-[80px] mb-2" placeholder="Enter prompt..."></textarea>
        <button id="askAiBtn" class="w-full bg-red-900/20 hover:bg-red-900/40 border border-red-900 text-red-500 py-2 text-xs font-bold tracking-widest transition-all">TRANSMIT</button>
        <div id="aiResponse" class="mt-4 p-3 bg-black border border-gray-800 text-sm text-gray-400 min-h-[100px] whitespace-pre-wrap font-mono custom-scrollbar"><span class="opacity-30">:: Awaiting Input ::</span></div>
      </div>
    </div>
  </div>
</div>

<!-- ============  READER SCRIPT  ============ -->
<script id="reader-script">
/* ----------  CONFIG  ---------- */

const TXT_FILE_URL = 'dreamweaver.txt';

// REGEX: Matches dates like:
// 12.12.23 | 2024-01-01 | Jan 12, 2024 | 12 Jan 2024
const ENTRY_PATTERN = /^(\d{1,2}[\/\.-]\d{1,2}[\/\.-]\d{2,4}|\d{4}[-\/]\d{1,2}[-\/]\d{1,2}|(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{1,2},?\s+\d{4}|\d{1,2}\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+\d{4})/i;

// KEYWORDS: This is how the code knows which tab a text belongs to.
const TAG_PATTERNS = {
  all: /.*/,
  lyric: /\b(lyrics?|song|track|release|chords|verse|chorus|hook|beat|tempo|melody|harmony|vocals|singing|performer|band|album|single|studio|recording|entitled|special thanks)\b|\[lyric\]/i,
  poem: /\b(poem|poetry|stanza|lime|sonnet|verse|couplet|line break|girl|meter|rhyme|rhythm|metaphor|simile|imagery|symbolism|alliteration|assonance|free verse|blank verse)\b|\[poem\]/i,
  film: /\b(film|movie|cinema|screenplay|script|scene|shot|frame|director|producer|camera|lens|visual|screening|broadcast|tv|drama|watching|viewing|credits|studio|scene)\b|\[film\]/i,
  book: /\b(book|novel|story|narrative|text|page|chapter|author|writer|writing|wrote|reading|read|literature|prose|essay|journal|diary|memoir|biography|publish|edition|volume)\b|\[book\]/i,
  dream: /\b(dream|dreamt|dreaming|nightmare|sleep|slumber|awake|waking|woke|unconscious|surreal|subconscious|her|me|trance|i|nocturnal|midnight|twilight)\b|\[dream\]/i
};

/* ----------  STATE  ---------- */
window.readerEntries = [];
window.readerCurrentIndex = 0;
let currentFilter = 'all';
let searchQuery = '';
let searchResults = [];
let isSearching = false;
let isIndexVisible = false;
let searchTimeout = null;

/* ----------  DOM  ---------- */
const searchBox = document.getElementById('searchBox');
const searchStats = document.getElementById('searchStats');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const randomBtn = document.getElementById('randomBtn');
const indexBtn = document.getElementById('indexBtn');
const dateNav = document.getElementById('dateNav');
const entryInfo = document.getElementById('entryInfo');
const loadingDiv = document.getElementById('loading');
const contentDiv = document.getElementById('content');
const analyticsStatus = document.getElementById('analyticsStatus');

/* ----------  ANALYTICS FUNCTIONS (OPTIMIZED FOR LARGE FILES) ---------- */

function showAnalyticsModal(content) {
  // Remove any existing modal
  const existingModal = document.querySelector('.analytics-modal');
  const existingOverlay = document.querySelector('.analytics-overlay');
  if (existingModal) existingModal.remove();
  if (existingOverlay) existingOverlay.remove();
  
  // Create overlay
  const overlay = document.createElement('div');
  overlay.className = 'analytics-overlay';
  overlay.onclick = () => {
    overlay.remove();
    modal.remove();
  };
  
  // Create modal
  const modal = document.createElement('div');
  modal.className = 'analytics-modal custom-scrollbar';
  modal.innerHTML = `
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-xl voodoo" style="color:var(--red)">ANALYTICS</h3>
      <button onclick="this.closest('.analytics-modal').remove(); this.closest('.analytics-overlay').remove();" class="text-xs border border-gray-700 px-2 py-1 hover:border-red-500">CLOSE</button>
    </div>
    <div class="text-sm font-mono whitespace-pre-wrap max-h-[60vh] overflow-y-auto">${content}</div>
  `;
  
  document.body.appendChild(overlay);
  document.body.appendChild(modal);
}

function setAnalyticsStatus(text, isError = false) {
  analyticsStatus.textContent = text;
  analyticsStatus.style.color = isError ? 'var(--red)' : 'var(--white)';
}

// Memory-efficient word count analysis
function analyzeWordCount() {
  setAnalyticsStatus('Analyzing word count...');
  
  setTimeout(() => {
    try {
      if (!window.readerEntries.length) {
        setAnalyticsStatus('No entries loaded', true);
        return;
      }
      
      const stats = {
        totalEntries: window.readerEntries.length,
        totalWords: 0,
        totalCharacters: 0,
        averageWords: 0,
        longestEntry: { title: '', words: 0 },
        shortestEntry: { title: '', words: Infinity }
      };
      
      const wordCountsByTag = {};
      const monthlyWords = {};
      
      // Process entries in chunks to avoid blocking
      let processed = 0;
      const processChunk = (start, end) => {
        for (let i = start; i < end && i < window.readerEntries.length; i++) {
          const entry = window.readerEntries[i];
          const words = entry.content.trim().split(/\s+/).length;
          const chars = entry.content.length;
          
          stats.totalWords += words;
          stats.totalCharacters += chars;
          
          // Track longest/shortest
          if (words > stats.longestEntry.words) {
            stats.longestEntry = { title: entry.title, words };
          }
          if (words < stats.shortestEntry.words) {
            stats.shortestEntry = { title: entry.title, words };
          }
          
          // Count by tag
          entry.tags.forEach(tag => {
            wordCountsByTag[tag] = (wordCountsByTag[tag] || 0) + words;
          });
          if (entry.tags.length === 0) {
            wordCountsByTag['untagged'] = (wordCountsByTag['untagged'] || 0) + words;
          }
          
          // Extract month from title for monthly stats
          const monthMatch = entry.title.match(/(\d{4})[-\/](\d{1,2})/);
          if (monthMatch) {
            const key = `${monthMatch[1]}-${monthMatch[2].padStart(2, '0')}`;
            monthlyWords[key] = (monthlyWords[key] || 0) + words;
          }
          
          processed++;
        }
      };
      
      // Process in chunks of 500 entries
      const chunkSize = 500;
      for (let i = 0; i < window.readerEntries.length; i += chunkSize) {
        processChunk(i, i + chunkSize);
      }
      
      stats.averageWords = Math.round(stats.totalWords / stats.totalEntries);
      
      // Sort tags by word count
      const sortedTags = Object.entries(wordCountsByTag)
        .sort((a, b) => b[1] - a[1])
        .map(([tag, count]) => `${tag}: ${count.toLocaleString()} words`);
      
      // Sort months chronologically
      const sortedMonths = Object.entries(monthlyWords)
        .sort(([a], [b]) => a.localeCompare(b))
        .slice(-12) // Last 12 months
        .map(([month, count]) => `${month}: ${count.toLocaleString()} words`);
      
      const report = `
TOTAL ENTRIES: ${stats.totalEntries.toLocaleString()}
TOTAL WORDS: ${stats.totalWords.toLocaleString()}
TOTAL CHARACTERS: ${stats.totalCharacters.toLocaleString()}
AVERAGE WORDS PER ENTRY: ${stats.averageWords.toLocaleString()}

LONGEST ENTRY: "${stats.longestEntry.title}" (${stats.longestEntry.words.toLocaleString()} words)
SHORTEST ENTRY: "${stats.shortestEntry.title}" (${stats.shortestEntry.words.toLocaleString()} words)

WORD COUNT BY TAG:
${sortedTags.join('\n')}

RECENT MONTHLY ACTIVITY (Last 12 months):
${sortedMonths.join('\n')}

ENTRIES WITH 1000+ WORDS: ${window.readerEntries.filter(e => e.content.trim().split(/\s+/).length >= 1000).length}
ENTRIES WITH < 100 WORDS: ${window.readerEntries.filter(e => e.content.trim().split(/\s+/).length < 100).length}

Last updated: ${new Date().toLocaleString()}
      `.trim();
      
      showAnalyticsModal(report);
      setAnalyticsStatus('Word count analysis complete');
    } catch (error) {
      console.error('Word count error:', error);
      setAnalyticsStatus('Analysis failed: ' + error.message, true);
    }
  }, 50);
}

// Optimized character name detection
function checkCharacterNames() {
  setAnalyticsStatus('Scanning for characters...');
  
  setTimeout(() => {
    try {
      const commonNames = [
        'alice', 'bob', 'charlie', 'david', 'eve', 'frank', 'grace', 'henry', 'isabel', 'jack',
        'kate', 'leo', 'mia', 'nathan', 'olivia', 'paul', 'quinn', 'rachel', 'sam', 'tara',
        'lotta', 'wendy', 'xavier', 'yvonne', 'zack',
        'john', 'jane', 'mary', 'james', 'emilee', 'michael', 'william', 'david', 'richard', 'joseph',
        'thomas', 'charles', 'christopher', 'daniel', 'matthew', 'tim', 'donald', 'mark', 'inky'
      ];
      
      const characterMap = new Map();
      const characterMentions = new Map();
      const nameRegex = /\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g;
      
      // Sample entries to avoid processing everything (for performance)
      const sampleSize = Math.min(500, window.readerEntries.length);
      const sampleEntries = window.readerEntries
        .sort(() => Math.random() - 0.5)
        .slice(0, sampleSize);
      
      sampleEntries.forEach(entry => {
        const matches = entry.content.match(nameRegex);
        if (matches) {
          matches.forEach(name => {
            const normalized = name.toLowerCase();
            // Filter out common words that aren't names
            if (name.length > 2 && 
                !['The', 'And', 'But', 'For', 'Not', 'You', 'She', 'He', 'They', 'This', 'That'].includes(name) &&
                !normalized.endsWith('\'s')) {
              
              characterMap.set(name, (characterMap.get(name) || 0) + 1);
              
              // Track which entries mention this character
              if (!characterMentions.has(name)) {
                characterMentions.set(name, new Set());
              }
              characterMentions.get(name).add(entry.title);
            }
          });
        }
      });
      
      // Convert to array and sort by frequency
      const sortedCharacters = Array.from(characterMap.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 50); // Top 50 characters
      
      let report = `CHARACTER ANALYSIS (sampled ${sampleSize} entries)\n\n`;
      report += `Total unique potential characters: ${characterMap.size}\n\n`;
      
      if (sortedCharacters.length > 0) {
        report += 'MOST FREQUENT CHARACTERS:\n';
        sortedCharacters.forEach(([name, count], index) => {
          const mentions = Array.from(characterMentions.get(name) || []).slice(0, 3);
          report += `${index + 1}. ${name}: ${count} mentions`;
          if (mentions.length > 0) {
            report += ` (in: ${mentions.join(', ')})`;
          }
          report += '\n';
        });
      } else {
        report += 'No character names detected. Try a larger sample.';
      }
      
      report += `\n\nCommon names detected: ${commonNames.filter(name => characterMap.has(name)).join(', ')}`;
      report += `\n\nAnalysis completed at: ${new Date().toLocaleTimeString()}`;
      
      showAnalyticsModal(report);
      setAnalyticsStatus(`Found ${characterMap.size} potential characters`);
    } catch (error) {
      console.error('Character analysis error:', error);
      setAnalyticsStatus('Character scan failed', true);
    }
  }, 50);
}

// Find repeated phrases (optimized for large text)
function findRepetitions() {
  setAnalyticsStatus('Finding repetitions...');
  
  setTimeout(() => {
    try {
      // Use a sampling approach for large files
      const sampleText = window.readerEntries
        .slice(0, 100) // First 100 entries
        .map(e => e.content.toLowerCase())
        .join('\n')
        .replace(/[^\w\s]/g, ' ');
      
      const words = sampleText.split(/\s+/).filter(w => w.length > 3);
      const phraseLength = 3; // Look for 3-word phrases
      const phraseCounts = new Map();
      
      // Count phrases
      for (let i = 0; i <= words.length - phraseLength; i++) {
        const phrase = words.slice(i, i + phraseLength).join(' ');
        phraseCounts.set(phrase, (phraseCounts.get(phrase) || 0) + 1);
      }
      
      // Filter for repetitions (appear at least 3 times)
      const repetitions = Array.from(phraseCounts.entries())
        .filter(([_, count]) => count >= 3)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 20); // Top 20 repetitions
      
      let report = 'REPETITION ANALYSIS (3-word phrases)\n\n';
      report += `Analyzed ${words.length.toLocaleString()} words from first 100 entries\n\n`;
      
      if (repetitions.length > 0) {
        report += 'MOST REPEATED PHRASES:\n';
        repetitions.forEach(([phrase, count], index) => {
          report += `${index + 1}. "${phrase}": ${count} times\n`;
        });
        
        // Find example entries containing the top repetition
        if (repetitions.length > 0) {
          const topPhrase = repetitions[0][0];
          const exampleEntries = window.readerEntries
            .filter(e => e.content.toLowerCase().includes(topPhrase))
            .slice(0, 3)
            .map(e => `‚Ä¢ ${e.title}`)
            .join('\n');
          
          if (exampleEntries) {
            report += `\n"${topPhrase}" appears in:\n${exampleEntries}`;
          }
        }
      } else {
        report += 'No significant repetitions found (3+ occurrences).';
      }
      
      report += `\n\nAnalysis completed: ${new Date().toLocaleString()}`;
      
      showAnalyticsModal(report);
      setAnalyticsStatus(`Found ${repetitions.length} repeated phrases`);
    } catch (error) {
      console.error('Repetition analysis error:', error);
      setAnalyticsStatus('Repetition search failed', true);
    }
  }, 50);
}

// Timeline analysis
function checkTimeline() {
  setAnalyticsStatus('Building timeline...');
  
  setTimeout(() => {
    try {
      // Extract dates from titles
      const datePatterns = [
        /(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/, // YYYY-MM-DD
        /(\d{1,2})[-\/](\d{1,2})[-\/](\d{4})/, // DD-MM-YYYY
        /(\d{1,2})\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+(\d{4})/i, // DD Month YYYY
        /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s+(\d{1,2}),?\s+(\d{4})/i // Month DD, YYYY
      ];
      
      const monthMap = {
        jan: '01', feb: '02', mar: '03', apr: '04', may: '05', jun: '06',
        jul: '07', aug: '08', sep: '09', oct: '10', nov: '11', dec: '12'
      };
      
      const entriesWithDates = [];
      
      window.readerEntries.forEach(entry => {
        let dateStr = null;
        let year, month, day;
        
        for (const pattern of datePatterns) {
          const match = entry.title.match(pattern);
          if (match) {
            if (pattern === datePatterns[0]) { // YYYY-MM-DD
              [, year, month, day] = match;
            } else if (pattern === datePatterns[1]) { // DD-MM-YYYY
              [, day, month, year] = match;
            } else if (pattern === datePatterns[2]) { // DD Month YYYY
              [, day, month, year] = match;
              month = monthMap[month.toLowerCase().substring(0, 3)];
            } else if (pattern === datePatterns[3]) { // Month DD, YYYY
              [, month, day, year] = match;
              month = monthMap[month.toLowerCase().substring(0, 3)];
            }
            
            if (year && month && day) {
              month = month.padStart(2, '0');
              day = day.padStart(2, '0');
              dateStr = `${year}-${month}-${day}`;
              break;
            }
          }
        }
        
        if (dateStr) {
          entriesWithDates.push({
            title: entry.title,
            date: dateStr,
            timestamp: new Date(dateStr).getTime(),
            words: entry.content.trim().split(/\s+/).length,
            tags: entry.tags
          });
        }
      });
      
      // Sort by date
      entriesWithDates.sort((a, b) => a.timestamp - b.timestamp);
      
      // Group by year and month
      const byYear = {};
      const byMonth = {};
      
      entriesWithDates.forEach(entry => {
        const year = entry.date.substring(0, 4);
        const month = entry.date.substring(0, 7);
        
        byYear[year] = (byYear[year] || 0) + 1;
        byMonth[month] = (byMonth[month] || 0) + 1;
      });
      
      // Calculate statistics
      const totalWithDates = entriesWithDates.length;
      const firstDate = entriesWithDates[0]?.date;
      const lastDate = entriesWithDates[entriesWithDates.length - 1]?.date;
      
      // Most productive months
      const productiveMonths = Object.entries(byMonth)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
      
      let report = 'TIMELINE ANALYSIS\n\n';
      report += `Entries with detectable dates: ${totalWithDates}/${window.readerEntries.length} (${Math.round(totalWithDates/window.readerEntries.length*100)}%)\n`;
      report += `Timespan: ${firstDate || 'N/A'} to ${lastDate || 'N/A'}\n\n`;
      
      report += 'ENTRIES BY YEAR:\n';
      Object.entries(byYear)
        .sort(([a], [b]) => a.localeCompare(b))
        .forEach(([year, count]) => {
          report += `${year}: ${count} entries\n`;
        });
      
      report += '\nMOST PRODUCTIVE MONTHS:\n';
      productiveMonths.forEach(([month, count], index) => {
        report += `${index + 1}. ${month}: ${count} entries\n`;
      });
      
      // Find gaps in timeline
      if (entriesWithDates.length > 1) {
        const gaps = [];
        for (let i = 1; i < entriesWithDates.length; i++) {
          const gapDays = Math.round((entriesWithDates[i].timestamp - entriesWithDates[i-1].timestamp) / (1000 * 60 * 60 * 24));
          if (gapDays > 30) { // Gaps longer than a month
            gaps.push({
              from: entriesWithDates[i-1].date,
              to: entriesWithDates[i].date,
              days: gapDays
            });
          }
        }
        
        if (gaps.length > 0) {
          report += '\nSIGNIFICANT GAPS (>30 days):\n';
          gaps.slice(0, 5).forEach(gap => {
            report += `${gap.from} ‚Üí ${gap.to}: ${gap.days} days\n`;
          });
        }
      }
      
      report += `\nAnalysis completed: ${new Date().toLocaleString()}`;
      
      showAnalyticsModal(report);
      setAnalyticsStatus(`Timeline built with ${totalWithDates} dated entries`);
    } catch (error) {
      console.error('Timeline analysis error:', error);
      setAnalyticsStatus('Timeline analysis failed', true);
    }
  }, 50);
}

/* ----------  SEARCH UTILS  ---------- */
function parseSearchQuery(q) {
  const terms = { and: [], or: [], not: [], exact: [] };
  const exactMatches = q.match(/"[^"]+"/g);
  if (exactMatches) {
    exactMatches.forEach(match => {
      terms.exact.push(match.replace(/"/g, '').toLowerCase());
      q = q.replace(match, '');
    });
  }
  let op = 'and';
  q.toLowerCase().split(/\s+/).filter(Boolean).forEach(w => {
    if (w === 'and') op = 'and';
    else if (w === 'or') op = 'or';
    else if (w.startsWith('-')) terms.not.push(w.slice(1));
    else terms[op].push(w);
  });
  return terms;
}

function matchesSearch(e, terms) {
  const txt = (e.content + ' ' + e.title).toLowerCase();
  if (terms.not.some(x => txt.includes(x))) return false;
  if (terms.exact.length && !terms.exact.every(x => txt.includes(x))) return false;
  if (terms.and.length && !terms.and.every(x => txt.includes(x))) return false;
  if (terms.or.length && !terms.or.some(x => txt.includes(x))) return false;
  return true;
}

function highlightText(text, query) {
  if (!query) return text;
  
  try {
    const escapedQuery = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`(${escapedQuery})`, 'gi');
    return text.replace(regex, '<span class="highlight" style="background:var(--red); color:black; padding:0 2px;">$1</span>');
  } catch (e) {
    console.log('Highlight error:', e);
    return text;
  }
}

function debounce(func, delay) {
  return function(...args) {
    if (searchTimeout) clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => func.apply(this, args), delay);
  };
}

/* ----------  LOAD & PARSE  ---------- */
async function loadText() {
  try {
    const res = await fetch(TXT_FILE_URL);
    if (!res.ok) throw new Error('File not found');
    let text = await res.text();
    
    // Normalize line endings
    text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    
    parseEntries(text);
    
    loadingDiv.style.display = 'none';
    contentDiv.style.display = 'block';

    if (window.readerEntries.length > 0) {
      // If we are refreshing, try to stay on the same entry, otherwise go to first
      showEntry(window.readerEntries[0].id);
    }
    
    // Set "All" button active
    const allBtn = document.querySelector('.filter-btn[data-filter="all"]');
    if (allBtn) styleActiveFilter(allBtn);
    
    buildIndex();
    updateUIState();
  } catch (err) {
    loadingDiv.innerHTML = `<p style="color:var(--red)">Error: ${err.message}</p>`;
  }
}

function parseEntries(text) {
  const lines = text.split('\n');
  let current = null;
  let id = 0;

  lines.forEach(line => {
    // TRIM line before checking regex. 
    // This allows dates to have accidental spaces before them.
    const cleanLine = line.trim(); 
    const m = cleanLine.match(ENTRY_PATTERN);
    
    if (m) {
      // Save previous entry if exists
      if (current && current.content.trim()) {
        detectTags(current);
        window.readerEntries.push(current);
      }
      
      // Start new entry
      current = {
        id: ++id,
        title: m[0].trim(), // Use the regex match as the title
        content: line + '\n',
        tags: []
      };
    } else if (current) {
      // Continue current entry
      current.content += line + '\n';
    }
  });

  // Don't forget the last entry
  if (current && current.content.trim()) {
    detectTags(current);
    window.readerEntries.push(current);
  }
  
  console.log(`Parsed ${window.readerEntries.length} entries`);
}

function detectTags(e) {
  // combine title and content for better detection
  const text = (e.title + ' ' + e.content).toLowerCase();
  
  for (const [tag, re] of Object.entries(TAG_PATTERNS)) {
    if (tag !== 'all' && re.test(text)) {
      e.tags.push(tag);
    }
  }
}

function getFilteredEntries() {
  return currentFilter === 'all' 
    ? window.readerEntries 
    : window.readerEntries.filter(e => e.tags.includes(currentFilter));
}

/* ----------  DISPLAY  ---------- */
function showEntry(entryId) {
  const e = window.readerEntries.find(x => x.id === entryId);
  if (!e) return;
  
  window.readerCurrentIndex = entryId;
  
  let displayContent = e.content;
  
  // Apply highlighting if searching
  if (isSearching && searchQuery) {
    displayContent = highlightText(displayContent, searchQuery);
  }
  
  // Format paragraphs
  displayContent = displayContent.split('\n').map(line => {
    const trimmed = line.trim();
    if (!trimmed) return '<br>';
    return `<p class="mb-4 leading-relaxed">${trimmed}</p>`;
  }).join('');
  
  contentDiv.innerHTML = displayContent;
  
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === entryId);
  const words = e.content.replace(/<[^>]*>/g, '').trim().split(/\s+/).length;
  
  // Generate Tags HTML
// Generate Tags HTML
  const tagsHtml = e.tags.length > 0 
    ? e.tags.map(t => `<span class="px-2 py-1 border text-[10px] uppercase border-gray-600 ${t === currentFilter ? 'text-red-500 border-red-500' : 'text-gray-400'}">${t}</span>`).join('')
    : '<span class="px-2 py-1 border text-[10px] uppercase border-gray-800 text-gray-700">Unclassified</span>';

  // Add a filter indicator if we aren't viewing "All"
  const filterIndicator = currentFilter !== 'all' 
    ? `<span class="text-[10px] uppercase tracking-wider text-red-500 border border-red-900 bg-red-900/20 px-2 py-1 rounded ml-2">FILTER: ${currentFilter}</span>` 
    : '';

  entryInfo.innerHTML = `
    <div class="flex flex-col gap-1">
      <div class="flex items-center flex-wrap">
        <span class="text-xs text-gray-500 uppercase tracking-widest">DREAMWEAVER ARCHIVE</span>
        ${filterIndicator}
        <span class="ml-2 font-bold text-xl voodoo" style="color:var(--red)">${e.title}</span>
      </div>
      <div class="text-xs text-gray-400 flex items-center gap-2 flex-wrap">
        ${isSearching ? `Result ${idx + 1}/${searchResults.length}` : `Entry ${idx + 1}/${pool.length}`}
        <span>‚Ä¢</span>${words} words
        <span class="ml-2 flex gap-1 flex-wrap">${tagsHtml}</span>
      </div>
    </div>`;
  
  // Smart button disabling
  prevBtn.disabled = idx <= 0;
  nextBtn.disabled = idx >= pool.length - 1;
  
  // Visual feedback for disabled buttons
  prevBtn.style.opacity = prevBtn.disabled ? '0.3' : '1';
  nextBtn.style.opacity = nextBtn.disabled ? '0.3' : '1';

  contentDiv.scrollTop = 0;
  if (isIndexVisible) buildIndex();
}

function showRandomEntry() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  if (!pool.length) return;
  
  let randomIdx;
  // Try to find a new one, but don't loop forever if only 1 exists
  do {
    randomIdx = Math.floor(Math.random() * pool.length);
  } while (pool[randomIdx].id === window.readerCurrentIndex && pool.length > 1);
  
  showEntry(pool[randomIdx].id);
}

function navigateEntries(dir) {
  const pool = isSearching ? searchResults : getFilteredEntries();
  const idx = pool.findIndex(x => x.id === window.readerCurrentIndex);
  const newIdx = dir === 'next' ? idx + 1 : idx - 1;
  
  if (newIdx >= 0 && newIdx < pool.length) {
    showEntry(pool[newIdx].id);
  }
}

function buildIndex() {
  const pool = isSearching ? searchResults : getFilteredEntries();
  dateNav.innerHTML = '';
  
  if (pool.length === 0) {
    dateNav.innerHTML = '<div class="p-4 text-xs text-gray-600">No entries found for this filter.</div>';
    return;
  }

  pool.forEach(e => {
    const div = document.createElement('div');
    div.className = 'p-3 border-b border-gray-700 cursor-pointer hover:bg-gray-900 transition-colors';
    
    if (e.id === window.readerCurrentIndex) {
      div.style.background = '#1a1a1a';
      div.style.borderLeft = '3px solid var(--red)';
    }
    
    const preview = e.content.replace(/<[^>]*>/g, '').substring(0, 50).replace(/\n/g, ' ') + '...';
    
    div.innerHTML = `
      <div class="text-sm font-bold text-gray-300 mb-1 truncate voodoo">${e.title}</div>
      <div class="text-xs text-gray-600 font-mono truncate">${preview}</div>
    `;
    
    div.addEventListener('click', () => showEntry(e.id));
    dateNav.appendChild(div);
  });
}

function styleActiveFilter(btn) {
  document.querySelectorAll('.filter-btn').forEach(b => {
    b.style.background = 'transparent';
    b.style.borderColor = '#333';
    b.style.color = '#666';
  });
  
  btn.style.background = 'var(--red)';
  btn.style.color = 'black';
  btn.style.borderColor = 'var(--red)';
}

/* ----------  SEARCH  ---------- */
function performSearch(query) {
  const trimmedQuery = query.trim();
  console.log('Searching for:', trimmedQuery);
  
  if (!trimmedQuery) {
    isSearching = false;
    searchResults = [];
    updateUIState();
    
    // Show current or first entry
    const pool = getFilteredEntries();
    if (pool.length > 0) {
      const entryToShow = window.readerCurrentIndex > 0 ? 
        window.readerCurrentIndex : pool[0].id;
      showEntry(entryToShow);
    }
    return;
  }
  
  isSearching = true;
  searchQuery = trimmedQuery;
  
  // SIMPLE SEARCH - Change this line to decide scope:
  // Option A: Search within current filter (like horse reader)
  const pool = getFilteredEntries();
  
  // Option B: Search ALL entries (old behavior you wanted)
  // const pool = window.readerEntries;
  
  const queryLower = trimmedQuery.toLowerCase();
  
  searchResults = pool.filter(entry => {
    const searchText = (entry.content + ' ' + entry.title).toLowerCase();
    return searchText.includes(queryLower);
  });
  
  console.log(`Found ${searchResults.length} of ${pool.length} entries`);
  
  updateUIState();
  
  if (searchResults.length > 0) {
    showEntry(searchResults[0].id);
  } else {
    contentDiv.innerHTML = `
      <div class="text-center mt-10 p-4">
        <div class="text-gray-500">No matches found for "${trimmedQuery}"</div>
      </div>`;
    entryInfo.innerHTML = `<div class="text-xs text-gray-500">Search: "${trimmedQuery}"</div>`;
  }
}

function updateUIState() {
  if (isSearching) {
    searchStats.textContent = `${searchResults.length} matches`;
  } else {
    const count = getFilteredEntries().length;
    searchStats.textContent = currentFilter !== 'all' ? `${count} ${currentFilter}s` : `${count} entries`;
  }
  buildIndex();
}

/* ----------  EVENTS  ---------- */
document.addEventListener('DOMContentLoaded', loadText);

searchBox.addEventListener('input', debounce(e => performSearch(e.target.value), 300));

prevBtn.addEventListener('click', () => navigateEntries('prev'));
nextBtn.addEventListener('click', () => navigateEntries('next'));
randomBtn.addEventListener('click', showRandomEntry);

indexBtn.addEventListener('click', () => {
  isIndexVisible = !isIndexVisible;
  dateNav.classList.toggle('hidden');
  if (isIndexVisible) buildIndex();
});

document.getElementById('filterBtns').addEventListener('click', e => {
  if (!e.target.classList.contains('filter-btn')) return;
  
  styleActiveFilter(e.target);
  currentFilter = e.target.dataset.filter;
  
  // Clear search when switching filters to avoid confusion
  searchBox.value = '';
  isSearching = false;
  
  // UX IMPROVEMENT: 
  // 1. Force the index to open so we see the list of filtered items
  isIndexVisible = true;
  dateNav.classList.remove('hidden');
  
  // 2. Update the UI
  updateUIState();
  
  // 3. Show first entry of new filter, or random if that feels more "Dreamweaver"
  const filtered = getFilteredEntries();
  if (filtered.length > 0) {
    showEntry(filtered[0].id);
    // Scroll the index to the top so we see the new results
    dateNav.scrollTop = 0;
  } else {
    contentDiv.innerHTML = `<div class="text-center mt-20 text-gray-600">No entries found tagged as <span style="color:var(--red)">${currentFilter}</span>.</div>`;
    entryInfo.innerHTML = '';
  }
});

document.addEventListener('keydown', e => {
  if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
  
  if (e.key === 'ArrowLeft') navigateEntries('prev');
  if (e.key === 'ArrowRight') navigateEntries('next');
  if (e.key.toLowerCase() === 'r') showRandomEntry();
  if (e.key === 'Escape' && isIndexVisible) {
    dateNav.classList.add('hidden');
    isIndexVisible = false;
  }
});
</script>

<!-- keep your existing ai-script block here -->
<script id="ai-script">
/* ----------  AI CONFIG  ---------- */
const NVIDIA_MODELS={
  stable:"meta/llama-3.3-70b-instruct",
  backup:"nvidia/llama-3.1-nemotron-70b-instruct"
};
let currentModel=NVIDIA_MODELS.stable,aiContext='current';
const apiKeyInput=document.getElementById('apiKeyInput');
const aiInput=document.getElementById('aiInput');
const askAiBtn=document.getElementById('askAiBtn');
const aiResponseDiv=document.getElementById('aiResponse');
const contextInfo=document.getElementById('contextInfo');

/* ----------  INIT  ---------- */
if(localStorage.getItem('dreamweaver_nvidia_key'))apiKeyInput.value=localStorage.getItem('dreamweaver_nvidia_key');
apiKeyInput.addEventListener('input',e=>localStorage.setItem('dreamweaver_nvidia_key',e.target.value));

/* ----------  TRANSMIT  ---------- */
askAiBtn.addEventListener('click',async()=>{
  const key=apiKeyInput.value.trim(),msg=aiInput.value.trim();
  if(!key){aiResponseDiv.innerHTML='<p class="text-red-500">Please enter an NVIDIA API Key.</p>';return;}
  if(!msg)return;
  if(!window.readerEntries?.length){aiResponseDiv.innerHTML='<p class="text-red-500">dreamweaver.txt not loaded yet.</p>';return;}
  askAiBtn.disabled=true;askAiBtn.textContent='TRANSMITTING...';
  aiResponseDiv.innerHTML='<p class="animate-pulse" style="color:var(--red)">Consulting Llama...</p>';
  try{
    let ctx='';
    if(aiContext==='current'){
      const e=window.readerEntries.find(x=>x.id===window.readerCurrentIndex);
      if(e)ctx=`CONTEXT (Current ‚Äì ${e.title}):\n${e.content.substring(0,4000)}\n\n---\n`;
    }else if(aiContext==='all'){
      ctx=`CONTEXT (Outline):\n${window.readerEntries.map(x=>`- ${x.title} (${x.tags.join(', ')})`).join('\n')}\n\n---\n`;
    }
    const proxy='https://corsproxy.io/?'+encodeURIComponent('https://integrate.api.nvidia.com/v1/chat/completions');
    const res=await fetch(proxy,{
      method:'POST',
      headers:{Authorization:`Bearer ${key}`,'Content-Type':'application/json'},
      body:JSON.stringify({
        model:currentModel,
        messages:[
          {role:'system',content:'You are an editor for DREAMWEAVER, a narrative where reality and dreams blur. Analyse via surrealism. Be bold, concise, literary.'},
          {role:'user',content:ctx+'User Question: '+msg}
        ],
        temperature:.6,top_p:1,max_tokens:1024
      })
    });
    if(!res.ok){if(res.status===404)throw new Error('404 Switch');const t=await res.text();let m=t;try{m=JSON.parse(t).error?.message||t;}catch{m=t}throw new Error(m);}
    const data=await res.json();
    let txt=data.choices[0].message.content;
    txt=txt.replace(/\*\*(.*?)\*\*/g,'<strong style="color:var(--red)">$1</strong>').replace(/\n/g,'<br>');
    aiResponseDiv.innerHTML=txt;
  }catch(err){
    console.error(err);
    if(err.message.includes('404')||err.message.includes('Switch')){
      currentModel=NVIDIA_MODELS.backup;
      aiResponseDiv.innerHTML='<p style="color:#888">Primary model unavailable. Switched to Backup.<br><strong>Please click Transmit again.</strong></p>';
    }else{
      aiResponseDiv.innerHTML=`<p style="color:var(--red)">Error: ${err.message}</p>`;
    }
  }finally{askAiBtn.disabled=false;askAiBtn.textContent='TRANSMIT';}
});

/* ----------  CONTEXT BUTTONS  ---------- */
document.addEventListener('click',e=>{
  if(!e.target.classList.contains('context-btn'))return;
  document.querySelectorAll('.context-btn').forEach(b=>{b.style.background='var(--dark-grey)';b.style.color='#888';b.style.borderColor='#333';});
  e.target.style.background='var(--red)';e.target.style.color='black';e.target.style.borderColor='var(--red)';
  aiContext=e.target.dataset.context;
  contextInfo.textContent=`Context: ${aiContext.toUpperCase()} (${aiContext==='current'?'Reading current entry':aiContext==='all'?'Reading all titles':'No context'})`;
});
</script>
</body>
</html>
