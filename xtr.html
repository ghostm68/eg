<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INK REALM SPLASH</title>
    <link rel="stylesheet" href="style.css">
</head>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
    overflow: hidden;
    background: #000;
    font-family: 'Courier New', monospace;
}

#three-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 1;
}

/* TV Static Effect */
.tv-static {
    position: fixed;
    width: 100vw;
    height: 100vh;
    background: 
        repeating-radial-gradient(circle at 50% 50%, 
            rgba(255, 0, 60, 0.03) 0%,
            transparent 2px),
        repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.02) 0px,
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 2px
        );
    opacity: 0.4;
    animation: static-flicker 0.15s infinite;
    pointer-events: none;
    z-index: 2;
    mix-blend-mode: overlay;
}

@keyframes static-flicker {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.5; }
}

/* Headlines */
.headline {
    position: fixed;
    width: 100vw;
    height: 50vh;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 3;
    pointer-events: none;
}

.headline.top { top: 0; }
.headline.bottom { bottom: 0; }

.glitch {
    position: relative;
    font-family: 'Arial Black', sans-serif;
    font-size: 15vw;
    font-weight: 900;
    text-transform: uppercase;
    letter-spacing: -0.05em;
    color: white;
    text-shadow: 
        8px 8px 0 #ff003c,
        -5px -5px 0 #000;
    animation: glitch-skew 3s infinite;
}

.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

.glitch::before {
    color: #ff003c;
    animation: glitch-1 2.5s infinite;
    clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}

.glitch::after {
    color: rgba(255, 255, 255, 0.8);
    animation: glitch-2 2s infinite;
    clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}

@keyframes glitch-skew {
    0%, 40% { transform: skew(0deg); }
    41% { transform: skew(3deg) scaleX(1.01); }
    42% { transform: skew(-2deg) scaleX(0.99); }
    43%, 100% { transform: skew(0deg); }
}

@keyframes glitch-1 {
    0%, 7% { transform: translate(0); }
    8% { transform: translate(-2px, 1px); }
    9% { transform: translate(1px, -1px); }
    10%, 100% { transform: translate(0); }
}

@keyframes glitch-2 {
    0%, 2% { transform: translate(0); }
    3% { transform: translate(3px, -1px); }
    4% { transform: translate(-1px, 2px); }
    5%, 100% { transform: translate(0); }
}
</style>
<body>
    <!-- TV Static Overlay (CSS) -->
    <div class="tv-static"></div>
    
    <!-- Canvas for Three.js -->
    <canvas id="three-canvas"></canvas>
    
    <!-- Main Headlines (HTML/CSS for reliability) -->
    <div class="headline top">
        <h1 class="glitch" data-text="WORDSTAR">WORDSTAR</h1>
    </div>
    <div class="headline bottom">
        <h1 class="glitch" data-text="NEXUS">NEXUS</h1>
    </div>
    
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Optional: Controls for debugging -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>// Configuration
const CONFIG = {
    colors: [0xff003c, 0xffffff], // Red, White
    wordList: [
        "dreamweaver", "wip", "dejavuglitches", "displaywriter", "bakedalaska",
        "38", "custompad", "typecast", "typespace", "citadelle",
        "typewriter", "birch", "cut&rune", "conceptweave",
        "daslexikondaslexikon", "ai", "netherlands", "90263", "everex"
    ],
    totalWords: 200, // Total instances (repeats allowed)
    speedRange: [0.5, 2.0], // Min/max movement speed
    sizeRange: [0.8, 3.5], // Min/max font size
    depth: 100, // Z-axis range (-50 to 50)
    rotationSpeed: 0.5
};

// Scene Setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 40;

const renderer = new THREE.WebGLRenderer({ 
    canvas: document.getElementById('three-canvas'),
    antialias: true,
    alpha: true
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// Text Geometry Pool (for performance)
const textGeometries = {};
const wordObjects = [];
const clock = new THREE.Clock();

// Load font then create scene
const fontLoader = new THREE.FontLoader();
fontLoader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', initScene);

function initScene(font) {
    // Create initial geometries for each unique word
    CONFIG.wordList.forEach(word => {
        const geometry = new THREE.TextGeometry(word, {
            font: font,
            size: 1,
            height: 0.1,
            curveSegments: 4, // Lower = more glitchy
            bevelEnabled: false
        });
        geometry.computeBoundingBox();
        textGeometries[word] = geometry;
    });
    
    // Create word instances
    for (let i = 0; i < CONFIG.totalWords; i++) {
        const word = CONFIG.wordList[Math.floor(Math.random() * CONFIG.wordList.length)];
        const geometry = textGeometries[word];
        
        // Material
        const material = new THREE.MeshBasicMaterial({
            color: CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)],
            transparent: true,
            opacity: 0.6 + Math.random() * 0.4
        });
        
        // Mesh
        const mesh = new THREE.Mesh(geometry, material);
        
        // Random position
        mesh.position.set(
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * 100,
            (Math.random() - 0.5) * CONFIG.depth
        );
        
        // Random scale
        const scale = CONFIG.sizeRange[0] + Math.random() * (CONFIG.sizeRange[1] - CONFIG.sizeRange[0]);
        mesh.scale.set(scale, scale, scale);
        
        // Store animation properties
        mesh.userData = {
            speed: CONFIG.speedRange[0] + Math.random() * (CONFIG.speedRange[1] - CONFIG.speedRange[0]),
            direction: new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.1,
                (Math.random() - 0.5) * 0.05
            ),
            rotationSpeed: new THREE.Vector3(
                (Math.random() - 0.5) * CONFIG.rotationSpeed,
                (Math.random() - 0.5) * CONFIG.rotationSpeed,
                (Math.random() - 0.5) * CONFIG.rotationSpeed
            ),
            bounds: 50, // Screen bounds
            timeOffset: Math.random() * 100
        };
        
        scene.add(mesh);
        wordObjects.push(mesh);
    }
    
    // Lighting (minimal, we're using BasicMaterial)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambientLight);
    
    // Add some directional light for depth
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);
    
    // Start animation
    animate();
}

// Animation Loop
function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    const time = clock.elapsedTime;
    
    wordObjects.forEach(mesh => {
        const data = mesh.userData;
        
        // Animated movement with sine waves for organic motion
        const waveX = Math.sin(time * 0.5 + data.timeOffset) * 0.5;
        const waveY = Math.cos(time * 0.3 + data.timeOffset) * 0.5;
        
        mesh.position.x += data.direction.x * data.speed + waveX * 0.05;
        mesh.position.y += data.direction.y * data.speed + waveY * 0.05;
        mesh.position.z += data.direction.z * data.speed;
        
        // Rotation
        mesh.rotation.x += data.rotationSpeed.x * delta;
        mesh.rotation.y += data.rotationSpeed.y * delta;
        
        // Screen wrapping
        if (Math.abs(mesh.position.x) > data.bounds) {
            mesh.position.x = -Math.sign(mesh.position.x) * data.bounds * 0.9;
        }
        if (Math.abs(mesh.position.y) > data.bounds) {
            mesh.position.y = -Math.sign(mesh.position.y) * data.bounds * 0.9;
        }
        if (Math.abs(mesh.position.z) > CONFIG.depth / 2) {
            mesh.position.z = -Math.sign(mesh.position.z) * (CONFIG.depth / 2) * 0.9;
        }
        
        // Pulsing opacity
        mesh.material.opacity = 0.5 + 0.3 * Math.sin(time * 0.8 + data.timeOffset);
    });
    
    // Subtle camera movement
    camera.position.x = Math.sin(time * 0.1) * 3;
    camera.position.y = Math.cos(time * 0.07) * 2;
    camera.lookAt(0, 0, 0);
    
    renderer.render(scene, camera);
}

// Handle Resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Optional: Interactive cursor effect
const mouse = new THREE.Vector2();
window.addEventListener('mousemove', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // Make words react to cursor
    wordObjects.forEach(mesh => {
        const dx = mesh.position.x - mouse.x * 50;
        const dy = mesh.position.y - mouse.y * 30;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 20) {
            mesh.position.z += (10 - distance) * 0.1;
            mesh.material.color.setHex(0xff003c);
        }
    });
});

// POST-PROCESSING: RGB Shift Glitch
function addPostProcessing() {
    // Shader for RGB split effect
    const rgbShiftShader = {
        uniforms: {
            tDiffuse: { value: null },
            amount: { value: 0.003 }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float amount;
            varying vec2 vUv;
            
            void main() {
                vec2 uv = vUv;
                vec4 cr = texture2D(tDiffuse, uv + vec2(amount, 0.0));
                vec4 cg = texture2D(tDiffuse, uv);
                vec4 cb = texture2D(tDiffuse, uv - vec2(amount, 0.0));
                gl_FragColor = vec4(cr.r, cg.g, cb.b, 1.0);
            }
        `
    };
    
    // Create render target
    const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);
    const rgbShiftPass = new THREE.ShaderPass(rgbShiftShader);
    
    // Add to animation loop
    const originalRender = renderer.render;
    renderer.render = function(scene, camera) {
        renderer.setRenderTarget(renderTarget);
        originalRender.call(renderer, scene, camera);
        
        renderer.setRenderTarget(null);
        rgbShiftPass.render(renderer, null, renderTarget);
    };
}
</script>
</body>
</html>
