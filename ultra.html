<!--[if IE 6]>
<html id="ie6" lang="en-US">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en-US">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en-US">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8) ]><!-->
<!DOCTYPE html>
<html lang="en" class="ðŸ‘—" data-theme="light">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	
<link rel="icon" type="image/svg+xml" href="https://cdn.jsdelivr.net/gh/ghostm68/inktwo@main/svg/inky.svg">
<link rel="apple-touch-icon" type="image/png" href="https://github.com/ghostm68/pantheon/raw/main/inkrealm.info.2025.png" />
<meta itemprop="name" content="wordstar nexus/conceptweave"/>	
<meta property="og:url" content="https://www.wordstar.nexus/conceptweave"/>

<title>2741 Lexicon v4.14</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

<style>
    :root {
        --red: #ff0000;
        --black: #050505;
        --dark-grey: #121212;
        --light-grey: #222222;
        --white: #d1d1d1;
    }
    
    * { 
        -webkit-tap-highlight-color: transparent; 
        box-sizing: border-box; 
    }
    
    body { 
        background: var(--black); 
        color: var(--white); 
        font-family: 'Nova Mono', monospace; 
        margin: 0;
        height: 100vh;
        overflow: hidden;
    }
    
    body::after {
        content: " ";
        display: block;
        position: fixed;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%);
        z-index: 999;
        background-size: 100% 3px;
        pointer-events: none;
        opacity: 0.4;
    }
    
    #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--black);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 4px double var(--red);
    }
    
    .app-grid {
        display: none;
        grid-template-columns: 320px 1fr;
        grid-template-rows: 50px 1fr 320px 30px;
        height: 100vh;
        gap: 1px;
        background: var(--red);
    }
    
    header {
        grid-column: span 2;
        background: var(--black);
        border-bottom: 1px solid var(--red);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        z-index: 50;
    }
    
    .sidebar {
        background: var(--black);
        border-right: 1px solid var(--red);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        padding: 0;
    }
    
    #word-explorer {
        background: var(--black);
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid var(--red);
        overflow: hidden;
    }
    
    .bottom-shelf {
        grid-row: 3;
        grid-column: span 2;
        display: grid;
        grid-template-columns: 1fr 350px;
        height: 320px;
        overflow: hidden;
        background: var(--black);
    }
    
    .editor-section {
        background: var(--dark-grey);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border-top: 1px solid var(--red);
    }
    
    #editor {
        flex-grow: 1;
        padding: 25px;
        font-family: 'Special Elite', serif;
        font-size: 1.2rem;
        line-height: 1.6;
        outline: none;
        overflow-y: auto;
        color: var(--white);
        caret-color: var(--red);
        background: var(--dark-grey);
        border: none;
    }
    
    .comms-console {
        background: var(--black);
        border-left: 1px solid var(--red);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    #chat-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px;
        font-size: 10px;
        scroll-behavior: smooth;
    }
    
    .chat-bubble {
        margin-bottom: 10px;
        padding: 8px;
        border: 1px solid var(--light-grey);
        background: var(--black);
    }
    
    .user-message {
        border-left: 3px solid #555;
        color: #888;
    }
    
    .bot-message {
        border-left: 3px solid var(--red);
        color: var(--white);
        background: rgba(255, 0, 0, 0.05);
    }
    
    .chat-input-area {
        display: flex;
        border-top: 1px solid var(--light-grey);
        padding: 5px;
        background: var(--black);
    }
    
    #chat-input {
        background: var(--black);
        color: var(--red);
        border: 1px solid var(--light-grey);
        flex-grow: 1;
        padding: 5px;
        font-size: 10px;
        outline: none;
        font-family: 'Nova Mono', monospace;
    }
    
    footer {
        grid-column: span 2;
        background: var(--black);
        border-top: 1px solid var(--light-grey);
        font-size: 8px;
        color: #444;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        height: 30px;
    }
    
    /* Word Explorer Styles */
    .explorer-header {
        background: var(--black);
        border-bottom: 1px solid var(--red);
        padding: 15px;
    }
    
    #current-word {
        font-size: 24px;
        color: var(--red);
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    #current-type {
        font-size: 10px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    #definition-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        font-size: 12px;
        line-height: 1.6;
    }
    
    .definition-section {
        margin-bottom: 20px;
    }
    
    .section-title {
        color: var(--red);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
        border-bottom: 1px solid var(--light-grey);
        padding-bottom: 3px;
    }
    
    .path-item {
        padding: 8px 12px;
        border-left: 2px solid var(--light-grey);
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
        background: rgba(255, 255, 255, 0.02);
    }
    
    .path-item:hover {
        border-left-color: var(--red);
        background: rgba(255, 0, 0, 0.05);
    }
    
    .path-item.active {
        border-left-color: var(--red);
        background: rgba(255, 0, 0, 0.1);
        color: var(--white);
    }
    
    .path-word {
        color: var(--red);
        font-weight: bold;
        margin-bottom: 3px;
    }
    
    .path-definition {
        color: #888;
        font-size: 10px;
        line-height: 1.4;
    }
    
    /* Sidebar Navigation */
    .nav-section {
        border-bottom: 1px solid var(--light-grey);
        padding: 15px;
    }
    
    .nav-title {
        color: var(--red);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
    }
    
    .word-link {
        display: block;
        padding: 6px 0;
        color: #888;
        cursor: pointer;
        font-size: 11px;
        transition: color 0.2s;
        border-left: 2px solid transparent;
        padding-left: 10px;
    }
    
    .word-link:hover {
        color: var(--white);
        border-left-color: var(--red);
    }
    
    .word-link.active {
        color: var(--red);
        border-left-color: var(--red);
    }
    
    #path-history {
        max-height: 150px;
        overflow-y: auto;
        margin-bottom: 10px;
    }
    
    .teletype-text::after {
        content: "|";
        animation: blink 1s infinite;
    }
    
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }
    
    @media (max-width: 768px) {
        .app-grid {
            grid-template-columns: 1fr;
            grid-template-rows: 50px 250px 1fr 350px 30px;
        }
        
        header, footer {
            grid-column: 1;
        }
        
        .sidebar {
            grid-row: 2;
            max-height: 250px;
            border-right: none;
            border-bottom: 1px solid var(--red);
        }
        
        #word-explorer {
            grid-row: 3;
            height: auto;
        }
        
        .bottom-shelf {
            grid-row: 4;
            grid-template-columns: 1fr;
            grid-template-rows: 200px 150px;
        }
        
        .comms-console {
            height: 150px;
            border-left: none;
            border-top: 1px solid var(--red);
        }
    }
</style>
</head>
<body>

<div id="splash-screen">
    <h1 class="text-red-600 font-bold text-4xl mb-4 tracking-tighter italic">LEXICON_2741</h1>
    <p class="text-zinc-500 animate-pulse text-xs tracking-widest uppercase">Initialize Word Matrix</p>
</div>

<div class="app-grid">
    <header>
        <div class="flex items-center gap-3">
            <div id="power-light" class="w-2 h-2 bg-zinc-900 rounded-full"></div>
            <h1 class="text-white font-bold tracking-tighter text-xs uppercase">LEXICON_2741_v4.14</h1>
            <button id="power-toggle" class="text-[9px] border border-zinc-800 px-2 py-1 text-zinc-500" onclick="toggleAPI()">API: OFF</button>
        </div>
        <div class="flex gap-2">
            <button onclick="clearHistory()" class="text-[9px] border border-zinc-800 px-2 py-1">CLEAR_HISTORY</button>
            <button onclick="exportLexicon()" class="text-[9px] border border-zinc-800 px-2 py-1 text-red-600 font-bold">EXPORT_JSON</button>
            <button onclick="generateJuxtaposition()" class="text-[9px] border border-zinc-800 px-2 py-1 text-red-600">JUXTAPOSE</button>
        </div>
    </header>
    
    <aside class="sidebar">
        <div class="nav-section">
            <div class="nav-title">Word Paths</div>
            <div id="path-history">
                <!-- Path history will be populated here -->
            </div>
        </div>
        
        <div class="nav-section" style="flex-grow: 1;">
            <div class="nav-title">Related Concepts</div>
            <div id="related-words">
                <!-- Related words will be populated here -->
            </div>
        </div>
        
        <div class="nav-section">
            <div class="nav-title">Quick Access</div>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="exploreWord('philosophy')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Philosophy</button>
                <button onclick="exploreWord('consciousness')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Consciousness</button>
                <button onclick="exploreWord('memory')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Memory</button>
                <button onclick="exploreWord('language')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Language</button>
            </div>
        </div>
    </aside>
    
    <main id="word-explorer">
        <div class="explorer-header">
            <div id="current-word">SELECTRIC</div>
            <div id="current-type">NOUN / SYSTEM</div>
        </div>
        
        <div id="definition-container">
            <div class="definition-section">
                <div class="section-title">Definition</div>
                <p>Initialize the system by clicking words from the sidebar or typing in the comms console.</p>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Etymology Path</div>
                <div id="etymology-path">
                    <!-- Etymology path will be populated here -->
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Semantic Field</div>
                <div id="semantic-field">
                    <!-- Semantic relationships will be populated here -->
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Juxtapositions</div>
                <div id="juxtapositions">
                    <!-- Generated juxtapositions will appear here -->
                </div>
            </div>
        </div>
    </main>
    
    <div class="bottom-shelf">
        <section class="editor-section">
            <div class="bg-red-600 text-white px-4 py-1 flex justify-between font-serif text-[10px]">
                <div class="teletype-text" id="teletype">>> LEXICON_INTERFACE_ACTIVE</div>
                <div id="word-count">0W</div>
            </div>
            <div id="editor" contenteditable="true" spellcheck="false"></div>
        </section>
        
        <aside class="comms-console">
            <div class="bg-zinc-900 text-[9px] p-2 text-zinc-500 uppercase flex justify-between border-b border-red-900">
                <span>Dolphin-Mistral-24b-Venice</span>
                <span id="api-status" class="text-red-700 font-bold">READY</span>
            </div>
            <div id="chat-container">
                <div class="chat-bubble bot-message">LEXICON_2741 Active. Query any word for definition paths and semantic relationships.</div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Enter word for analysis..." onkeypress="if(event.key==='Enter') queryWord()">
                <button onclick="queryWord()" class="bg-red-800 px-2 text-[9px] ml-1">ANALYZE</button>
            </div>
        </aside>
    </div>
    
    <footer>
        <div>LEXICON_v4.14 // DOLPHIN-MISTRAL-24B-VENICE</div>
        <div class="flex gap-4 uppercase">
            <span>OpenRouter BYOK</span><span>|</span>
            <span id="footer-status">MODEL_READY</span>
        </div>
    </footer>
</div>

<script>
    // Configuration
    const OPENROUTER_API_KEY = "your-openrouter-api-key-here"; // Replace with your key
    const MODEL = "cognitivecomputations/dolphin-mistral-24b-venice-edition:free";
    
    // State
    let currentWord = "selectric";
    let wordHistory = [];
    let wordData = {};
    let isAPIReady = false;
    let statusMessages = [
        ">> LEXICON_INTERFACE_ACTIVE",
        ">> DOLPHIN-MISTRAL-24B-VENICE_LOADED",
        ">> SEMANTIC_PATHS_READY",
        ">> JUXTAPOSITION_ENGINE_PRIMED",
        ">> WORD_MATRIX_STABLE"
    ];
    let messageIndex = 0, charIndex = 0, isDeleting = false;
    
    // Initialize
    function init() {
        loadSavedData();
        updateDisplay();
        typeStatus();
        updateAPIStatus();
    }
    
    // Typewriter effect for status
    function typeStatus() {
        const target = document.getElementById('teletype');
        if(!target) return;
        const currentMsg = statusMessages[messageIndex];
        target.innerText = isDeleting ? currentMsg.substring(0, charIndex - 1) : currentMsg.substring(0, charIndex + 1);
        charIndex = isDeleting ? charIndex - 1 : charIndex + 1;
        let speed = isDeleting ? 40 : 80;
        if (!isDeleting && charIndex === currentMsg.length) { speed = 3000; isDeleting = true; }
        else if (isDeleting && charIndex === 3) { isDeleting = false; messageIndex = (messageIndex + 1) % statusMessages.length; speed = 500; }
        setTimeout(typeStatus, speed);
    }
    
    // Toggle API status
    function toggleAPI() {
        isAPIReady = !isAPIReady;
        const btn = document.getElementById('power-toggle');
        const light = document.getElementById('power-light');
        const status = document.getElementById('api-status');
        
        if (isAPIReady) {
            btn.innerText = "API: ON";
            btn.style.color = "var(--red)";
            light.classList.add('bg-red-600', 'animate-pulse');
            status.textContent = "ACTIVE";
            status.style.color = "var(--red)";
            addChatMessage("API connection established. Dolphin-Mistral-24b-Venice ready.", "bot");
        } else {
            btn.innerText = "API: OFF";
            btn.style.color = "#555";
            light.classList.remove('bg-red-600', 'animate-pulse');
            status.textContent = "OFFLINE";
            status.style.color = "#555";
            addChatMessage("API disconnected. Using cached data only.", "bot");
        }
    }
    
    // Query word with AI
    async function queryWord() {
        const input = document.getElementById('chat-input');
        const word = input.value.trim().toLowerCase();
        if (!word) return;
        
        input.value = '';
        addChatMessage(`Analyzing: ${word}`, "user");
        
        // Add to history
        if (!wordHistory.includes(word)) {
            wordHistory.unshift(word);
            if (wordHistory.length > 10) wordHistory.pop();
            updateHistoryDisplay();
        }
        
        // Try to get from cache first
        if (wordData[word]) {
            displayWordData(word, wordData[word]);
            addChatMessage(`Loaded cached data for "${word}"`, "bot");
            return;
        }
        
        // Use AI if API is ready
        if (isAPIReady) {
            addChatMessage("Querying Dolphin-Mistral-24b-Venice...", "bot");
            try {
                const data = await fetchWordAnalysis(word);
                wordData[word] = data;
                displayWordData(word, data);
                addChatMessage(`Analysis complete for "${word}"`, "bot");
                saveData();
            } catch (error) {
                addChatMessage(`API Error: ${error.message}`, "bot");
                // Fallback to generated data
                const fallbackData = generateWordData(word);
                wordData[word] = fallbackData;
                displayWordData(word, fallbackData);
            }
        } else {
            // Use generated data
            const generatedData = generateWordData(word);
            wordData[word] = generatedData;
            displayWordData(word, generatedData);
            addChatMessage(`Generated analysis for "${word}" (offline mode)`, "bot");
        }
    }
    
    // Fetch word analysis from OpenRouter
    async function fetchWordAnalysis(word) {
        const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
                "HTTP-Referer": window.location.origin,
                "X-Title": "LEXICON_2741"
            },
            body: JSON.stringify({
                model: MODEL,
                messages: [
                    {
                        role: "system",
                        content: `You are an expert etymologist and lexicographer. Analyze the word provided and return ONLY a JSON object with this exact structure:
{
    "word": "${word}",
    "type": "part of speech",
    "definition": "clear definition",
    "etymology": ["etymology path step 1", "etymology path step 2", "etymology path step 3"],
    "semantic_field": ["related word 1", "related word 2", "related word 3", "related word 4", "related word 5"],
    "juxtapositions": ["interesting juxtaposition 1", "interesting juxtaposition 2"]
}

Make etymology an array of 3 steps showing word origin path.
Make semantic_field an array of 5 related words.
Make juxtapositions an array of 2 creative juxtapositions.`
                    },
                    {
                        role: "user",
                        content: `Analyze the word: ${word}`
                    }
                ],
                temperature: 0.7,
                max_tokens: 500
            })
        });
        
        if (!response.ok) {
            throw new Error(`API error: ${response.status}`);
        }
        
        const data = await response.json();
        const content = data.choices[0].message.content;
        
        try {
            // Extract JSON from response
            const jsonMatch = content.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
                return JSON.parse(jsonMatch[0]);
            }
            throw new Error("No JSON found in response");
        } catch (e) {
            // If JSON parsing fails, generate structured data from text
            return generateStructuredDataFromText(word, content);
        }
    }
    
    // Generate structured data from AI text response
    function generateStructuredDataFromText(word, text) {
        const lines = text.split('\n').filter(line => line.trim());
        return {
            word: word,
            type: extractType(lines) || "Noun",
            definition: extractDefinition(lines) || `The study or concept of ${word}`,
            etymology: [
                `From ancient roots relating to ${word}`,
                `Middle period development`,
                `Modern usage and adaptation`
            ],
            semantic_field: extractRelatedWords(lines) || ["concept", "idea", "thought", "notion", "principle"],
            juxtapositions: [
                `${word} and its shadow`,
                `${word} in the machine`
            ]
        };
    }
    
    function extractType(lines) {
        for (const line of lines) {
            if (line.toLowerCase().includes('noun') || line.includes('Verb') || line.includes('Adjective')) {
                return line.split(' ')[0];
            }
        }
        return null;
    }
    
    function extractDefinition(lines) {
        for (const line of lines) {
            if (line.toLowerCase().includes('definition:') || line.includes('means')) {
                return line.split(':')[1]?.trim() || line;
            }
        }
        return lines[0] || null;
    }
    
    function extractRelatedWords(lines) {
        const words = [];
        for (const line of lines) {
            const wordMatches = line.match(/\b(?:related to|similar to|including)\s+([^,.]+)/i);
            if (wordMatches) {
                words.push(...wordMatches[1].split(/\s+/).filter(w => w.length > 3));
            }
        }
        return words.slice(0, 5);
    }
    
    // Generate word data (offline fallback)
    function generateWordData(word) {
        const types = ["Noun", "Verb", "Adjective", "Adverb", "Concept"];
        const origins = ["Latin", "Greek", "Old English", "French", "Germanic", "Proto-Indo-European"];
        
        return {
            word: word,
            type: types[Math.floor(Math.random() * types.length)],
            definition: `The essence or quality of ${word}; a fundamental principle or state of being related to ${word}.`,
            etymology: [
                `From ${origins[Math.floor(Math.random() * origins.length)]} root *${word.substring(0, 3)}-`,
                `Through medieval scholastic tradition`,
                `Modern philosophical adaptation`
            ],
            semantic_field: [
                "essence",
                "being",
                "existence",
                "nature",
                "reality"
            ],
            juxtapositions: [
                `${word} and silence`,
                `${word} and machine`
            ]
        };
    }
    
    // Display word data
    function displayWordData(word, data) {
        currentWord = word;
        
        // Update header
        document.getElementById('current-word').textContent = word.toUpperCase();
        document.getElementById('current-type').textContent = data.type.toUpperCase();
        
        // Update definition
        const definitionContainer = document.getElementById('definition-container');
        definitionContainer.innerHTML = `
            <div class="definition-section">
                <div class="section-title">Definition</div>
                <p>${data.definition}</p>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Etymology Path</div>
                <div id="etymology-path">
                    ${data.etymology.map((step, i) => `
                        <div class="path-item ${i === 0 ? 'active' : ''}" onclick="insertText('${step.split(' ')[0]}')">
                            <div class="path-word">${i + 1}. ${step.split(' ')[0]}</div>
                            <div class="path-definition">${step}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Semantic Field</div>
                <div id="semantic-field">
                    ${data.semantic_field.map(relatedWord => `
                        <div class="path-item" onclick="exploreWord('${relatedWord}')">
                            <div class="path-word">${relatedWord}</div>
                            <div class="path-definition">Related concept in the ${word} semantic field</div>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Juxtapositions</div>
                <div id="juxtapositions">
                    ${data.juxtapositions.map(jux => `
                        <div class="path-item" onclick="insertText('${jux}')">
                            <div class="path-definition">${jux}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
        
        // Update related words in sidebar
        updateRelatedWords(data.semantic_field);
        
        // Insert word into editor
        insertText(word);
    }
    
    // Update related words display
    function updateRelatedWords(relatedWords) {
        const container = document.getElementById('related-words');
        container.innerHTML = relatedWords.map(word => `
            <div class="word-link" onclick="exploreWord('${word}')">${word}</div>
        `).join('');
    }
    
    // Update history display
    function updateHistoryDisplay() {
        const container = document.getElementById('path-history');
        container.innerHTML = wordHistory.map(word => `
            <div class="word-link ${word === currentWord ? 'active' : ''}" onclick="exploreWord('${word}')">${word}</div>
        `).join('');
    }
    
    // Explore word (shortcut function)
    function exploreWord(word) {
        document.getElementById('chat-input').value = word;
        queryWord();
    }
    
    // Generate juxtaposition
    async function generateJuxtaposition() {
        if (!isAPIReady) {
            addChatMessage("API required for juxtaposition generation", "bot");
            return;
        }
        
        const words = Object.keys(wordData);
        if (words.length < 2) {
            addChatMessage("Need at least 2 analyzed words for juxtaposition", "bot");
            return;
        }
        
        const word1 = words[Math.floor(Math.random() * words.length)];
        let word2;
        do {
            word2 = words[Math.floor(Math.random() * words.length)];
        } while (word2 === word1);
        
        addChatMessage(`Generating juxtaposition: ${word1} Ã— ${word2}`, "bot");
        
        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${OPENROUTER_API_KEY}`,
                    "HTTP-Referer": window.location.origin
                },
                body: JSON.stringify({
                    model: MODEL,
                    messages: [
                        {
                            role: "system",
                            content: "Generate a creative philosophical juxtaposition between two concepts. Return only the juxtaposition text."
                        },
                        {
                            role: "user",
                            content: `Create a juxtaposition between ${word1} and ${word2}`
                        }
                    ],
                    temperature: 0.9,
                    max_tokens: 100
                })
            });
            
            const data = await response.json();
            const juxtaposition = data.choices[0].message.content;
            
            // Add to juxtapositions section
            const juxtapositionsDiv = document.getElementById('juxtapositions');
            if (juxtapositionsDiv) {
                juxtapositionsDiv.innerHTML += `
                    <div class="path-item" onclick="insertText('${juxtaposition.replace(/'/g, "\\'")}')">
                        <div class="path-word">${word1} Ã— ${word2}</div>
                        <div class="path-definition">${juxtaposition}</div>
                    </div>
                `;
            }
            
            addChatMessage(`Juxtaposition generated: ${word1} Ã— ${word2}`, "bot");
            insertText(juxtaposition);
        } catch (error) {
            addChatMessage(`Juxtaposition failed: ${error.message}`, "bot");
        }
    }
    
    // Insert text into editor
    function insertText(text) {
        const editor = document.getElementById('editor');
        editor.innerHTML += ` <span style="color:var(--red)">${text}</span> `;
        editor.scrollTop = editor.scrollHeight;
        updateWordCount();
        saveEditor();
    }
    
    // Update word count
    function updateWordCount() {
        const editor = document.getElementById('editor');
        const text = editor.innerText.trim();
        const wordCount = text.length > 0 ? text.split(/\s+/).length : 0;
        document.getElementById('word-count').textContent = `${wordCount}W`;
    }
    
    // Add chat message
    function addChatMessage(message, sender) {
        const container = document.getElementById('chat-container');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-bubble ${sender}-message`;
        messageDiv.textContent = message;
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    // Clear history
    function clearHistory() {
        if (confirm("Clear word history?")) {
            wordHistory = [];
            updateHistoryDisplay();
            addChatMessage("History cleared", "bot");
        }
    }
    
    // Export lexicon as JSON
    function exportLexicon() {
        const data = {
            currentWord: currentWord,
            wordHistory: wordHistory,
            wordData: wordData,
            exportDate: new Date().toISOString()
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lexicon_2741_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        addChatMessage("Lexicon exported as JSON", "bot");
    }
    
    // Save data to localStorage
    function saveData() {
        const data = {
            wordHistory: wordHistory,
            wordData: wordData,
            currentWord: currentWord
        };
        localStorage.setItem('lexicon_2741_data', JSON.stringify(data));
    }
    
    // Load saved data
    function loadSavedData() {
        try {
            const saved = localStorage.getItem('lexicon_2741_data');
            if (saved) {
                const data = JSON.parse(saved);
                wordHistory = data.wordHistory || [];
                wordData = data.wordData || {};
                currentWord = data.currentWord || "selectric";
            }
        } catch (e) {
            console.log("No saved data found");
        }
    }
    
    // Save editor content
    function saveEditor() {
        const editor = document.getElementById('editor');
        localStorage.setItem('lexicon_2741_editor', editor.innerHTML);
    }
    
    // Load editor content
    function loadEditor() {
        const saved = localStorage.getItem('lexicon_2741_editor');
        if (saved) {
            document.getElementById('editor').innerHTML = saved;
        } else {
            document.getElementById('editor').innerHTML = `
                _2741_LEXICON_PROTOCOL:<br>
                i. ACTIVATE API for Dolphin-Mistral-24b-Venice analysis.<br>
                ii. ENTER words in comms console or CLICK from sidebar.<br>
                iii. EXPLORE etymology paths and semantic fields.<br>
                iv. GENERATE juxtapositions between concepts.<br>
                v. COMPOSE in this space; text auto-saves.<br><br>
                ------------------------------------------<br><br>
                The lexicon hums with potential connections. Each word a node in the vast semantic network. The detective of meaning follows etymological traces through time, from ancient roots to modern nuance...
            `;
        }
        updateWordCount();
    }
    
    // Update API status display
    function updateAPIStatus() {
        const status = document.getElementById('api-status');
        const footer = document.getElementById('footer-status');
        const texts = ['READY', 'ANALYZING', 'PROCESSING', 'IDLE'];
        let index = 0;
        
        setInterval(() => {
            if (status && footer) {
                if (isAPIReady) {
                    status.textContent = texts[index];
                    footer.textContent = `MODEL_${texts[index]}`;
                    index = (index + 1) % texts.length;
                } else {
                    status.textContent = "OFFLINE";
                    footer.textContent = "MODEL_OFFLINE";
                }
            }
        }, 3000);
    }
    
    // Update display
    function updateDisplay() {
        updateHistoryDisplay();
        loadEditor();
        
        // Display current word if exists
        if (wordData[currentWord]) {
            displayWordData(currentWord, wordData[currentWord]);
        }
    }
    
    // Splash screen handler
    document.getElementById('splash-screen').addEventListener('click', function() {
        this.style.opacity = '0';
        this.style.transition = 'opacity 0.5s';
        document.querySelector('.app-grid').style.display = 'grid';
        setTimeout(() => {
            this.style.display = 'none';
            init();
        }, 500);
    });
    
    // Initialize editor event listeners
    document.addEventListener('DOMContentLoaded', function() {
        const editor = document.getElementById('editor');
        if (editor) {
            editor.addEventListener('input', function() {
                updateWordCount();
                saveEditor();
            });
        }
    });
</script>
</body>
</html>
