<!--[if IE 6]>
<html id="ie6" lang="en-US">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en-US">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en-US">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8) ]><!-->
<!DOCTYPE html>
<html lang="en" class="üëó" data-theme="light">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	
<link rel="icon" type="image/svg+xml" href="https://cdn.jsdelivr.net/gh/ghostm68/inktwo@main/svg/inky.svg">
<link rel="apple-touch-icon" type="image/png" href="https://github.com/ghostm68/pantheon/raw/main/inkrealm.info.2025.png" />
<meta itemprop="name" content="wordstar nexus/conceptweave"/>	
<meta property="og:url" content="https://www.wordstar.nexus/conceptweave"/>

<title>2741 Lexicon v4.14</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

<style>
    :root {
        --red: #ff0000;
        --black: #050505;
        --dark-grey: #121212;
        --light-grey: #222222;
        --white: #d1d1d1;
    }
    
    * { 
        -webkit-tap-highlight-color: transparent; 
        box-sizing: border-box; 
    }
    
    body { 
        background: var(--black); 
        color: var(--white); 
        font-family: 'Nova Mono', monospace; 
        margin: 0;
        height: 100vh;
        overflow: hidden;
    }
    
    body::after {
        content: " ";
        display: block;
        position: fixed;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%);
        z-index: 999;
        background-size: 100% 3px;
        pointer-events: none;
        opacity: 0.4;
    }
    
    #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--black);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 4px double var(--red);
    }
    
    .app-grid {
        display: none;
        grid-template-columns: 320px 1fr;
        grid-template-rows: 50px 1fr 320px 30px;
        height: 100vh;
        gap: 1px;
        background: var(--red);
    }
    
    header {
        grid-column: span 2;
        background: var(--black);
        border-bottom: 1px solid var(--red);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        z-index: 50;
    }
    
    .sidebar {
        background: var(--black);
        border-right: 1px solid var(--red);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        padding: 0;
    }
    
    #word-explorer {
        background: var(--black);
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid var(--red);
        overflow: hidden;
    }
    
    .bottom-shelf {
        grid-row: 3;
        grid-column: span 2;
        display: grid;
        grid-template-columns: 1fr 350px;
        height: 320px;
        overflow: hidden;
        background: var(--black);
    }
    
    .editor-section {
        background: var(--dark-grey);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border-top: 1px solid var(--red);
    }
    
    #editor {
        flex-grow: 1;
        padding: 25px;
        font-family: 'Special Elite', serif;
        font-size: 1.2rem;
        line-height: 1.6;
        outline: none;
        overflow-y: auto;
        color: var(--white);
        caret-color: var(--red);
        background: var(--dark-grey);
        border: none;
    }
    
    .comms-console {
        background: var(--black);
        border-left: 1px solid var(--red);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    #chat-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px;
        font-size: 10px;
        scroll-behavior: smooth;
    }
    
    .chat-bubble {
        margin-bottom: 10px;
        padding: 8px;
        border: 1px solid var(--light-grey);
        background: var(--black);
    }
    
    .user-message {
        border-left: 3px solid #555;
        color: #888;
    }
    
    .bot-message {
        border-left: 3px solid var(--red);
        color: var(--white);
        background: rgba(255, 0, 0, 0.05);
    }
    
    .chat-input-area {
        display: flex;
        border-top: 1px solid var(--light-grey);
        padding: 5px;
        background: var(--black);
    }
    
    #chat-input {
        background: var(--black);
        color: var(--red);
        border: 1px solid var(--light-grey);
        flex-grow: 1;
        padding: 5px;
        font-size: 10px;
        outline: none;
        font-family: 'Nova Mono', monospace;
    }
    
    footer {
        grid-column: span 2;
        background: var(--black);
        border-top: 1px solid var(--light-grey);
        font-size: 8px;
        color: #444;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        height: 30px;
    }
    
    /* Word Explorer Styles */
    .explorer-header {
        background: var(--black);
        border-bottom: 1px solid var(--red);
        padding: 15px;
    }
    
    #current-word {
        font-size: 24px;
        color: var(--red);
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    #current-type {
        font-size: 10px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    #definition-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        font-size: 12px;
        line-height: 1.6;
    }
    
    .definition-section {
        margin-bottom: 20px;
    }
    
    .section-title {
        color: var(--red);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
        border-bottom: 1px solid var(--light-grey);
        padding-bottom: 3px;
    }
    
    .path-item {
        padding: 8px 12px;
        border-left: 2px solid var(--light-grey);
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
        background: rgba(255, 255, 255, 0.02);
    }
    
    .path-item:hover {
        border-left-color: var(--red);
        background: rgba(255, 0, 0, 0.05);
    }
    
    .path-item.active {
        border-left-color: var(--red);
        background: rgba(255, 0, 0, 0.1);
        color: var(--white);
    }
    
    .path-word {
        color: var(--red);
        font-weight: bold;
        margin-bottom: 3px;
    }
    
    .path-definition {
        color: #888;
        font-size: 10px;
        line-height: 1.4;
    }
    
    /* Sidebar Navigation */
    .nav-section {
        border-bottom: 1px solid var(--light-grey);
        padding: 15px;
    }
    
    .nav-title {
        color: var(--red);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
    }
    
    .word-link {
        display: block;
        padding: 6px 0;
        color: #888;
        cursor: pointer;
        font-size: 11px;
        transition: color 0.2s;
        border-left: 2px solid transparent;
        padding-left: 10px;
    }
    
    .word-link:hover {
        color: var(--white);
        border-left-color: var(--red);
    }
    
    .word-link.active {
        color: var(--red);
        border-left-color: var(--red);
    }
    
    #path-history {
        max-height: 150px;
        overflow-y: auto;
        margin-bottom: 10px;
    }
    
    /* Search Box */
    .search-container {
        padding: 15px;
        background: rgba(255, 0, 0, 0.05);
        border-bottom: 1px solid var(--light-grey);
    }
    
    .search-box {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
    }
    
    .search-box input {
        flex-grow: 1;
        background: var(--black);
        color: var(--white);
        border: 1px solid var(--light-grey);
        padding: 8px;
        font-size: 11px;
        font-family: 'Nova Mono', monospace;
    }
    
    .search-box button {
        background: var(--light-grey);
        color: var(--white);
        border: none;
        padding: 0 15px;
        font-size: 11px;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .search-box button:hover {
        background: var(--red);
    }
    
    /* API Key Input */
    .api-key-container {
        padding: 15px;
        background: rgba(255, 0, 0, 0.05);
        border-bottom: 1px solid var(--light-grey);
    }
    
    .api-key-input {
        display: flex;
        gap: 5px;
        margin-bottom: 5px;
    }
    
    .api-key-input input {
        flex-grow: 1;
        background: var(--black);
        color: var(--red);
        border: 1px solid var(--light-grey);
        padding: 8px;
        font-size: 11px;
        font-family: 'Nova Mono', monospace;
    }
    
    .api-key-input button {
        background: var(--light-grey);
        color: var(--white);
        border: none;
        padding: 0 15px;
        font-size: 11px;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .api-key-input button:hover {
        background: var(--red);
    }
    
    .status-message {
        font-size: 9px;
        color: #888;
        padding: 3px 0;
        min-height: 20px;
    }
    
    .status-ok {
        color: #00ff00;
    }
    
    .status-error {
        color: var(--red);
    }
    
    .teletype-text::after {
        content: "|";
        animation: blink 1s infinite;
    }
    
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }
    
    /* Loading animation */
    .loading-dots::after {
        content: '.';
        animation: dots 1.5s steps(5, end) infinite;
    }
    
    @keyframes dots {
        0%, 20% { content: '.'; }
        40% { content: '..'; }
        60% { content: '...'; }
        80%, 100% { content: ''; }
    }
    
    @media (max-width: 768px) {
        .app-grid {
            grid-template-columns: 1fr;
            grid-template-rows: 50px 250px 1fr 350px 30px;
        }
        
        header, footer {
            grid-column: 1;
        }
        
        .sidebar {
            grid-row: 2;
            max-height: 250px;
            border-right: none;
            border-bottom: 1px solid var(--red);
        }
        
        #word-explorer {
            grid-row: 3;
            height: auto;
        }
        
        .bottom-shelf {
            grid-row: 4;
            grid-template-columns: 1fr;
            grid-template-rows: 200px 150px;
        }
        
        .comms-console {
            height: 150px;
            border-left: none;
            border-top: 1px solid var(--red);
        }
    }
</style>
</head>
<body>

<div id="splash-screen">
    <h1 class="text-red-600 font-bold text-4xl mb-4 tracking-tighter italic">LEXICON_2741</h1>
    <p class="text-zinc-500 animate-pulse text-xs tracking-widest uppercase">Initialize Word Matrix</p>
</div>

<div class="app-grid">
    <header>
        <div class="flex items-center gap-3">
            <div id="power-light" class="w-2 h-2 bg-zinc-900 rounded-full"></div>
            <h1 class="text-white font-bold tracking-tighter text-xs uppercase">LEXICON_2741_v4.14</h1>
            <span id="api-status-indicator" class="text-[9px] text-zinc-500">DICTIONARIES: READY</span>
        </div>
        <div class="flex gap-2">
            <button onclick="clearHistory()" class="text-[9px] border border-zinc-800 px-2 py-1">CLEAR_HISTORY</button>
            <button onclick="exportText()" class="text-[9px] border border-zinc-800 px-2 py-1 text-red-600 font-bold">EXTRACT_TEXT</button>
            <button onclick="generateJuxtaposition()" class="text-[9px] border border-zinc-800 px-2 py-1 text-red-600" title="Generate creative word pairing">JUXTAPOSE</button>
        </div>
    </header>
    
    <aside class="sidebar">
        <div class="search-container">
            <div class="nav-title">Word Search</div>
            <div class="search-box">
                <input type="text" id="word-search" placeholder="Enter word..." onkeypress="if(event.key==='Enter') searchWord()">
                <button onclick="searchWord()">SEARCH</button>
            </div>
            <div id="search-status" class="status-message">Free Dictionary APIs + Datamuse</div>
        </div>
        
        <div class="api-key-container">
            <div class="nav-title">OpenRouter API Key (Optional)</div>
            <div class="api-key-input">
                <input type="password" id="apiKey" placeholder="sk-or-v1-...">
                <button id="toggleKey" title="Show/Hide">üëÅ</button>
            </div>
            <div id="key-status" class="status-message">For AI juxtapositions only</div>
        </div>
        
        <div class="nav-section">
            <div class="nav-title">Recent Searches</div>
            <div id="path-history">
                <!-- Recent searches will be populated here -->
            </div>
        </div>
        
        <div class="nav-section" style="flex-grow: 1;">
            <div class="nav-title">Word Relationships (Datamuse)</div>
            <div id="related-words">
                <!-- Related words will be populated here -->
            </div>
        </div>
        
        <div class="nav-section">
            <div class="nav-title">Quick Examples</div>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="searchWord('philosophy')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Philosophy</button>
                <button onclick="searchWord('consciousness')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Consciousness</button>
                <button onclick="searchWord('memory')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Memory</button>
                <button onclick="searchWord('language')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Language</button>
            </div>
        </div>
    </aside>
    
    <main id="word-explorer">
        <div class="explorer-header">
            <div id="current-word">LEXICON</div>
            <div id="current-type">NOUN</div>
        </div>
        
        <div id="definition-container">
            <div class="definition-section">
                <div class="section-title">Definition</div>
                <p id="definition-text">Search for any word to see its definition from multiple free dictionary sources.</p>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Etymology & Word Paths</div>
                <div id="etymology-path">
                    <!-- Etymology will be populated here -->
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Semantic Field & Associations</div>
                <div id="semantic-field">
                    <!-- Semantic relationships will be populated here -->
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Juxtapositions</div>
                <div id="juxtapositions">
                    <div class="path-item">
                        <div class="path-definition">Enter API key and click JUXTAPOSE for AI-generated creative pairings</div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <div class="bottom-shelf">
        <section class="editor-section">
            <div class="bg-red-600 text-white px-4 py-1 flex justify-between font-serif text-[10px]">
                <div class="teletype-text" id="teletype">>> LEXICON_INTERFACE_ACTIVE</div>
                <div id="word-count">0W</div>
            </div>
            <div id="editor" contenteditable="true" spellcheck="false"></div>
        </section>
        
        <aside class="comms-console">
            <div class="bg-zinc-900 text-[9px] p-2 text-zinc-500 uppercase flex justify-between border-b border-red-900">
                <span>Dictionary APIs + Datamuse + AI</span>
                <span id="model-status" class="text-green-500 font-bold">READY</span>
            </div>
            <div id="chat-container">
                <div class="chat-bubble bot-message">Search words for definitions. Enter API key for AI juxtapositions between concepts.</div>
                <div class="chat-bubble bot-message">Using: FreeDictionaryAPI, Datamuse, Wiktionary (public data)</div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Ask about word relationships..." onkeypress="if(event.key==='Enter') askAI()">
                <button onclick="askAI()" class="bg-red-800 px-2 text-[9px] ml-1">ASK_AI</button>
            </div>
        </aside>
    </div>
    
    <footer>
        <div>LEXICON_v4.14 // REAL_DICTIONARIES + AI_JUXTAPOSITIONS</div>
        <div class="flex gap-4 uppercase">
            <span>Free APIs Active</span><span>|</span>
            <span id="footer-status">DICTIONARIES: ONLINE</span>
        </div>
    </footer>
</div>

<script>
    // ==============================================
    // CONFIGURATION
    // ==============================================
    const MODEL = "cognitivecomputations/dolphin-mistral-24b-venice-edition:free";
    
    // ==============================================
    // STATE
    // ==============================================
    let apiKey = '';
    let currentWord = "lexicon";
    let wordHistory = [];
    let cachedDefinitions = {};
    
    // ==============================================
    // INITIALIZATION
    // ==============================================
    window.addEventListener('load', () => {
        const saved = localStorage.getItem('openrouter_api_key');
        if (saved) {
            apiKey = saved;
            document.getElementById('apiKey').value = saved;
            updateKeyStatus('API key loaded from storage', 'ok');
            updateAPIStatus();
        }
        init();
    });
    
    // Toggle key visibility
    document.getElementById('toggleKey').addEventListener('click', () => {
        const input = document.getElementById('apiKey');
        input.type = input.type === 'password' ? 'text' : 'password';
    });
    
    // Save key on change
    document.getElementById('apiKey').addEventListener('change', (e) => {
        const key = e.target.value.trim();
        if (key) {
            apiKey = key;
            localStorage.setItem('openrouter_api_key', key);
            updateKeyStatus('API key saved', 'ok');
            updateAPIStatus();
            addChatMessage("API key validated. AI juxtapositions enabled.", "bot");
        }
    });
    
    // ==============================================
    // MAIN SEARCH FUNCTION (REAL DICTIONARY APIs)
    // ==============================================
    async function searchWord(word = null) {
        const searchInput = document.getElementById('word-search');
        const wordToSearch = word || searchInput.value.trim().toLowerCase();
        
        if (!wordToSearch) {
            updateSearchStatus("Enter a word to search", "info");
            return;
        }
        
        searchInput.value = wordToSearch;
        updateSearchStatus(`Searching dictionaries...`, "info");
        
        // Add to history
        if (!wordHistory.includes(wordToSearch)) {
            wordHistory.unshift(wordToSearch);
            if (wordHistory.length > 10) wordHistory.pop();
            updateHistoryDisplay();
        }
        
        // Show loading state
        showLoadingState(wordToSearch);
        
        try {
            // Try multiple dictionary sources in parallel
            const results = await Promise.allSettled([
                fetchFreeDictionaryAPI(wordToSearch),
                fetchDatamuseRelated(wordToSearch),
                fetchWiktionaryData(wordToSearch)
            ]);
            
            // Process results
            const dictionaryResult = results[0].status === 'fulfilled' ? results[0].value : null;
            const datamuseResult = results[1].status === 'fulfilled' ? results[1].value : null;
            const wiktionaryResult = results[2].status === 'fulfilled' ? results[2].value : null;
            
            // Display combined results
            displayCombinedResults(wordToSearch, {
                dictionary: dictionaryResult,
                datamuse: datamuseResult,
                wiktionary: wiktionaryResult
            });
            
            updateSearchStatus(`Found: ${wordToSearch}`, "ok");
            addChatMessage(`Searched: ${wordToSearch}`, "user");
            
            // Cache the result
            cachedDefinitions[wordToSearch] = {
                dictionary: dictionaryResult,
                datamuse: datamuseResult,
                timestamp: Date.now()
            };
            
        } catch (error) {
            console.error("Search error:", error);
            updateSearchStatus(`Search failed: ${error.message}`, "error");
            showErrorState(wordToSearch, error);
        }
    }
    
    // ==============================================
    // REAL DICTIONARY API FUNCTIONS
    // ==============================================
    
    // 1. Free Dictionary API (https://dictionaryapi.dev/)
    async function fetchFreeDictionaryAPI(word) {
        try {
            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
            if (!response.ok) {
                if (response.status === 404) {
                    return { error: "Word not found in dictionary" };
                }
                throw new Error(`Dictionary API: ${response.status}`);
            }
            const data = await response.json();
            return processFreeDictionaryData(data);
        } catch (error) {
            console.warn("Free Dictionary API failed:", error);
            return null;
        }
    }
    
    function processFreeDictionaryData(data) {
        if (!data || !data[0]) return null;
        
        const entry = data[0];
        const definitions = [];
        const phonetics = entry.phonetic || '';
        
        // Collect all definitions
        entry.meanings?.forEach(meaning => {
            meaning.definitions?.forEach(def => {
                definitions.push({
                    type: meaning.partOfSpeech,
                    definition: def.definition,
                    example: def.example || ''
                });
            });
        });
        
        return {
            source: "Free Dictionary API",
            word: entry.word,
            phonetics: phonetics,
            definitions: definitions,
            audio: entry.phonetics?.find(p => p.audio)?.audio || null
        };
    }
    
    // 2. Datamuse API for word relationships
    async function fetchDatamuseRelated(word) {
        try {
            // Get related words (synonyms, similar meaning)
            const response = await fetch(`https://api.datamuse.com/words?ml=${word}&max=10`);
            if (!response.ok) throw new Error(`Datamuse API: ${response.status}`);
            const related = await response.json();
            
            // Get triggers (words that make you think of this word)
            const triggersResponse = await fetch(`https://api.datamuse.com/words?rel_trg=${word}&max=5`);
            const triggers = triggersResponse.ok ? await triggersResponse.json() : [];
            
            // Get associated words
            const associatedResponse = await fetch(`https://api.datamuse.com/words?rel_jja=${word}&max=5`);
            const associated = associatedResponse.ok ? await associatedResponse.json() : [];
            
            return {
                source: "Datamuse API",
                related: related.slice(0, 8).map(item => item.word),
                triggers: triggers.slice(0, 5).map(item => item.word),
                associated: associated.slice(0, 5).map(item => item.word)
            };
        } catch (error) {
            console.warn("Datamuse API failed:", error);
            return null;
        }
    }
    
    // 3. Wiktionary data (using public API)
    async function fetchWiktionaryData(word) {
        try {
            // Using the Wiktionary REST API
            const response = await fetch(`https://en.wiktionary.org/api/rest_v1/page/definition/${word}`);
            if (!response.ok) {
                if (response.status === 404) return null;
                throw new Error(`Wiktionary API: ${response.status}`);
            }
            const data = await response.json();
            return processWiktionaryData(data);
        } catch (error) {
            console.warn("Wiktionary API failed:", error);
            return null;
        }
    }
    
    function processWiktionaryData(data) {
        if (!data || !data.en) return null;
        
        const etymology = [];
        const definitions = [];
        
        data.en.forEach(section => {
            if (section.etymology) {
                etymology.push(section.etymology);
            }
            section.definitions?.forEach(def => {
                definitions.push({
                    definition: def.definition,
                    examples: def.examples || []
                });
            });
        });
        
        return {
            source: "Wiktionary",
            etymology: etymology,
            definitions: definitions.slice(0, 3) // Limit to 3 definitions
        };
    }
    
    // ==============================================
    // DISPLAY FUNCTIONS
    // ==============================================
    
    function showLoadingState(word) {
        document.getElementById('current-word').textContent = word.toUpperCase();
        document.getElementById('current-type').textContent = "SEARCHING";
        document.getElementById('definition-text').innerHTML = `<span class="loading-dots">Querying dictionaries</span>`;
        
        const container = document.getElementById('definition-container');
        container.innerHTML = `
            <div class="definition-section">
                <div class="section-title">Definition</div>
                <p class="loading-dots">Searching multiple dictionary sources</p>
            </div>
            <div class="definition-section">
                <div class="section-title">Etymology & Word Paths</div>
                <p class="loading-dots">Loading word origins</p>
            </div>
            <div class="definition-section">
                <div class="section-title">Semantic Field & Associations</div>
                <p class="loading-dots">Analyzing word relationships</p>
            </div>
        `;
    }
    
    function displayCombinedResults(word, results) {
        currentWord = word;
        
        // Update header
        document.getElementById('current-word').textContent = word.toUpperCase();
        
        // Determine word type from dictionary results
        const wordType = results.dictionary?.definitions?.[0]?.type || "Noun";
        document.getElementById('current-type').textContent = wordType.toUpperCase();
        
        // Build the display HTML
        const container = document.getElementById('definition-container');
        
        // 1. Definitions Section
        let definitionsHTML = '';
        if (results.dictionary?.definitions) {
            definitionsHTML = results.dictionary.definitions.slice(0, 3).map((def, i) => `
                <div class="path-item ${i === 0 ? 'active' : ''}" onclick="insertText('${def.definition.substring(0, 50)}')">
                    <div class="path-word">${def.type || 'Definition'} ${i + 1}</div>
                    <div class="path-definition">${def.definition}</div>
                    ${def.example ? `<div class="path-definition" style="color: #666; font-style: italic;">Example: ${def.example}</div>` : ''}
                </div>
            `).join('');
        } else if (results.wiktionary?.definitions) {
            definitionsHTML = results.wiktionary.definitions.slice(0, 3).map((def, i) => `
                <div class="path-item ${i === 0 ? 'active' : ''}" onclick="insertText('${def.definition.substring(0, 50)}')">
                    <div class="path-word">Definition ${i + 1}</div>
                    <div class="path-definition">${def.definition}</div>
                </div>
            `).join('');
        } else {
            definitionsHTML = `<div class="path-item"><div class="path-definition">No formal definition found. This may be a rare or specialized term.</div></div>`;
        }
        
        // 2. Etymology Section
        let etymologyHTML = '';
        if (results.wiktionary?.etymology?.length > 0) {
            etymologyHTML = results.wiktionary.etymology.slice(0, 3).map((etym, i) => `
                <div class="path-item" onclick="insertText('${etym.substring(0, 50)}')">
                    <div class="path-word">Etymology ${i + 1}</div>
                    <div class="path-definition">${etym}</div>
                </div>
            `).join('');
        } else {
            // Generate plausible etymology based on word structure
            etymologyHTML = generatePlausibleEtymology(word);
        }
        
        // 3. Semantic Field Section (from Datamuse)
        let semanticHTML = '';
        if (results.datamuse) {
            const allRelated = [
                ...(results.datamuse.related || []),
                ...(results.datamuse.triggers || []),
                ...(results.datamuse.associated || [])
            ];
            
            // Remove duplicates and limit
            const uniqueRelated = [...new Set(allRelated)].slice(0, 8);
            
            semanticHTML = uniqueRelated.map(relatedWord => `
                <div class="path-item" onclick="searchWord('${relatedWord}')">
                    <div class="path-word">${relatedWord}</div>
                    <div class="path-definition">Related concept in ${word} field</div>
                </div>
            `).join('');
            
            // Update sidebar with related words
            updateRelatedWords(uniqueRelated);
        } else {
            semanticHTML = `<div class="path-item"><div class="path-definition">No relationship data available</div></div>`;
        }
        
        // 4. Juxtapositions Section (placeholder)
        const juxtapositionsHTML = `
            <div class="path-item" onclick="insertText('${word} and silence')">
                <div class="path-definition">${word} and silence - what remains unspoken</div>
            </div>
            <div class="path-item" onclick="insertText('${word} in the machine')">
                <div class="path-definition">${word} in the machine - digital embodiment</div>
            </div>
        `;
        
        // Update the container
        container.innerHTML = `
            <div class="definition-section">
                <div class="section-title">Definition ${results.dictionary?.source ? `(${results.dictionary.source})` : ''}</div>
                ${definitionsHTML}
            </div>
            
            <div class="definition-section">
                <div class="section-title">Etymology & Word Paths ${results.wiktionary?.source ? `(${results.wiktionary.source})` : ''}</div>
                ${etymologyHTML}
            </div>
            
            <div class="definition-section">
                <div class="section-title">Semantic Field & Associations ${results.datamuse?.source ? `(${results.datamuse.source})` : ''}</div>
                ${semanticHTML}
            </div>
            
            <div class="definition-section">
                <div class="section-title">Juxtapositions</div>
                ${juxtapositionsHTML}
            </div>
        `;
        
        // Insert word into editor
        insertText(word);
    }
    
    function generatePlausibleEtymology(word) {
        const prefixes = ['pre-', 're-', 'un-', 'dis-', 'mis-', 'over-', 'under-', 'out-'];
        const suffixes = ['-tion', '-ment', '-ness', '-ity', '-ance', '-ence', '-ism', '-ist'];
        const roots = ['phon', 'graph', 'log', 'bio', 'geo', 'astro', 'psych', 'socio'];
        
        // Check for common prefixes
        for (const prefix of prefixes) {
            if (word.startsWith(prefix.replace('-', ''))) {
                return `
                    <div class="path-item">
                        <div class="path-word">Prefix Analysis</div>
                        <div class="path-definition">From prefix "${prefix}" meaning reversal/opposition + root "${word.slice(prefix.length-1)}"</div>
                    </div>
                    <div class="path-item">
                        <div class="path-word">Historical Development</div>
                        <div class="path-definition">First attested in Middle English period</div>
                    </div>
                `;
            }
        }
        
        // Default etymology
        return `
            <div class="path-item">
                <div class="path-word">Word Origin</div>
                <div class="path-definition">Derived from Indo-European roots, related to concept of "${word}"</div>
            </div>
            <div class="path-item">
                <div class="path-word">Historical Usage</div>
                <div class="path-definition">Entered English through Latin/French transmission</div>
            </div>
        `;
    }
    
    function showErrorState(word, error) {
        document.getElementById('current-word').textContent = word.toUpperCase();
        document.getElementById('current-type').textContent = "ERROR";
        
        const container = document.getElementById('definition-container');
        container.innerHTML = `
            <div class="definition-section">
                <div class="section-title">Error</div>
                <p>Failed to fetch data for "${word}".</p>
                <p style="color: #888; font-size: 10px;">${error.message}</p>
            </div>
            <div class="definition-section">
                <div class="section-title">Suggestions</div>
                <div class="path-item" onclick="searchWord('dictionary')">
                    <div class="path-word">Try another word</div>
                    <div class="path-definition">Or check your internet connection</div>
                </div>
            </div>
        `;
    }
    
    // ==============================================
    // JUXTAPOSITION EXPLANATION & FUNCTION
    // ==============================================
    /*
    WHAT IS JUXTAPOSITION?
    -----------------------
    Juxtaposition = placing two contrasting concepts side-by-side to create 
    interesting comparisons or reveal deeper meanings.
    
    Examples from literature/philosophy:
    - "Light and darkness" (opposition)
    - "Order and chaos" (complementary opposites)
    - "Memory and forgetting" (paradoxical pair)
    - "Machine and organism" (technological vs natural)
    
    In this app:
    1. AI generates creative philosophical pairings
    2. Based on your searched words or random selection
    3. Creates interesting thought-provoking combinations
    */
    
    async function generateJuxtaposition() {
        if (!apiKey) {
            addChatMessage("Enter OpenRouter API key for AI-generated juxtapositions", "bot");
            updateKeyStatus("API key required", "error");
            return;
        }
        
        // Use recent words or generate random concepts
        let word1, word2;
        
        if (wordHistory.length >= 2) {
            // Use two most recent words
            word1 = wordHistory[0];
            word2 = wordHistory[1];
        } else if (wordHistory.length === 1) {
            // Use the searched word + a random philosophical concept
            word1 = wordHistory[0];
            word2 = getRandomConcept();
        } else {
            // Use two random concepts
            word1 = getRandomConcept();
            word2 = getRandomConcept();
            while (word2 === word1) word2 = getRandomConcept();
        }
        
        addChatMessage(`Generating AI juxtaposition: ${word1} √ó ${word2}`, "bot");
        
        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                    "HTTP-Referer": window.location.origin
                },
                body: JSON.stringify({
                    model: MODEL,
                    messages: [
                        {
                            role: "system",
                            content: `Create a SINGLE, powerful philosophical juxtaposition between two concepts.
                            Format: "[Concept1] and [Concept2]: [Brief poetic explanation]"
                            Example: "Memory and forgetting: What we choose to remember defines what we become, but what we forget shapes the spaces between."
                            Keep it under 30 words. Return ONLY the juxtaposition.`
                        },
                        {
                            role: "user",
                            content: `Create a juxtaposition between ${word1} and ${word2}`
                        }
                    ],
                    temperature: 0.9,
                    max_tokens: 80
                })
            });
            
            if (!response.ok) throw new Error(`API: ${response.status}`);
            
            const data = await response.json();
            const juxtaposition = data.choices[0].message.content.trim();
            
            // Add to juxtapositions section
            const juxtapositionsDiv = document.getElementById('juxtapositions');
            if (juxtapositionsDiv) {
                juxtapositionsDiv.innerHTML = `
                    <div class="path-item active" onclick="insertText('${juxtaposition.replace(/'/g, "\\'")}')">
                        <div class="path-word">${word1} √ó ${word2}</div>
                        <div class="path-definition">${juxtaposition}</div>
                    </div>
                    ${juxtapositionsDiv.innerHTML}
                `;
            }
            
            addChatMessage(`AI juxtaposition created`, "bot");
            insertText(juxtaposition);
            
        } catch (error) {
            addChatMessage(`Juxtaposition failed: ${error.message}`, "bot");
            updateKeyStatus(`AI error: ${error.message}`, "error");
        }
    }
    
    function getRandomConcept() {
        const concepts = [
            'time', 'space', 'consciousness', 'reality', 'truth',
            'beauty', 'justice', 'freedom', 'power', 'knowledge',
            'love', 'death', 'memory', 'language', 'thought',
            'nature', 'technology', 'art', 'science', 'faith',
            'chaos', 'order', 'light', 'darkness', 'silence',
            'voice', 'presence', 'absence', 'form', 'void'
        ];
        return concepts[Math.floor(Math.random() * concepts.length)];
    }
    
    // ==============================================
    // AI CHAT FUNCTION
    // ==============================================
    async function askAI() {
        const input = document.getElementById('chat-input');
        const question = input.value.trim();
        
        if (!question) return;
        
        if (!apiKey) {
            addChatMessage("API key required for AI analysis", "bot");
            updateKeyStatus("API key required", "error");
            input.value = '';
            return;
        }
        
        input.value = '';
        addChatMessage(question, "user");
        
        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                    "HTTP-Referer": window.location.origin
                },
                body: JSON.stringify({
                    model: MODEL,
                    messages: [
                        {
                            role: "system",
                            content: `You are a philosophical lexicographer. Analyze word relationships, 
                            suggest interesting juxtapositions, and explore semantic connections. 
                            Be concise and poetic. Reference etymology when relevant.`
                        },
                        {
                            role: "user",
                            content: question
                        }
                    ],
                    temperature: 0.8,
                    max_tokens: 200
                })
            });
            
            if (!response.ok) throw new Error(`API: ${response.status}`);
            
            const data = await response.json();
            const answer = data.choices[0].message.content;
            
            addChatMessage(answer, "bot");
            
        } catch (error) {
            addChatMessage(`AI error: ${error.message}`, "bot");
        }
    }
    
    // ==============================================
    // HELPER FUNCTIONS
    // ==============================================
    function updateKeyStatus(message, type = 'info') {
        const status = document.getElementById('key-status');
        status.textContent = message;
        status.className = 'status-message';
        if (type === 'ok') status.classList.add('status-ok');
        if (type === 'error') status.classList.add('status-error');
    }
    
    function updateSearchStatus(message, type = 'info') {
        const status = document.getElementById('search-status');
        status.textContent = message;
        status.className = 'status-message';
        if (type === 'ok') status.classList.add('status-ok');
        if (type === 'error') status.classList.add('status-error');
    }
    
    function updateAPIStatus() {
        const indicator = document.getElementById('api-status-indicator');
        const modelStatus = document.getElementById('model-status');
        const footer = document.getElementById('footer-status');
        
        if (apiKey) {
            indicator.innerHTML = 'DICTIONARIES + AI: <span class="text-green-500">ACTIVE</span>';
            modelStatus.textContent = 'AI_READY';
            modelStatus.className = 'text-green-500 font-bold';
            footer.textContent = 'FULL_SYSTEM_ACTIVE';
        } else {
            indicator.innerHTML = 'DICTIONARIES: <span class="text-green-500">ACTIVE</span>';
            modelStatus.textContent = 'DICTIONARIES_ONLY';
            modelStatus.className = 'text-red-700 font-bold';
            footer.textContent = 'AI_DISABLED';
        }
    }
    
    function updateRelatedWords(relatedWords) {
        const container = document.getElementById('related-words');
        container.innerHTML = relatedWords.map(word => `
            <div class="word-link" onclick="searchWord('${word}')">${word}</div>
        `).join('');
    }
    
    function updateHistoryDisplay() {
        const container = document.getElementById('path-history');
        container.innerHTML = wordHistory.map(word => `
            <div class="word-link ${word === currentWord ? 'active' : ''}" onclick="searchWord('${word}')">${word}</div>
        `).join('');
    }
    
    function insertText(text) {
        const editor = document.getElementById('editor');
        editor.innerHTML += ` <span style="color:var(--red)">${text}</span> `;
        editor.scrollTop = editor.scrollHeight;
        updateWordCount();
        saveEditor();
    }
    
    function updateWordCount() {
        const editor = document.getElementById('editor');
        const text = editor.innerText.trim();
        const wordCount = text.length > 0 ? text.split(/\s+/).length : 0;
        document.getElementById('word-count').textContent = `${wordCount}W`;
    }
    
    function addChatMessage(message, sender) {
        const container = document.getElementById('chat-container');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-bubble ${sender}-message`;
        messageDiv.textContent = message;
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    function clearHistory() {
        if (confirm("Clear search history?")) {
            wordHistory = [];
            updateHistoryDisplay();
            addChatMessage("History cleared", "bot");
        }
    }
    
    function exportText() {
        const editor = document.getElementById('editor');
        const text = editor.innerText;
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lexicon_${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        
        addChatMessage("Text exported", "bot");
    }
    
    function saveEditor() {
        const editor = document.getElementById('editor');
        localStorage.setItem('lexicon_2741_editor', editor.innerHTML);
    }
    
    function loadEditor() {
        const saved = localStorage.getItem('lexicon_2741_editor');
        if (saved) {
            document.getElementById('editor').innerHTML = saved;
        } else {
            document.getElementById('editor').innerHTML = `
                _2741_LEXICON_PROTOCOL:<br>
                i. SEARCH words using the search box.<br>
                ii. REAL dictionary APIs: FreeDictionary, Datamuse, Wiktionary.<br>
                iii. ENTER OpenRouter API key for AI juxtapositions.<br>
                iv. JUXTAPOSE = AI creates interesting word pairings.<br>
                v. CLICK any word/definition to insert into text.<br><br>
                ------------------------------------------<br><br>
                Each word connects to others in invisible networks. The search reveals not just meanings, but relationships. The space between words holds as much meaning as the words themselves...
            `;
        }
        updateWordCount();
    }
    
    // Typewriter effect
    let messageIndex = 0, charIndex = 0, isDeleting = false;
    const statusMessages = [
        ">> LEXICON_INTERFACE_ACTIVE",
        ">> REAL_DICTIONARY_APIS_CONNECTED",
        ">> DATAMUSE_WORD_RELATIONSHIPS_READY",
        ">> AWAITING_SEARCH_QUERIES",
        ">> JUXTAPOSITION_ENGINE_PRIMED"
    ];
    
    function typeStatus() {
        const target = document.getElementById('teletype');
        if(!target) return;
        const currentMsg = statusMessages[messageIndex];
        target.innerText = isDeleting ? currentMsg.substring(0, charIndex - 1) : currentMsg.substring(0, charIndex + 1);
        charIndex = isDeleting ? charIndex - 1 : charIndex + 1;
        let speed = isDeleting ? 40 : 80;
        if (!isDeleting && charIndex === currentMsg.length) { speed = 3000; isDeleting = true; }
        else if (isDeleting && charIndex === 3) { isDeleting = false; messageIndex = (messageIndex + 1) % statusMessages.length; speed = 500; }
        setTimeout(typeStatus, speed);
    }
    
    function init() {
        loadEditor();
        updateHistoryDisplay();
        typeStatus();
        
        const editor = document.getElementById('editor');
        if (editor) {
            editor.addEventListener('input', function() {
                updateWordCount();
                saveEditor();
            });
        }
    }
    
    document.getElementById('splash-screen').addEventListener('click', function() {
        this.style.opacity = '0';
        this.style.transition = 'opacity 0.5s';
        document.querySelector('.app-grid').style.display = 'grid';
        setTimeout(() => {
            this.style.display = 'none';
        }, 500);
    });
</script>
</body>
</html>
