<!--[if IE 6]>
<html id="ie6" lang="en-US">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en-US">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en-US">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8) ]><!-->
<!DOCTYPE html>
<html lang="en" class="üëó" data-theme="light">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	
<link rel="icon" type="image/svg+xml" href="https://cdn.jsdelivr.net/gh/ghostm68/inktwo@main/svg/inky.svg">
<link rel="apple-touch-icon" type="image/png" href="https://github.com/ghostm68/pantheon/raw/main/inkrealm.info.2025.png" />
<meta itemprop="name" content="wordstar nexus/conceptweave"/>	
<meta property="og:url" content="https://www.wordstar.nexus/conceptweave"/>

<title>2741 Lexicon v4.14</title>
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&display=swap" rel="stylesheet">

<style>
    :root {
        --red: #ff0000;
        --black: #050505;
        --dark-grey: #121212;
        --light-grey: #222222;
        --white: #d1d1d1;
    }
    
    * { 
        -webkit-tap-highlight-color: transparent; 
        box-sizing: border-box; 
    }
    
    body { 
        background: var(--black); 
        color: var(--white); 
        font-family: 'Nova Mono', monospace; 
        margin: 0;
        height: 100vh;
        overflow: hidden;
    }
    
    body::after {
        content: " ";
        display: block;
        position: fixed;
        top: 0; left: 0; bottom: 0; right: 0;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.15) 50%);
        z-index: 999;
        background-size: 100% 3px;
        pointer-events: none;
        opacity: 0.4;
    }
    
    #splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--black);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 4px double var(--red);
    }
    
    .app-grid {
        display: none;
        grid-template-columns: 320px 1fr;
        grid-template-rows: 50px 1fr 320px 30px;
        height: 100vh;
        gap: 1px;
        background: var(--red);
    }
    
    header {
        grid-column: span 2;
        background: var(--black);
        border-bottom: 1px solid var(--red);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        z-index: 50;
    }
    
    .sidebar {
        background: var(--black);
        border-right: 1px solid var(--red);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        padding: 0;
    }
    
    #word-explorer {
        background: var(--black);
        display: flex;
        flex-direction: column;
        border-bottom: 1px solid var(--red);
        overflow: hidden;
    }
    
    .bottom-shelf {
        grid-row: 3;
        grid-column: span 2;
        display: grid;
        grid-template-columns: 1fr 350px;
        height: 320px;
        overflow: hidden;
        background: var(--black);
    }
    
    .editor-section {
        background: var(--dark-grey);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        border-top: 1px solid var(--red);
    }
    
    #editor {
        flex-grow: 1;
        padding: 25px;
        font-family: 'Special Elite', serif;
        font-size: 1.2rem;
        line-height: 1.6;
        outline: none;
        overflow-y: auto;
        color: var(--white);
        caret-color: var(--red);
        background: var(--dark-grey);
        border: none;
    }
    
    .comms-console {
        background: var(--black);
        border-left: 1px solid var(--red);
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }
    
    #chat-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 10px;
        font-size: 10px;
        scroll-behavior: smooth;
    }
    
    .chat-bubble {
        margin-bottom: 10px;
        padding: 8px;
        border: 1px solid var(--light-grey);
        background: var(--black);
    }
    
    .user-message {
        border-left: 3px solid #555;
        color: #888;
    }
    
    .bot-message {
        border-left: 3px solid var(--red);
        color: var(--white);
        background: rgba(255, 0, 0, 0.05);
    }
    
    .chat-input-area {
        display: flex;
        border-top: 1px solid var(--light-grey);
        padding: 5px;
        background: var(--black);
    }
    
    #chat-input {
        background: var(--black);
        color: var(--red);
        border: 1px solid var(--light-grey);
        flex-grow: 1;
        padding: 5px;
        font-size: 10px;
        outline: none;
        font-family: 'Nova Mono', monospace;
    }
    
    footer {
        grid-column: span 2;
        background: var(--black);
        border-top: 1px solid var(--light-grey);
        font-size: 8px;
        color: #444;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        height: 30px;
    }
    
    /* Word Explorer Styles */
    .explorer-header {
        background: var(--black);
        border-bottom: 1px solid var(--red);
        padding: 15px;
    }
    
    #current-word {
        font-size: 24px;
        color: var(--red);
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    #current-type {
        font-size: 10px;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    #definition-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        font-size: 12px;
        line-height: 1.6;
    }
    
    .definition-section {
        margin-bottom: 20px;
    }
    
    .section-title {
        color: var(--red);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
        border-bottom: 1px solid var(--light-grey);
        padding-bottom: 3px;
    }
    
    .path-item {
        padding: 8px 12px;
        border-left: 2px solid var(--light-grey);
        margin-bottom: 8px;
        cursor: pointer;
        transition: all 0.2s;
        background: rgba(255, 255, 255, 0.02);
    }
    
    .path-item:hover {
        border-left-color: var(--red);
        background: rgba(255, 0, 0, 0.05);
    }
    
    .path-item.active {
        border-left-color: var(--red);
        background: rgba(255, 0, 0, 0.1);
        color: var(--white);
    }
    
    .path-word {
        color: var(--red);
        font-weight: bold;
        margin-bottom: 3px;
    }
    
    .path-definition {
        color: #888;
        font-size: 10px;
        line-height: 1.4;
    }
    
    /* Sidebar Navigation */
    .nav-section {
        border-bottom: 1px solid var(--light-grey);
        padding: 15px;
    }
    
    .nav-title {
        color: var(--red);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 10px;
    }
    
    .word-link {
        display: block;
        padding: 6px 0;
        color: #888;
        cursor: pointer;
        font-size: 11px;
        transition: color 0.2s;
        border-left: 2px solid transparent;
        padding-left: 10px;
    }
    
    .word-link:hover {
        color: var(--white);
        border-left-color: var(--red);
    }
    
    .word-link.active {
        color: var(--red);
        border-left-color: var(--red);
    }
    
    #path-history {
        max-height: 150px;
        overflow-y: auto;
        margin-bottom: 10px;
    }
    
    /* Search Box */
    .search-container {
        padding: 15px;
        background: rgba(255, 0, 0, 0.05);
        border-bottom: 1px solid var(--light-grey);
    }
    
    .search-box {
        display: flex;
        gap: 5px;
        margin-bottom: 10px;
    }
    
    .search-box input {
        flex-grow: 1;
        background: var(--black);
        color: var(--white);
        border: 1px solid var(--light-grey);
        padding: 8px;
        font-size: 11px;
        font-family: 'Nova Mono', monospace;
    }
    
    .search-box button {
        background: var(--light-grey);
        color: var(--white);
        border: none;
        padding: 0 15px;
        font-size: 11px;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .search-box button:hover {
        background: var(--red);
    }
    
    /* API Key Input */
    .api-key-container {
        padding: 15px;
        background: rgba(255, 0, 0, 0.05);
        border-bottom: 1px solid var(--light-grey);
    }
    
    .api-key-input {
        display: flex;
        gap: 5px;
        margin-bottom: 5px;
    }
    
    .api-key-input input {
        flex-grow: 1;
        background: var(--black);
        color: var(--red);
        border: 1px solid var(--light-grey);
        padding: 8px;
        font-size: 11px;
        font-family: 'Nova Mono', monospace;
    }
    
    .api-key-input button {
        background: var(--light-grey);
        color: var(--white);
        border: none;
        padding: 0 15px;
        font-size: 11px;
        cursor: pointer;
        white-space: nowrap;
    }
    
    .api-key-input button:hover {
        background: var(--red);
    }
    
    .status-message {
        font-size: 9px;
        color: #888;
        padding: 3px 0;
        min-height: 20px;
    }
    
    .status-ok {
        color: #00ff00;
    }
    
    .status-error {
        color: var(--red);
    }
    
    .teletype-text::after {
        content: "|";
        animation: blink 1s infinite;
    }
    
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }
    
    @media (max-width: 768px) {
        .app-grid {
            grid-template-columns: 1fr;
            grid-template-rows: 50px 250px 1fr 350px 30px;
        }
        
        header, footer {
            grid-column: 1;
        }
        
        .sidebar {
            grid-row: 2;
            max-height: 250px;
            border-right: none;
            border-bottom: 1px solid var(--red);
        }
        
        #word-explorer {
            grid-row: 3;
            height: auto;
        }
        
        .bottom-shelf {
            grid-row: 4;
            grid-template-columns: 1fr;
            grid-template-rows: 200px 150px;
        }
        
        .comms-console {
            height: 150px;
            border-left: none;
            border-top: 1px solid var(--red);
        }
    }
</style>
</head>
<body>

<div id="splash-screen">
    <h1 class="text-red-600 font-bold text-4xl mb-4 tracking-tighter italic">LEXICON_2741</h1>
    <p class="text-zinc-500 animate-pulse text-xs tracking-widest uppercase">Initialize Word Matrix</p>
</div>

<div class="app-grid">
    <header>
        <div class="flex items-center gap-3">
            <div id="power-light" class="w-2 h-2 bg-zinc-900 rounded-full"></div>
            <h1 class="text-white font-bold tracking-tighter text-xs uppercase">LEXICON_2741_v4.14</h1>
            <span id="api-status-indicator" class="text-[9px] text-zinc-500">API: LOCKED</span>
        </div>
        <div class="flex gap-2">
            <button onclick="clearHistory()" class="text-[9px] border border-zinc-800 px-2 py-1">CLEAR_HISTORY</button>
            <button onclick="exportText()" class="text-[9px] border border-zinc-800 px-2 py-1 text-red-600 font-bold">EXTRACT_TEXT</button>
            <button onclick="generateJuxtaposition()" class="text-[9px] border border-zinc-800 px-2 py-1 text-red-600">JUXTAPOSE</button>
        </div>
    </header>
    
    <aside class="sidebar">
        <div class="search-container">
            <div class="nav-title">Word Search</div>
            <div class="search-box">
                <input type="text" id="word-search" placeholder="Enter word..." onkeypress="if(event.key==='Enter') searchWord()">
                <button onclick="searchWord()">SEARCH</button>
            </div>
            <div id="search-status" class="status-message">Enter a word to search</div>
        </div>
        
        <div class="api-key-container">
            <div class="nav-title">OpenRouter API Key</div>
            <div class="api-key-input">
                <input type="password" id="apiKey" placeholder="sk-or-v1-...">
                <button id="toggleKey" title="Show/Hide">üëÅ</button>
            </div>
            <div id="key-status" class="status-message">For AI juxtapositions only</div>
        </div>
        
        <div class="nav-section">
            <div class="nav-title">Recent Words</div>
            <div id="path-history">
                <!-- Recent searches will be populated here -->
            </div>
        </div>
        
        <div class="nav-section" style="flex-grow: 1;">
            <div class="nav-title">Semantic Field</div>
            <div id="related-words">
                <!-- Related words will be populated here -->
            </div>
        </div>
        
        <div class="nav-section">
            <div class="nav-title">Quick Access</div>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="searchWord('philosophy')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Philosophy</button>
                <button onclick="searchWord('consciousness')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Consciousness</button>
                <button onclick="searchWord('memory')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Memory</button>
                <button onclick="searchWord('language')" class="text-[9px] border border-zinc-800 px-2 py-1 text-left">Language</button>
            </div>
        </div>
    </aside>
    
    <main id="word-explorer">
        <div class="explorer-header">
            <div id="current-word">LEXICON</div>
            <div id="current-type">NOUN / SYSTEM</div>
        </div>
        
        <div id="definition-container">
            <div class="definition-section">
                <div class="section-title">Definition</div>
                <p>A dictionary or word-book; a vocabulary of a particular language, subject, or field of study.</p>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Etymology Path</div>
                <div id="etymology-path">
                    <div class="path-item active" onclick="searchWord('lexicon')">
                        <div class="path-word">1. Lexicon</div>
                        <div class="path-definition">From Greek "lexikon" (biblion) meaning "word-book"</div>
                    </div>
                    <div class="path-item" onclick="searchWord('dictionary')">
                        <div class="path-word">2. Lexikos</div>
                        <div class="path-definition">Greek "lexikos" meaning "of words"</div>
                    </div>
                    <div class="path-item" onclick="searchWord('word')">
                        <div class="path-word">3. Lexis</div>
                        <div class="path-definition">Greek "lexis" meaning "word, speech"</div>
                    </div>
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Semantic Field</div>
                <div id="semantic-field">
                    <div class="path-item" onclick="searchWord('dictionary')">
                        <div class="path-word">Dictionary</div>
                        <div class="path-definition">A reference work containing words</div>
                    </div>
                    <div class="path-item" onclick="searchWord('vocabulary')">
                        <div class="path-word">Vocabulary</div>
                        <div class="path-definition">The body of words used</div>
                    </div>
                    <div class="path-item" onclick="searchWord('glossary')">
                        <div class="path-word">Glossary</div>
                        <div class="path-definition">A list of specialized terms</div>
                    </div>
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Juxtapositions</div>
                <div id="juxtapositions">
                    <div class="path-item" onclick="insertText('Lexicon and labyrinth')">
                        <div class="path-definition">Lexicon and labyrinth - the maze of language</div>
                    </div>
                    <div class="path-item" onclick="insertText('Word and void')">
                        <div class="path-definition">Word and void - what language cannot contain</div>
                    </div>
                </div>
            </div>
        </div>
    </main>
    
    <div class="bottom-shelf">
        <section class="editor-section">
            <div class="bg-red-600 text-white px-4 py-1 flex justify-between font-serif text-[10px]">
                <div class="teletype-text" id="teletype">>> LEXICON_INTERFACE_ACTIVE</div>
                <div id="word-count">0W</div>
            </div>
            <div id="editor" contenteditable="true" spellcheck="false"></div>
        </section>
        
        <aside class="comms-console">
            <div class="bg-zinc-900 text-[9px] p-2 text-zinc-500 uppercase flex justify-between border-b border-red-900">
                <span>Dolphin-Mistral-24b-Venice</span>
                <span id="model-status" class="text-red-700 font-bold">AI_JUXTAPOSITIONS</span>
            </div>
            <div id="chat-container">
                <div class="chat-bubble bot-message">Use the search box for word definitions. Enter API key for AI-generated juxtapositions.</div>
            </div>
            <div class="chat-input-area">
                <input type="text" id="chat-input" placeholder="Ask AI about word relationships..." onkeypress="if(event.key==='Enter') askAI()">
                <button onclick="askAI()" class="bg-red-800 px-2 text-[9px] ml-1">ASK_AI</button>
            </div>
        </aside>
    </div>
    
    <footer>
        <div>LEXICON_v4.14 // LOCAL_DB + AI_JUXTAPOSITIONS</div>
        <div class="flex gap-4 uppercase">
            <span>OpenRouter BYOK</span><span>|</span>
            <span id="footer-status">SEARCH_ACTIVE</span>
        </div>
    </footer>
</div>

<script>
    // Configuration
    const MODEL = "cognitivecomputations/dolphin-mistral-24b-venice-edition:free";
    
    // State
    let apiKey = '';
    let currentWord = "lexicon";
    let wordHistory = [];
    let wordDatabase = {};
    
    // Load saved API key on startup
    window.addEventListener('load', () => {
        const saved = localStorage.getItem('openrouter_api_key');
        if (saved) {
            apiKey = saved;
            document.getElementById('apiKey').value = saved;
            updateStatus('API key loaded from storage', 'ok');
            updateAPIStatus();
        }
        init();
    });
    
    // Toggle key visibility
    document.getElementById('toggleKey').addEventListener('click', () => {
        const input = document.getElementById('apiKey');
        input.type = input.type === 'password' ? 'text' : 'password';
    });
    
    // Save key on change
    document.getElementById('apiKey').addEventListener('change', (e) => {
        const key = e.target.value.trim();
        if (key) {
            apiKey = key;
            localStorage.setItem('openrouter_api_key', key);
            updateStatus('API key saved', 'ok');
            updateAPIStatus();
            addChatMessage("API key validated. AI juxtapositions enabled.", "bot");
        }
    });
    
    // Search word in local database
    function searchWord(word = null) {
        const searchInput = document.getElementById('word-search');
        const wordToSearch = word || searchInput.value.trim().toLowerCase();
        
        if (!wordToSearch) {
            updateSearchStatus("Enter a word to search", "info");
            return;
        }
        
        searchInput.value = wordToSearch;
        updateSearchStatus(`Searching: ${wordToSearch}`, "info");
        
        // Add to history
        if (!wordHistory.includes(wordToSearch)) {
            wordHistory.unshift(wordToSearch);
            if (wordHistory.length > 10) wordHistory.pop();
            updateHistoryDisplay();
        }
        
        // Get word data from local database
        const wordData = getWordData(wordToSearch);
        displayWordData(wordToSearch, wordData);
        
        updateSearchStatus(`Found: ${wordToSearch}`, "ok");
        addChatMessage(`Searched: ${wordToSearch}`, "user");
    }
    
    // Get word data from local sources
    function getWordData(word) {
        // Local database of word information
        const localDictionary = {
            'philosophy': {
                type: 'Noun',
                definition: 'The study of fundamental questions about existence, knowledge, values, reason, mind, and language.',
                etymology: ['Greek "philosophia": philo (love) + sophia (wisdom)', 
                          '14th century: via Old French from Latin "philosophia"',
                          'Originally: love of wisdom or knowledge'],
                semanticField: ['metaphysics', 'epistemology', 'ethics', 'logic', 'aesthetics'],
                examples: ['Ancient Greek philosophy', 'Philosophy of mind', 'Moral philosophy']
            },
            'consciousness': {
                type: 'Noun',
                definition: 'The state of being aware of and able to think about ones own existence, sensations, thoughts, and surroundings.',
                etymology: ['Latin "conscientia": knowledge within oneself',
                          '17th century: from conscious + -ness',
                          'Root: Latin "conscire" (be privy to)'],
                semanticField: ['awareness', 'cognition', 'mind', 'perception', 'subjectivity'],
                examples: ['Stream of consciousness', 'Altered states of consciousness']
            },
            'memory': {
                type: 'Noun',
                definition: 'The faculty by which the mind stores and remembers information.',
                etymology: ['Latin "memoria" from memor (mindful, remembering)',
                          '13th century: from Old French "memorie"',
                          'Indo-European root *mer- (to remember)'],
                semanticField: ['recall', 'recollection', 'remembrance', 'mnemonic', 'retention'],
                examples: ['Collective memory', 'Memory palace technique']
            },
            'language': {
                type: 'Noun',
                definition: 'The method of human communication, either spoken or written, consisting of the use of words in a structured and conventional way.',
                etymology: ['Old French "langage" from langue (tongue)',
                          '13th century: from Latin "lingua" (tongue, language)',
                          'Proto-Indo-European *dnÃ•«µ ∞w√©h‚ÇÇs (tongue, speech)'],
                semanticField: ['linguistics', 'communication', 'syntax', 'semantics', 'discourse'],
                examples: ['Natural language processing', 'Body language']
            },
            'lexicon': {
                type: 'Noun',
                definition: 'A dictionary or word-book; a vocabulary of a particular language, subject, or field of study.',
                etymology: ['Greek "lexikon" (biblion) meaning "word-book"',
                          '17th century: via medieval Latin from Greek',
                          'From "lexis" meaning "word, speech"'],
                semanticField: ['dictionary', 'vocabulary', 'glossary', 'thesaurus', 'terminology'],
                examples: ['Technical lexicon', 'Mental lexicon']
            }
        };
        
        // If word exists in local dictionary, return it
        if (localDictionary[word]) {
            return localDictionary[word];
        }
        
        // Otherwise generate plausible data
        return generateWordData(word);
    }
    
    // Generate word data for unknown words
    function generateWordData(word) {
        const types = ['Noun', 'Verb', 'Adjective', 'Adverb'];
        const origins = ['Latin', 'Greek', 'Old English', 'French', 'Germanic'];
        const fields = {
            'Noun': ['concept', 'entity', 'object', 'abstraction', 'quality'],
            'Verb': ['action', 'process', 'state', 'occurrence', 'activity'],
            'Adjective': ['descriptive', 'qualitative', 'attributive', 'relational', 'classifying'],
            'Adverb': ['manner', 'time', 'place', 'degree', 'frequency']
        };
        
        const type = types[Math.floor(Math.random() * types.length)];
        const origin = origins[Math.floor(Math.random() * origins.length)];
        
        return {
            type: type,
            definition: `The ${type.toLowerCase()} "${word}" refers to a concept or entity within its semantic domain.`,
            etymology: [
                `From ${origin} root *${word.substring(0, 3)}-`,
                `Middle development through scholarly tradition`,
                `Modern usage in technical and philosophical contexts`
            ],
            semanticField: fields[type],
            examples: [`The ${word} of contemporary thought`, `${word} in historical context`]
        };
    }
    
    // Display word data
    function displayWordData(word, data) {
        currentWord = word;
        
        // Update header
        document.getElementById('current-word').textContent = word.toUpperCase();
        document.getElementById('current-type').textContent = data.type.toUpperCase();
        
        // Update definition
        const definitionContainer = document.getElementById('definition-container');
        definitionContainer.innerHTML = `
            <div class="definition-section">
                <div class="section-title">Definition</div>
                <p>${data.definition}</p>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Etymology Path</div>
                <div id="etymology-path">
                    ${data.etymology.map((step, i) => `
                        <div class="path-item ${i === 0 ? 'active' : ''}" onclick="insertText('${step.split(' ')[0]}')">
                            <div class="path-word">${i + 1}. ${step.split(' ')[0]}</div>
                            <div class="path-definition">${step}</div>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Semantic Field</div>
                <div id="semantic-field">
                    ${data.semanticField.map(relatedWord => `
                        <div class="path-item" onclick="searchWord('${relatedWord}')">
                            <div class="path-word">${relatedWord}</div>
                            <div class="path-definition">Related concept in ${word} field</div>
                        </div>
                    `).join('')}
                </div>
            </div>
            
            <div class="definition-section">
                <div class="section-title">Juxtapositions</div>
                <div id="juxtapositions">
                    <div class="path-item" onclick="insertText('${word} and silence')">
                        <div class="path-definition">${word} and silence - what remains unspoken</div>
                    </div>
                    <div class="path-item" onclick="insertText('${word} in the machine')">
                        <div class="path-definition">${word} in the machine - digital embodiment</div>
                    </div>
                </div>
            </div>
        `;
        
        // Update related words in sidebar
        updateRelatedWords(data.semanticField);
        
        // Insert word into editor
        insertText(word);
    }
    
    // Ask AI about word relationships
    async function askAI() {
        const input = document.getElementById('chat-input');
        const question = input.value.trim();
        
        if (!question) return;
        
        if (!apiKey) {
            addChatMessage("API key required for AI analysis. Enter key in sidebar.", "bot");
            updateStatus("API key required", "error");
            input.value = '';
            return;
        }
        
        input.value = '';
        addChatMessage(question, "user");
        
        try {
            addChatMessage("Analyzing with Dolphin-Mistral-24b-Venice...", "bot");
            
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                    "HTTP-Referer": window.location.origin,
                    "X-Title": "LEXICON_2741"
                },
                body: JSON.stringify({
                    model: MODEL,
                    messages: [
                        {
                            role: "system",
                            content: `You are a philosophical lexicographer. Analyze word relationships and create insightful juxtapositions. Keep responses concise and poetic.`
                        },
                        {
                            role: "user",
                            content: question
                        }
                    ],
                    temperature: 0.8,
                    max_tokens: 150
                })
            });
            
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            
            const data = await response.json();
            const answer = data.choices[0].message.content;
            
            addChatMessage(answer, "bot");
            
            // If answer contains interesting juxtapositions, add them
            if (answer.includes(' and ') || answer.includes(' √ó ') || answer.includes(' vs ')) {
                const juxtapositionsDiv = document.getElementById('juxtapositions');
                if (juxtapositionsDiv) {
                    juxtapositionsDiv.innerHTML += `
                        <div class="path-item" onclick="insertText('${answer.replace(/'/g, "\\'").substring(0, 100)}')">
                            <div class="path-definition">${answer.substring(0, 150)}...</div>
                        </div>
                    `;
                }
            }
            
        } catch (error) {
            addChatMessage(`AI error: ${error.message}`, "bot");
            updateStatus(`AI error: ${error.message}`, "error");
        }
    }
    
    // Generate AI juxtaposition between words
    async function generateJuxtaposition() {
        if (!apiKey) {
            addChatMessage("API key required for AI juxtapositions", "bot");
            updateStatus("API key required", "error");
            return;
        }
        
        if (wordHistory.length < 2) {
            addChatMessage("Search at least 2 words first", "bot");
            return;
        }
        
        const word1 = wordHistory[0];
        const word2 = wordHistory[1] || wordHistory[0];
        
        addChatMessage(`Generating AI juxtaposition: ${word1} √ó ${word2}`, "bot");
        
        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                    "HTTP-Referer": window.location.origin
                },
                body: JSON.stringify({
                    model: MODEL,
                    messages: [
                        {
                            role: "system",
                            content: "Create a single, poetic philosophical juxtaposition between two concepts. Return only the juxtaposition text (max 20 words)."
                        },
                        {
                            role: "user",
                            content: `Create a juxtaposition between ${word1} and ${word2}`
                        }
                    ],
                    temperature: 0.9,
                    max_tokens: 50
                })
            });
            
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            
            const data = await response.json();
            const juxtaposition = data.choices[0].message.content;
            
            // Add to juxtapositions section
            const juxtapositionsDiv = document.getElementById('juxtapositions');
            if (juxtapositionsDiv) {
                juxtapositionsDiv.innerHTML += `
                    <div class="path-item" onclick="insertText('${juxtaposition.replace(/'/g, "\\'")}')">
                        <div class="path-word">${word1} √ó ${word2}</div>
                        <div class="path-definition">${juxtaposition}</div>
                    </div>
                `;
            }
            
            addChatMessage(`AI juxtaposition: ${juxtaposition}`, "bot");
            insertText(juxtaposition);
            
        } catch (error) {
            addChatMessage(`Juxtaposition failed: ${error.message}`, "bot");
            updateStatus(`AI error: ${error.message}`, "error");
        }
    }
    
    // Update status messages
    function updateStatus(message, type = 'info') {
        const status = document.getElementById('key-status');
        status.textContent = message;
        status.className = 'status-message';
        if (type === 'ok') status.classList.add('status-ok');
        if (type === 'error') status.classList.add('status-error');
    }
    
    function updateSearchStatus(message, type = 'info') {
        const status = document.getElementById('search-status');
        status.textContent = message;
        status.className = 'status-message';
        if (type === 'ok') status.classList.add('status-ok');
        if (type === 'error') status.classList.add('status-error');
    }
    
    // Update API status display
    function updateAPIStatus() {
        const indicator = document.getElementById('api-status-indicator');
        const modelStatus = document.getElementById('model-status');
        const footer = document.getElementById('footer-status');
        
        if (apiKey) {
            indicator.innerHTML = 'API: <span class="text-green-500">ACTIVE</span>';
            modelStatus.textContent = 'AI_READY';
            modelStatus.className = 'text-green-500 font-bold';
            footer.textContent = 'AI_JUXTAPOSITIONS_ENABLED';
        } else {
            indicator.innerHTML = 'API: <span class="text-red-500">LOCKED</span>';
            modelStatus.textContent = 'AI_DISABLED';
            modelStatus.className = 'text-red-700 font-bold';
            footer.textContent = 'LOCAL_SEARCH_ONLY';
        }
    }
    
    // Update related words display
    function updateRelatedWords(relatedWords) {
        const container = document.getElementById('related-words');
        container.innerHTML = relatedWords.map(word => `
            <div class="word-link" onclick="searchWord('${word}')">${word}</div>
        `).join('');
    }
    
    // Update history display
    function updateHistoryDisplay() {
        const container = document.getElementById('path-history');
        container.innerHTML = wordHistory.map(word => `
            <div class="word-link ${word === currentWord ? 'active' : ''}" onclick="searchWord('${word}')">${word}</div>
        `).join('');
    }
    
    // Insert text into editor
    function insertText(text) {
        const editor = document.getElementById('editor');
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        
        // Create span element for the text
        const span = document.createElement('span');
        span.style.color = 'var(--red)';
        span.textContent = ' ' + text + ' ';
        
        // Insert at cursor position
        range.insertNode(span);
        
        // Move cursor after inserted text
        range.setStartAfter(span);
        range.setEndAfter(span);
        selection.removeAllRanges();
        selection.addRange(range);
        
        editor.scrollTop = editor.scrollHeight;
        updateWordCount();
        saveEditor();
    }
    
    // Update word count
    function updateWordCount() {
        const editor = document.getElementById('editor');
        const text = editor.innerText.trim();
        const wordCount = text.length > 0 ? text.split(/\s+/).length : 0;
        document.getElementById('word-count').textContent = `${wordCount}W`;
    }
    
    // Add chat message
    function addChatMessage(message, sender) {
        const container = document.getElementById('chat-container');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-bubble ${sender}-message`;
        messageDiv.textContent = message;
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }
    
    // Clear history
    function clearHistory() {
        if (confirm("Clear search history?")) {
            wordHistory = [];
            updateHistoryDisplay();
            addChatMessage("History cleared", "bot");
        }
    }
    
    // Export text
    function exportText() {
        const editor = document.getElementById('editor');
        const text = editor.innerText;
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lexicon_${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        
        addChatMessage("Text exported", "bot");
    }
    
    // Save editor content
    function saveEditor() {
        const editor = document.getElementById('editor');
        localStorage.setItem('lexicon_2741_editor', editor.innerHTML);
    }
    
    // Load editor content
    function loadEditor() {
        const saved = localStorage.getItem('lexicon_2741_editor');
        if (saved) {
            document.getElementById('editor').innerHTML = saved;
        } else {
            document.getElementById('editor').innerHTML = `
                _2741_LEXICON_PROTOCOL:<br>
                i. SEARCH words using the search box.<br>
                ii. EXPLORE etymology paths and semantic fields.<br>
                iii. ENTER API key for AI-generated juxtapositions.<br>
                iv. USE ASK_AI for word relationship analysis.<br>
                v. CLICK any word to insert into text.<br><br>
                ------------------------------------------<br><br>
                Each word carries its history in its sounds. The search begins not with answers but with better questions. The lexicon expands with every query, every connection made between seemingly disparate concepts...
            `;
        }
        updateWordCount();
    }
    
    // Typewriter effect for status
    let messageIndex = 0, charIndex = 0, isDeleting = false;
    const statusMessages = [
        ">> LEXICON_INTERFACE_ACTIVE",
        ">> LOCAL_DATABASE_LOADED",
        ">> SEARCH_SYSTEM_PRIMED",
        ">> AWAITING_QUERIES",
        ">> WORD_MATRIX_STABLE"
    ];
    
    function typeStatus() {
        const target = document.getElementById('teletype');
        if(!target) return;
        const currentMsg = statusMessages[messageIndex];
        target.innerText = isDeleting ? currentMsg.substring(0, charIndex - 1) : currentMsg.substring(0, charIndex + 1);
        charIndex = isDeleting ? charIndex - 1 : charIndex + 1;
        let speed = isDeleting ? 40 : 80;
        if (!isDeleting && charIndex === currentMsg.length) { speed = 3000; isDeleting = true; }
        else if (isDeleting && charIndex === 3) { isDeleting = false; messageIndex = (messageIndex + 1) % statusMessages.length; speed = 500; }
        setTimeout(typeStatus, speed);
    }
    
    // Initialize
    function init() {
        loadEditor();
        updateHistoryDisplay();
        typeStatus();
        
        // Set up editor event listener
        const editor = document.getElementById('editor');
        if (editor) {
            editor.addEventListener('input', function() {
                updateWordCount();
                saveEditor();
            });
        }
    }
    
    // Splash screen handler
    document.getElementById('splash-screen').addEventListener('click', function() {
        this.style.opacity = '0';
        this.style.transition = 'opacity 0.5s';
        document.querySelector('.app-grid').style.display = 'grid';
        setTimeout(() => {
            this.style.display = 'none';
        }, 500);
    });
</script>
</body>
</html>
