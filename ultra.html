<!--[if IE 6]>
<html id="ie6" lang="en-US">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8) ]><!-->
<!DOCTYPE html>
<html lang="en" class="üëó" data-theme="light">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>LEXICON 2741 v4.60 // WEBSTER-GERMAN-LOGIC-SYNONYM</title>

<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Nova+Mono&family=Special+Elite&family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">

<style>
    :root {
        --red: #ff0000;
        --black: #050505;
        --dark-grey: #121212;
        --mid-grey: #1a1a1a;
        --white: #d1d1d1;
        --gold: #d4af37;
    }
    
    body { 
        background: var(--black); 
        color: var(--white); 
        font-family: 'Nova Mono', monospace; 
        margin: 0;
        height: 100vh;
        overflow: hidden;
        cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='6' fill='%23ff0000' opacity='0.7'/%3E%3C/svg%3E") 8 8, auto;
    }

    /* CRT Overlay */
    body::after {
        content: " ";
        display: block;
        position: fixed;
        top: 0; left: 0; bottom: 0; right: 0;
        background: 
            linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%),
            radial-gradient(ellipse at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.2) 100%);
        z-index: 999;
        background-size: 100% 3px, 100% 100%;
        pointer-events: none;
        opacity: 0.3;
        animation: scanlines 8s linear infinite;
    }
    
    @keyframes scanlines {
        0% { background-position: 0px 0px, 0 0; }
        100% { background-position: 0px 1000px, 0 0; }
    }
    
    .app-grid {
        display: grid;
        grid-template-columns: 320px 1fr;
        grid-template-rows: 50px 1fr 380px 30px;
        height: 100vh;
        gap: 1px;
        background: var(--red);
        animation: gridFadeIn 1s ease-out;
    }
    
    @keyframes gridFadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    header {
        grid-column: span 2;
        background: var(--black);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        border-bottom: 1px solid #222;
        position: relative;
        overflow: hidden;
    }
    
    header::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--red), transparent);
        animation: pulse 4s ease-in-out infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 0.3; }
        50% { opacity: 1; }
    }
    
    .sidebar {
        background: var(--black);
        overflow-y: auto;
        padding: 20px;
        border-right: 1px solid #222;
        scrollbar-width: thin;
        scrollbar-color: var(--red) transparent;
    }
    
    .sidebar::-webkit-scrollbar {
        width: 4px;
    }
    
    .sidebar::-webkit-scrollbar-track {
        background: transparent;
    }
    
    .sidebar::-webkit-scrollbar-thumb {
        background-color: var(--red);
        border-radius: 2px;
    }
    
    main#word-explorer {
        background: var(--black);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        padding: 30px;
        animation: fadeIn 0.8s ease-out;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    .bottom-shelf {
        grid-row: 3;
        grid-column: span 2;
        display: grid;
        grid-template-columns: 1fr 450px;
        background: var(--red);
        gap: 1px;
        position: relative;
    }
    
    .bottom-shelf::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--red), transparent);
    }
    
    .editor-section {
        background: var(--dark-grey);
        display: flex;
        flex-direction: column;
        position: relative;
    }
    
    #editor {
        flex-grow: 1;
        padding: 30px;
        font-family: 'Special Elite', serif;
        font-size: 1.25rem;
        line-height: 1.6;
        outline: none;
        overflow-y: auto;
        background: #0d0d0d;
        color: #e0e0e0;
        caret-color: var(--red);
        border: none;
        transition: all 0.3s ease;
    }
    
    #editor:focus {
        box-shadow: inset 0 0 0 1px rgba(255, 0, 0, 0.3);
    }
    
    #editor::selection {
        background: rgba(255, 0, 0, 0.3);
        color: white;
    }
    
    .comms-console {
        background: var(--black);
        display: flex;
        flex-direction: column;
        font-family: 'Courier Prime', monospace;
        position: relative;
    }
    
    #chat-container {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        font-size: 12px;
        background: #080808;
        scroll-behavior: smooth;
    }
    
    .section-title {
        color: var(--red);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 2px;
        margin-bottom: 15px;
        border-bottom: 1px solid #222;
        padding-bottom: 8px;
        position: relative;
    }
    
    .section-title::after {
        content: '';
        position: absolute;
        bottom: -1px;
        left: 0;
        width: 60px;
        height: 1px;
        background: var(--red);
    }
    
    /* Definition Card Styles */
    .path-item {
        background: rgba(255, 255, 255, 0.02);
        border-left: 3px solid var(--red);
        padding: 15px;
        margin-bottom: 12px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }
    
    .path-item::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.1), transparent);
        transition: left 0.6s ease;
    }
    
    .path-item:hover::before {
        left: 100%;
    }
    
    .path-item:hover {
        background: rgba(255, 0, 0, 0.05);
        transform: translateX(4px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .path-word { 
        font-weight: bold; 
        font-size: 11px; 
        color: var(--red); 
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .path-word::before {
        content: '‚ñ∂';
        font-size: 8px;
        opacity: 0.7;
    }
    
    .path-definition { 
        font-family: 'Courier Prime', monospace; 
        font-size: 14px; 
        line-height: 1.5;
        color: #bbb; 
    }

    .german-logic { 
        border-left-color: var(--gold);
        background: rgba(212, 175, 55, 0.03);
    }
    
    .german-logic:hover {
        background: rgba(212, 175, 55, 0.08);
    }

    input {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid #333;
        color: var(--white);
        padding: 10px 12px;
        font-family: inherit;
        font-size: 12px;
        transition: all 0.3s ease;
        outline: none;
    }
    
    input:focus {
        border-color: var(--red);
        box-shadow: 0 0 0 1px rgba(255, 0, 0, 0.3);
        background: rgba(255, 0, 0, 0.05);
    }
    
    input::placeholder {
        color: #555;
        font-style: italic;
    }
    
    button {
        background: transparent;
        border: 1px solid #333;
        color: var(--white);
        padding: 10px 20px;
        font-family: inherit;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        cursor: pointer;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    button::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        border-radius: 50%;
        background: rgba(255, 0, 0, 0.2);
        transform: translate(-50%, -50%);
        transition: width 0.6s, height 0.6s;
    }
    
    button:hover::before {
        width: 200px;
        height: 200px;
    }
    
    button:hover { 
        background: var(--red); 
        color: white;
        border-color: var(--red);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 0, 0, 0.2);
    }
    
    button:active {
        transform: translateY(0);
    }

    #splash-screen {
        position: fixed; 
        inset: 0; 
        background: #000; 
        z-index: 5000;
        display: flex; 
        flex-direction: column; 
        align-items: center; 
        justify-content: center;
        text-align: center; 
        border: 12px solid var(--red); 
        cursor: pointer;
        animation: splashFade 0.5s ease-out;
    }
    
    @keyframes splashFade {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .synonym-chip {
        display: inline-block;
        padding: 4px 12px;
        border: 1px solid #222;
        margin: 0 8px 8px 0;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.3s ease;
        background: rgba(255, 255, 255, 0.02);
    }
    
    .synonym-chip:hover { 
        border-color: var(--red); 
        color: var(--red);
        background: rgba(255, 0, 0, 0.05);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .synonym-chip:active {
        transform: translateY(0);
    }

    /* Typing cursor effect */
    .typing-cursor {
        display: inline-block;
        width: 2px;
        height: 1.2em;
        background: var(--red);
        margin-left: 2px;
        animation: blink 1s infinite;
        vertical-align: middle;
    }
    
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }

    /* Status indicators */
    .status-dot {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 6px;
        animation: pulse 2s infinite;
    }
    
    .status-online {
        background: #00ff00;
        box-shadow: 0 0 8px #00ff00;
    }
    
    .status-offline {
        background: #ff0000;
        box-shadow: 0 0 8px #ff0000;
    }
    
    .status-loading {
        background: var(--gold);
        box-shadow: 0 0 8px var(--gold);
    }

    /* Chat message styling */
    .chat-message {
        margin-bottom: 15px;
        padding: 12px 15px;
        border-radius: 4px;
        animation: messageSlide 0.3s ease-out;
        position: relative;
    }
    
    @keyframes messageSlide {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }
    
    .chat-user {
        background: rgba(255, 255, 255, 0.03);
        border-left: 3px solid #555;
        margin-left: 20px;
    }
    
    .chat-ai {
        background: rgba(255, 0, 0, 0.05);
        border-left: 3px solid var(--red);
        margin-right: 20px;
    }
    
    .chat-system {
        background: rgba(212, 175, 55, 0.05);
        border-left: 3px solid var(--gold);
        font-style: italic;
        color: #888;
    }
    
    .chat-error {
        background: rgba(255, 0, 0, 0.1);
        border-left: 3px solid #ff4444;
        color: #ff6666;
    }
    
    .chat-sender {
        font-weight: bold;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 5px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    /* Loading animations */
    .loading-pulse {
        animation: pulse 1.5s ease-in-out infinite;
    }
    
    .loading-rotate {
        animation: rotate 2s linear infinite;
    }
    
    @keyframes rotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }

    /* Responsive adjustments */
    @media (max-width: 1200px) {
        .app-grid {
            grid-template-columns: 280px 1fr;
        }
        
        .bottom-shelf {
            grid-template-columns: 1fr 400px;
        }
    }
    
    @media (max-width: 900px) {
        .app-grid {
            grid-template-columns: 1fr;
            grid-template-rows: 50px auto 1fr 400px 30px;
        }
        
        .sidebar {
            grid-row: 2;
            max-height: 300px;
        }
        
        main#word-explorer {
            grid-row: 3;
        }
        
        .bottom-shelf {
            grid-row: 4;
            grid-template-columns: 1fr;
            grid-template-rows: 250px 150px;
        }
    }

    /* Custom scrollbar for editor */
    #editor::-webkit-scrollbar {
        width: 6px;
    }
    
    #editor::-webkit-scrollbar-track {
        background: transparent;
    }
    
    #editor::-webkit-scrollbar-thumb {
        background: var(--red);
        border-radius: 3px;
    }
</style>
</head>
<body>

<div id="splash-screen" onclick="hideSplash()">
    <h1 class="text-red-600 text-7xl font-bold tracking-tighter mb-4 italic">LEXICON_2741</h1>
    <p class="text-zinc-600 animate-pulse tracking-[0.5em] uppercase text-xs">Deploying Webster-Germanic Logic Matrix</p>
    <p class="text-zinc-800 text-[9px] mt-8 uppercase">Click to Initialize Interface</p>
</div>

<div class="app-grid">
    <header>
        <div class="flex items-center gap-4">
            <div id="status-dot" class="status-dot status-online"></div>
            <h1 class="text-xs font-bold uppercase tracking-widest">LEXICON_STATION_v4.60</h1>
            <span id="status-text" class="text-[9px] text-zinc-600">CORE: ONLINE</span>
        </div>
        <div class="flex gap-4 items-center">
            <span id="word-count" class="text-[10px] text-zinc-500">0 WORDS</span>
            <button onclick="exportText()" class="text-[9px] px-4 py-1 border-zinc-800 text-red-600 font-bold hover:bg-red-600 hover:text-white">EXTRACT_LOG</button>
        </div>
    </header>
    
    <aside class="sidebar border-r border-zinc-900">
        <div class="mb-8">
            <div class="section-title">Word Query</div>
            <div class="flex gap-2 mb-4">
                <input type="text" id="word-search" placeholder="Enter query term..." class="flex-grow" onkeypress="if(event.key==='Enter') searchWord()">
                <button onclick="searchWord()">EXE</button>
            </div>
            <div class="text-[9px] text-zinc-700 uppercase leading-tight">Multi-source lexical analysis</div>
        </div>

        <div class="mb-8">
            <div class="section-title">OpenRouter Key</div>
            <input type="password" id="apiKey" placeholder="sk-or-v1-..." class="w-full mb-3" onchange="saveApiKey()">
            <button onclick="toggleKeyVisibility()" class="w-full text-[9px] mb-2">üëÅ TOGGLE VISIBILITY</button>
            <div class="text-[9px] text-zinc-700 uppercase leading-tight">Enables full AI dialectic & juxtaposition</div>
        </div>

        <div class="mb-8">
            <div class="section-title">Logic Trail</div>
            <div id="path-history" class="text-[10px] space-y-2 max-h-[200px] overflow-y-auto"></div>
        </div>

        <div class="mb-8">
            <div class="section-title">System Status</div>
            <div id="system-status" class="text-[9px] space-y-1">
                <div class="flex justify-between"><span>Webster 1913:</span><span class="text-green-500">READY</span></div>
                <div class="flex justify-between"><span>German Logic:</span><span class="text-green-500">READY</span></div>
                <div class="flex justify-between"><span>Datamuse API:</span><span class="text-green-500">ONLINE</span></div>
                <div class="flex justify-between"><span>AI Synthesis:</span><span id="ai-status-indicator" class="text-red-500">OFFLINE</span></div>
            </div>
        </div>

        <div>
            <div class="section-title">Quick Search</div>
            <div class="grid grid-cols-2 gap-2">
                <button onclick="searchWord('philosophy')" class="text-[9px]">PHILOSOPHY</button>
                <button onclick="searchWord('consciousness')" class="text-[9px]">CONSCIOUSNESS</button>
                <button onclick="searchWord('language')" class="text-[9px]">LANGUAGE</button>
                <button onclick="searchWord('memory')" class="text-[9px]">MEMORY</button>
                <button onclick="searchWord('logic')" class="text-[9px]">LOGIC</button>
                <button onclick="searchWord('truth')" class="text-[9px]">TRUTH</button>
            </div>
        </div>
    </aside>
    
    <main id="word-explorer">
        <div id="intro-msg">
            <h2 class="text-6xl font-bold tracking-tighter text-white mb-6">LOGOS_CORE</h2>
            <p class="text-zinc-500 max-w-xl text-lg font-serif leading-relaxed">
                Awaiting the activation of a word. The search will bridge Webster's 1913 definitions with Germanic logical counterparts and synonym-cluster logic.
                <br><br>
                <span class="text-sm">Enter a word above to begin lexical decomposition.</span>
            </p>
        </div>
        
        <div id="results-area" class="hidden">
            <div class="flex justify-between items-end mb-8 border-b border-zinc-800 pb-6">
                <div>
                    <h2 id="current-word" class="text-7xl font-bold tracking-tighter text-red-600 italic mb-2">WORD</h2>
                    <div id="word-info" class="flex gap-4 text-xs text-zinc-600">
                        <span id="word-type">PART OF SPEECH</span>
                        <span id="word-origin">ETYMOLOGY</span>
                        <span id="word-length">LENGTH: 0</span>
                    </div>
                </div>
                <div class="text-right">
                    <button onclick="speakWord()" class="text-[9px] px-3 py-1 mb-2">üîä SPEAK</button>
                    <button onclick="copyToClipboard()" class="text-[9px] px-3 py-1">üìã COPY</button>
                </div>
            </div>

            <div class="grid grid-cols-1 gap-8">
                <div>
                    <div class="section-title">I. Webster's Definition (1913 Logic)</div>
                    <div id="webster-target"></div>
                </div>

                <div>
                    <div class="section-title" style="color:var(--gold)">II. Germanic Bridge</div>
                    <div id="german-target"></div>
                </div>
                
                <div>
                    <div class="section-title">III. Synonym Logic & Semantic Cluster</div>
                    <div id="synonym-target" class="flex flex-wrap gap-2 mt-3"></div>
                </div>
            </div>
        </div>
    </main>
    
    <div class="bottom-shelf">
        <section class="editor-section">
            <div class="bg-red-800 text-white px-4 py-2 flex justify-between font-bold text-[10px] uppercase tracking-tighter">
                <div id="teletype">>> Manuscript_Editor_Ready<span class="typing-cursor"></span></div>
                <div>Format: Unabridged</div>
            </div>
            <div id="editor" contenteditable="true" spellcheck="false">Start your manuscript here...</div>
        </section>
        
        <aside class="comms-console">
            <div class="bg-zinc-900 text-[9px] p-3 text-zinc-500 uppercase flex justify-between border-b border-red-900">
                <span>AI Dialectic Console</span>
                <span id="ai-status" class="text-green-500 font-bold">READY</span>
            </div>
            <div id="chat-container">
                <div class="chat-message chat-system">
                    <div class="chat-sender">SYSTEM</div>
                    <div>Console active. You may ask general questions or use 'JUXTAPOSE' for conceptual synthesis.</div>
                </div>
            </div>
            <div class="p-3 bg-black border-t border-zinc-900">
                <div class="flex gap-2">
                    <input type="text" id="chat-input" placeholder="Enter query or juxtaposition request..." class="flex-grow text-[11px] p-2" onkeypress="if(event.key==='Enter') askAI()">
                    <button onclick="askAI()" class="text-[9px] px-4">ASK</button>
                    <button onclick="generateJuxtaposition()" class="text-[9px] bg-red-900 px-4 font-bold">JUXTAPOSE</button>
                </div>
            </div>
        </aside>
    </div>
    
    <footer class="col-span-2 bg-black flex justify-between items-center px-4 text-[9px] text-zinc-800 uppercase border-t border-zinc-900">
        <div>Lexicon 2741 // [Webster 1913] [German-Logic] [Datamuse-Synonym] [AI-Synthesis]</div>
        <div id="footer-status">¬© 2025 ALL_LOGIC_IS_LOCAL</div>
    </footer>
</div>

<script>
    // ==============================
    // CONFIGURATION & STATE
    // ==============================
    const SOURCES = {
        webster: "https://raw.githubusercontent.com/adambom/dictionary/master/dictionary.json",
        german: "https://raw.githubusercontent.com/hathibelagal/German-English-JSON-Dictionary/master/german_english.json"
    };

    let cache = { webster: null, german: null };
    let currentWord = '';
    let apiKey = localStorage.getItem('lexicon_api_key') || '';
    let wordHistory = JSON.parse(localStorage.getItem('lexicon_history') || '[]');

    // ==============================
    // INITIALIZATION
    // ==============================
    document.addEventListener('DOMContentLoaded', () => {
        // Load saved API key
        if (apiKey) {
            document.getElementById('apiKey').value = apiKey;
            updateAiStatus();
        }
        
        // Load history
        updateHistoryDisplay();
        
        // Start teletype effect
        typeStatus();
        
        // Auto-save editor
        setInterval(saveEditor, 5000);
        
        // Load initial editor content
        loadEditor();
    });

    function hideSplash() {
        const splash = document.getElementById('splash-screen');
        splash.style.opacity = '0';
        splash.style.transition = 'opacity 0.5s ease-out';
        setTimeout(() => {
            splash.style.display = 'none';
            document.getElementById('word-search').focus();
        }, 500);
    }

    // ==============================
    // DICTIONARY LOADER
    // ==============================
    async function loadData() {
        if (cache.webster) return true;
        
        updateStatus("LOADING DATASETS...", 'loading');
        
        try {
            const [w, g] = await Promise.all([
                fetch(SOURCES.webster).then(r => r.json()),
                fetch(SOURCES.german).then(r => r.json())
            ]);
            
            cache.webster = w;
            cache.german = g;
            updateStatus("SYSTEM: READY", 'online');
            return true;
        } catch (e) {
            console.error('Failed to load data:', e);
            updateStatus("SYSTEM: ERROR", 'offline');
            addChatMessage('SYSTEM', 'Failed to load dictionary datasets. Using limited functionality.', 'system');
            return false;
        }
    }

    // ==============================
    // MAIN SEARCH FUNCTION
    // ==============================
    async function searchWord(overrideWord = null) {
        const wordInput = document.getElementById('word-search');
        const word = (overrideWord || wordInput.value).trim().toLowerCase();
        
        if (!word) {
            showNotification('Enter a word to search', 'error');
            return;
        }

        // Update UI state
        currentWord = word;
        wordInput.value = word;
        document.getElementById('intro-msg').classList.add('hidden');
        document.getElementById('results-area').classList.remove('hidden');
        document.getElementById('current-word').textContent = word.toUpperCase();
        document.getElementById('word-length').textContent = `LENGTH: ${word.length}`;

        // Show loading state
        showLoadingState();

        // Load data if needed
        const dataLoaded = await loadData();
        if (!dataLoaded) {
            showErrorState('Failed to load dictionary data');
            return;
        }

        try {
            // Process all data sources in parallel
            const [websterResult, germanResult, synonymResult] = await Promise.allSettled([
                getWebsterDefinition(word),
                getGermanConnections(word),
                getSynonyms(word)
            ]);

            // Display results
            displayResults({
                webster: websterResult.status === 'fulfilled' ? websterResult.value : null,
                german: germanResult.status === 'fulfilled' ? germanResult.value : null,
                synonyms: synonymResult.status === 'fulfilled' ? synonymResult.value : null
            });

            // Update history
            updateWordHistory(word);
            
            // Add to chat log
            addChatMessage('SYSTEM', `Searched: ${word}`, 'system');

        } catch (error) {
            console.error('Search error:', error);
            showErrorState('Search failed');
        }
    }

    // ==============================
    // DATA PROCESSING FUNCTIONS
    // ==============================
    function getWebsterDefinition(word) {
        const def = cache.webster[word.toUpperCase()] || cache.webster[word];
        if (!def) return null;
        
        return {
            definition: def,
            formatted: `<div class="path-item" onclick="insertText('${word}')">
                <div class="path-word">Webster Primary</div>
                <div class="path-definition">${def}</div>
            </div>`
        };
    }

    function getGermanConnections(word) {
        const hits = [];
        
        // Search in German-English dictionary
        for (const [german, english] of Object.entries(cache.german)) {
            if (english.toLowerCase().includes(word)) {
                hits.push({ german, english });
                if (hits.length >= 3) break;
            }
        }
        
        // Also search German words that match
        if (hits.length === 0) {
            for (const [german, english] of Object.entries(cache.german)) {
                if (german.toLowerCase().includes(word)) {
                    hits.push({ german, english });
                    if (hits.length >= 2) break;
                }
            }
        }
        
        return {
            hits,
            formatted: hits.map(hit => `
                <div class="path-item german-logic" onclick="insertText('${hit.german}')">
                    <div class="path-word">German Logic: ${hit.german}</div>
                    <div class="path-definition">${hit.english}</div>
                </div>
            `).join('')
        };
    }

    async function getSynonyms(word) {
        try {
            const response = await fetch(`https://api.datamuse.com/words?rel_syn=${word}&max=20`);
            if (!response.ok) throw new Error('Datamuse API failed');
            
            const data = await response.json();
            return {
                words: data.map(item => item.word),
                formatted: data.slice(0, 15).map(item => `
                    <span class="synonym-chip" onclick="searchWord('${item.word}')">${item.word}</span>
                `).join('')
            };
        } catch (error) {
            console.warn('Datamuse error:', error);
            return { words: [], formatted: '<div class="text-zinc-700 italic">Synonym data unavailable</div>' };
        }
    }

    // ==============================
    // DISPLAY FUNCTIONS
    // ==============================
    function showLoadingState() {
        document.getElementById('webster-target').innerHTML = `
            <div class="path-item loading-pulse">
                <div class="path-word">Loading...</div>
                <div class="path-definition">Querying Webster 1913</div>
            </div>`;
            
        document.getElementById('german-target').innerHTML = `
            <div class="path-item german-logic loading-pulse">
                <div class="path-word">Loading...</div>
                <div class="path-definition">Searching Germanic connections</div>
            </div>`;
            
        document.getElementById('synonym-target').innerHTML = `
            <span class="synonym-chip loading-pulse">Loading synonyms...</span>`;
    }

    function displayResults(results) {
        // Webster definition
        document.getElementById('webster-target').innerHTML = 
            results.webster?.formatted || 
            `<div class="path-item"><div class="path-definition">No Webster definition found</div></div>`;
        
        // German connections
        document.getElementById('german-target').innerHTML = 
            results.german?.formatted || 
            `<div class="path-item"><div class="path-definition">No Germanic connections found</div></div>`;
        
        // Synonyms
        document.getElementById('synonym-target').innerHTML = 
            results.synonyms?.formatted || 
            `<div class="text-zinc-700 italic">No synonyms available</div>`;
        
        // Update word info
        updateWordInfo(results);
    }

    function updateWordInfo(results) {
        const infoDiv = document.getElementById('word-info');
        const type = results.webster?.definition?.match(/\b(noun|verb|adjective|adverb)\b/i)?.[0] || 'Unknown';
        document.getElementById('word-type').textContent = type.toUpperCase();
        
        // Simple etymology guess based on word structure
        const etymology = guessEtymology(currentWord);
        document.getElementById('word-origin').textContent = etymology;
    }

    function guessEtymology(word) {
        if (word.endsWith('tion') || word.endsWith('sion')) return 'Latin';
        if (word.endsWith('keit') || word.endsWith('heit')) return 'German';
        if (word.endsWith('ology') || word.endsWith('graphy')) return 'Greek';
        if (word.endsWith('able') || word.endsWith('ible')) return 'French/Latin';
        return 'Indo-European';
    }

    function showErrorState(message) {
        document.getElementById('webster-target').innerHTML = `
            <div class="path-item">
                <div class="path-word">Error</div>
                <div class="path-definition">${message}</div>
            </div>`;
        
        addChatMessage('ERROR', `Search failed for: ${currentWord}`, 'error');
    }

    // ==============================
    // AI FUNCTIONS
    // ==============================
    async function askAI() {
        const input = document.getElementById('chat-input');
        const query = input.value.trim();
        
        if (!query) {
            showNotification('Enter a question', 'error');
            return;
        }
        
        if (!apiKey) {
            showNotification('API key required for AI functions', 'error');
            document.getElementById('apiKey').focus();
            return;
        }
        
        input.value = '';
        addChatMessage('USER', query, 'user');
        
        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`,
                    "HTTP-Referer": window.location.origin,
                    "X-Title": "Lexicon 2741"
                },
                body: JSON.stringify({
                    model: "google/gemini-2.0-flash-001",
                    messages: [
                        {
                            role: "system",
                            content: "You are a philosophical lexicographer. Provide insightful analysis of word relationships, etymology, and conceptual connections. Be concise and poetic."
                        },
                        {
                            role: "user",
                            content: query
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 300
                })
            });
            
            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }
            
            const data = await response.json();
            const answer = data.choices[0].message.content;
            addChatMessage('AI', answer, 'ai');
            
        } catch (error) {
            console.error('AI error:', error);
            addChatMessage('ERROR', `AI service unavailable: ${error.message}`, 'error');
        }
    }

    async function generateJuxtaposition() {
        if (!apiKey) {
            showNotification('API key required for juxtaposition', 'error');
            document.getElementById('apiKey').focus();
            return;
        }
        
        const word = currentWord || 'philosophy';
        addChatMessage('SYSTEM', `Generating juxtaposition for: ${word}`, 'system');
        
        try {
            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${apiKey}`
                },
                body: JSON.stringify({
                    model: "google/gemini-2.0-flash-001",
                    messages: [{
                        role: "system",
                        content: "Create a powerful philosophical juxtaposition. Format: 'Concept1 √ó Concept2: Poetic explanation in one sentence.' Be insightful and concise."
                    }, {
                        role: "user",
                        content: `Juxtapose: ${word}`
                    }],
                    temperature: 0.9,
                    max_tokens: 100
                })
            });
            
            const data = await response.json();
            const result = data.choices[0].message.content;
            
            addChatMessage('AI', result, 'ai');
            insertText(result, true);
            
            // Add to juxtaposition display
            const juxDiv = document.createElement('div');
            juxDiv.className = 'path-item';
            juxDiv.innerHTML = `
                <div class="path-word">AI Juxtaposition</div>
                <div class="path-definition">${result}</div>
            `;
            juxDiv.onclick = () => insertText(result, true);
            
            const resultsArea = document.getElementById('results-area');
            if (!resultsArea.querySelector('.juxtaposition-section')) {
                const section = document.createElement('div');
                section.className = 'juxtaposition-section';
                section.innerHTML = '<div class="section-title">IV. AI Juxtapositions</div>';
                resultsArea.appendChild(section);
            }
            
            const section = resultsArea.querySelector('.juxtaposition-section');
            section.appendChild(juxDiv);
            
        } catch (error) {
            console.error('Juxtaposition error:', error);
            addChatMessage('ERROR', 'Juxtaposition failed', 'error');
        }
    }

    // ==============================
    // UTILITY FUNCTIONS
    // ==============================
    function addChatMessage(sender, message, type = 'system') {
        const container = document.getElementById('chat-container');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message chat-${type}`;
        messageDiv.innerHTML = `
            <div class="chat-sender">
                <span class="status-dot status-${type === 'ai' ? 'online' : type === 'error' ? 'offline' : 'loading'}"></span>
                ${sender}
            </div>
            <div>${message}</div>
        `;
        container.appendChild(messageDiv);
        container.scrollTop = container.scrollHeight;
    }

    function insertText(text, isAI = false) {
        const editor = document.getElementById('editor');
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        
        const span = document.createElement('span');
        span.style.color = isAI ? 'var(--red)' : 'var(--white)';
        span.style.fontWeight = isAI ? 'bold' : 'normal';
        span.textContent = ' ' + text + ' ';
        
        range.insertNode(span);
        range.setStartAfter(span);
        range.setEndAfter(span);
        selection.removeAllRanges();
        selection.addRange(range);
        
        editor.scrollTop = editor.scrollHeight;
        updateWordCount();
        saveEditor();
        
        showNotification('Text inserted', 'success');
    }

    function updateWordCount() {
        const text = document.getElementById('editor').innerText;
        const count = text.trim() ? text.trim().split(/\s+/).length : 0;
        document.getElementById('word-count').innerText = `${count} WORDS`;
    }

    function updateWordHistory(word) {
        if (!wordHistory.includes(word)) {
            wordHistory.unshift(word);
            if (wordHistory.length > 10) wordHistory.pop();
            localStorage.setItem('lexicon_history', JSON.stringify(wordHistory));
            updateHistoryDisplay();
        }
    }

    function updateHistoryDisplay() {
        const container = document.getElementById('path-history');
        container.innerHTML = wordHistory.map(word => `
            <div class="flex items-center gap-2 p-2 hover:bg-zinc-900 cursor-pointer rounded" onclick="searchWord('${word}')">
                <div class="w-2 h-2 bg-red-600 rounded-full"></div>
                <span class="text-xs">${word.toUpperCase()}</span>
            </div>
        `).join('');
    }

    function saveApiKey() {
        apiKey = document.getElementById('apiKey').value.trim();
        localStorage.setItem('lexicon_api_key', apiKey);
        updateAiStatus();
        showNotification('API key saved', 'success');
    }

    function toggleKeyVisibility() {
        const input = document.getElementById('apiKey');
        input.type = input.type === 'password' ? 'text' : 'password';
    }

    function updateAiStatus() {
        const indicator = document.getElementById('ai-status-indicator');
        const status = document.getElementById('ai-status');
        
        if (apiKey) {
            indicator.textContent = 'ONLINE';
            indicator.className = 'text-green-500';
            status.textContent = 'AI: READY';
        } else {
            indicator.textContent = 'OFFLINE';
            indicator.className = 'text-red-500';
            status.textContent = 'AI: DISABLED';
        }
    }

    function updateStatus(text, state = 'online') {
        const element = document.getElementById('status-text');
        const dot = document.getElementById('status-dot');
        
        element.textContent = text;
        dot.className = `status-dot status-${state}`;
    }

    function typeStatus() {
        const messages = [
            ">> System Initialized",
            ">> Webster 1913 Loaded",
            ">> German Logic Active",
            ">> Datamuse Online",
            ">> AI Synthesis Ready"
        ];
        
        let index = 0;
        const teletype = document.getElementById('teletype');
        
        function type() {
            teletype.textContent = messages[index] + ' ';
            index = (index + 1) % messages.length;
        }
        
        type();
        setInterval(type, 3000);
    }

    function saveEditor() {
        const content = document.getElementById('editor').innerHTML;
        localStorage.setItem('lexicon_editor', content);
    }

    function loadEditor() {
        const saved = localStorage.getItem('lexicon_editor');
        if (saved) {
            document.getElementById('editor').innerHTML = saved;
            updateWordCount();
        }
    }

    function exportText() {
        const text = document.getElementById('editor').innerText;
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `lexicon_2741_${new Date().toISOString().slice(0,10)}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showNotification('Text exported', 'success');
    }

    function copyToClipboard() {
        if (!currentWord) return;
        navigator.clipboard.writeText(currentWord);
        showNotification('Word copied to clipboard', 'success');
    }

    function speakWord() {
        if (!currentWord || !window.speechSynthesis) return;
        const utterance = new SpeechSynthesisUtterance(currentWord);
        utterance.rate = 0.8;
        utterance.pitch = 1;
        speechSynthesis.speak(utterance);
    }

    function showNotification(message, type = 'info') {
        // Create notification element
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 px-4 py-2 rounded text-xs font-bold uppercase tracking-wider z-50 
            ${type === 'error' ? 'bg-red-900 text-red-200' : 
              type === 'success' ? 'bg-green-900 text-green-200' : 
              'bg-zinc-900 text-zinc-200'}`;
        notification.textContent = message;
        notification.style.transform = 'translateX(100%)';
        notification.style.transition = 'transform 0.3s ease';
        
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 10);
        
        // Remove after delay
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                document.body.removeChild(notification);
            }, 300);
        }, 3000);
    }

    // Auto-focus search on page load
    window.addEventListener('load', () => {
        setTimeout(() => {
            if (document.getElementById('splash-screen').style.display !== 'none') {
                document.getElementById('word-search').focus();
            }
        }, 100);
    });
</script>
</body>
</html>
