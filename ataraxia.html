<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=1024, initial-scale=1.0">
  <title>Ataraxia - World Building</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/three@0.159.0/build/three.module.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Olivetti', 'Courier New', monospace;
      height: 100vh;
      overflow: hidden;
      background: #1a1a1a;
      color: #e0e0e0;
    }

    /* Import default Olivetti font */
    @font-face {
      font-family: 'Olivetti';
      src: url('https://cdn.jsdelivr.net/gh/ghostm68/eg/fonts/olivetti-typewriter-regular.otf') format('opentype');
      font-weight: normal;
      font-style: normal;
    }

    /* Three.js Canvas for Effects */
    #effects-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      position: relative;
      z-index: 2;
    }

    /* Header */
    .app-header {
      background: #2a2a2a;
      color: #e0e0e0;
      padding: 10px 15px;
      text-align: center;
      border-bottom: 1px solid #444;
      z-index: 1000;
      flex-shrink: 0;
      position: relative;
    }

    .main-title {
      font-family: 'Olivetti', 'Courier New', monospace;
      font-size: 1.8em;
      margin: 0;
    }

    .subtitle {
      font-family: 'Olivetti', 'Courier New', monospace;
      font-size: 0.9em;
      opacity: 0.9;
    }

    /* Main Content - Split Screen */
    .main-content {
      display: flex;
      flex: 1;
      overflow: hidden;
      flex-direction: row-reverse;
    }

    /* Map Section */
    .map-section {
      flex: 1;
      position: relative;
      border-left: 1px solid #444;
    }

    #map {
      width: 100%;
      height: 100%;
    }

    .map-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      display: flex;
      gap: 5px;
    }

    .map-btn {
      background: rgba(42, 42, 42, 0.9);
      border: 1px solid #00aaff;
      border-radius: 5px;
      padding: 8px 12px;
      cursor: pointer;
      font-family: 'Olivetti', 'Courier New', monospace;
      font-size: 0.8em;
      color: #e0e0e0;
    }

    /* Writing Section */
    .writing-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #2a2a2a;
    }

    .writing-header {
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 10px 15px;
      font-family: 'Olivetti', 'Courier New', monospace;
      font-weight: bold;
      flex-shrink: 0;
      border-bottom: 1px solid #444;
    }

    #writing-area {
      flex: 1;
      width: 100%;
      border: none;
      padding: 15px;
      background: #1a1a1a;
      resize: none;
      outline: none;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
      color: #e0e0e0;
    }

    .writing-tools {
      background: #1a1a1a;
      padding: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      flex-shrink: 0;
      border-top: 1px solid #444;
    }

    .writing-tools button {
      padding: 8px 12px;
      background: #2a2a2a;
      border: 1px solid #00aaff;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8em;
      color: #e0e0e0;
      flex: 1;
      min-width: 120px;
    }

    /* Full Page Street Map Panel */
    #street-map-panel {
      position: fixed;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      z-index: 1002;
      transition: left 0.4s ease;
      display: flex;
      flex-direction: column;
    }

    #street-map-panel.active {
      left: 0;
    }

    #street-map {
      flex: 1;
      width: 100%;
    }

    .street-map-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      background: #2a2a2a;
      border-bottom: 1px solid #444;
      color: #e0e0e0;
    }

    .street-map-controls {
      display: flex;
      gap: 10px;
      padding: 15px;
      background: #2a2a2a;
      border-bottom: 1px solid #444;
    }

    .street-map-btn {
      padding: 10px 15px;
      background: #1a1a1a;
      border: 1px solid #00aaff;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      color: #e0e0e0;
    }

    /* Settings Panel */
    #settings-panel {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 400px;
      max-height: 80vh;
      background: #2a2a2a;
      border: 2px solid #00aaff;
      border-radius: 8px;
      padding: 20px;
      z-index: 1001;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
      display: none;
    }

    .settings-group {
      margin-bottom: 15px;
    }

    .settings-group label {
      display: block;
      margin-bottom: 5px;
      color: #e0e0e0;
    }

    .settings-group select, .settings-group input {
      width: 100%;
      padding: 8px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #1a1a1a;
      color: #e0e0e0;
      font-family: inherit;
    }

    input[type="range"] {
      accent-color: #00aaff;
    }

    .close-btn {
      background: #00aaff;
      color: #1a1a1a;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
      font-family: inherit;
      font-weight: bold;
      width: 100%;
    }

    .credits-section {
      margin-top: 20px;
      padding: 15px;
      background: rgba(0, 170, 255, 0.1);
      border-radius: 5px;
      font-size: 0.8em;
    }

    .export-note {
      color: #00aaff;
      font-style: italic;
      margin-top: 10px;
      padding: 10px;
      background: rgba(0, 170, 255, 0.1);
      border-left: 3px solid #00aaff;
    }

    /* Location Inspiration */
    #location-inspiration {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 400px;
      background: #2a2a2a;
      border: 2px solid #00aaff;
      border-radius: 8px;
      padding: 20px;
      z-index: 1001;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      display: none;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .main-content {
        flex-direction: column;
      }
      
      .writing-section {
        order: 1;
        flex: 0.6;
        border-bottom: 1px solid #444;
      }
      
      .map-section {
        order: 2;
        flex: 0.4;
        border-left: none;
      }
      
      .writing-tools {
        flex-direction: column;
      }
      
      .writing-tools button {
        min-width: auto;
      }
    }

    /* Remove Leaflet attribution */
    .leaflet-control-attribution {
      display: none !important;
    }

    /* Street map pin styling */
    .street-pin {
      background: rgba(0, 170, 255, 0.8);
      color: #1a1a1a;
      padding: 8px 12px;
      border-radius: 15px;
      font-family: 'Olivetti', 'Courier New', monospace;
      font-size: 12px;
      border: 2px solid white;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <!-- Three.js Effects Container -->
  <div id="effects-container"></div>

  <div class="app-container">
    <!-- Header -->
    <div class="app-header">
      <div class="main-title">Ataraxia</div>
      <div class="subtitle">World Building Sanctuary</div>
    </div>

    <!-- Main Split Screen Content -->
    <div class="main-content">
      <!-- Map Section -->
      <div class="map-section">
        <div id="map"></div>
        <div class="map-controls">
          <button class="map-btn" id="settings-btn">Settings</button>
          <button class="map-btn" id="inspiration-btn">Get Inspired</button>
          <button class="map-btn" id="show-street-map">Street Map</button>
        </div>
      </div>

      <!-- Writing Section -->
      <div class="writing-section">
        <div class="writing-header">
          üìù Your World Awaits...
        </div>
        <textarea id="writing-area" placeholder="Begin your world-building journey here...&#10;&#10;Click 'Get Inspired' for location prompts, or create your own stories."></textarea>
        <div class="writing-tools">
          <button id="generate-poem">Generate Poem</button>
          <button id="save-location">Pin to Main Map</button>
          <button id="clear-text">Clear</button>
          <button id="export-text">Export Text</button>
        </div>
      </div>
    </div>

    <!-- Full Page Street Map Panel -->
    <div id="street-map-panel">
      <div class="street-map-header">
        <h3>üó∫Ô∏è Street Map - Click to Add Location to Text</h3>
        <button class="close-btn" id="close-street-map" style="width: auto;">Close Street Map</button>
      </div>
      <div class="street-map-controls">
        <button class="street-map-btn" id="insert-coordinates">Insert Coordinates</button>
        <button class="street-map-btn" id="insert-address">Insert Address</button>
        <button class="street-map-btn" id="clear-street-pins">Clear Pins</button>
      </div>
      <div id="street-map"></div>
    </div>

    <!-- Location Inspiration Modal -->
    <div id="location-inspiration">
      <h3>üìç Location Inspiration</h3>
      <p id="location-info"></p>
      <button id="use-inspiration">Use in Writing</button>
      <button class="close-btn" id="close-inspiration">Close</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-panel">
      <h3>Ataraxia Settings</h3>
      
      <div class="settings-group">
        <label for="map-theme">Map Theme:</label>
        <select id="map-theme">
          <option value="dark" selected>Dark</option>
          <option value="light">Light</option>
          <option value="satellite">Satellite</option>
        </select>
      </div>

      <div class="settings-group">
        <label for="font-family">Font Family:</label>
        <select id="font-family">
          <!-- Dynamically populated -->
        </select>
      </div>

      <div class="settings-group">
        <label for="font-size">Font Size: <span id="font-size-value" style="color: #00aaff;">14px</span></label>
        <input type="range" id="font-size" min="12" max="24" value="14">
      </div>

      <div class="settings-group">
        <label for="visual-effect">Visual Effect:</label>
        <select id="visual-effect">
          <option value="none">None</option>
          <option value="particles">Particles</option>
          <option value="holographic">Holographic</option>
        </select>
      </div>

      <div class="credits-section">
        <h4>Credits & Technology</h4>
        <p><strong>Ataraxia World Building Tool</strong></p>
        <p><strong>3D Visual Effects:</strong> Particle systems and holographic shaders powered by Three.js</p>
        <p><strong>Mapping:</strong> Leaflet with OpenStreetMap & CartoDB</p>
        <p><strong>Fonts:</strong> Various typefaces from the Olivetti collection</p>
        
        <div class="export-note">
          <strong>Screen Recording Notice:</strong> The 3D visual effects (particles, holographic displays) are rendered in real-time using WebGL and exist only within this browser session. They will not appear in text exports but can be captured via screen recording software for presentations or personal use.
        </div>
      </div>

      <button class="close-btn" id="close-settings">Apply & Close</button>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // Global or widely accessible variables
    let scene, camera, renderer, currentEffect = 'none';
    let effectObjects = [];
    let particleSystem = null;

    let map; // Declare map globally
    let currentTileLayer; // Declare currentTileLayer globally
    const tileLayers = { // Make tileLayers globally accessible too
      dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'),
      light: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19
      }),
      satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}')
    };

    // Font list from your GitHub repository
    const fontList = [
      { name: "Olivetti Typewriter", file: "olivetti-typewriter-regular.otf" },
      { name: "Antiqua Outline", file: "Antiqua-Outline.otf" },
      { name: "Calligraph", file: "Calligraph.otf" },
      { name: "Hazard", file: "Hazard.otf" },
      { name: "Typewriter Serial", file: "Typewriter-Serial.otf" }
    ];

    // Street map variables
    let streetMap = null;
    let streetPins = [];
    let currentStreetPin = null;

    document.addEventListener('DOMContentLoaded', async () => {
      // Initialize Map with no attribution
      map = L.map('map', { // Assign to global map
        attributionControl: false
      }).setView([37.8, -96], 4);

      currentTileLayer = tileLayers.dark; // Assign to global currentTileLayer
      currentTileLayer.addTo(map);

      // Initialize Three.js
      initThreeJS();
      initEffects();

      // Initialize font selector
      initFontSelector();

      // UI Elements
      const writingArea = document.getElementById('writing-area');
      const settingsBtn = document.getElementById('settings-btn');
      const inspirationBtn = document.getElementById('inspiration-btn');
      const showStreetMapBtn = document.getElementById('show-street-map');
      const closeStreetMapBtn = document.getElementById('close-street-map');
      const streetMapPanel = document.getElementById('street-map-panel');
      const settingsPanel = document.getElementById('settings-panel');
      const closeSettings = document.getElementById('close-settings');
      const visualEffectSelect = document.getElementById('visual-effect');
      // Removed insertCoordinatesBtn, insertAddressBtn, clearStreetPinsBtn from here
      // as they are handled by global functions or dynamic popup events.

      // Street Map
      showStreetMapBtn.addEventListener('click', () => {
        streetMapPanel.classList.add('active');
        if (!streetMap) {
          initStreetMap();
        }
        // Invalidate size to ensure map renders correctly after panel becomes active
        if (streetMap) {
            setTimeout(() => { // Give CSS transition time
                streetMap.invalidateSize();
            }, 300);
        }
      });

      closeStreetMapBtn.addEventListener('click', () => {
        streetMapPanel.classList.remove('active');
      });

      function initStreetMap() {
        streetMap = L.map('street-map', {
          attributionControl: false
        }).setView(map.getCenter(), Math.min(map.getZoom() + 2, 18));
        
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19
        }).addTo(streetMap);

        // Add click event to street map for pinning
        streetMap.on('click', function(e) {
          addStreetPin(e.latlng);
        });
      }

      function addStreetPin(latlng) {
        // Remove previous temporary pin
        if (currentStreetPin) {
          streetMap.removeLayer(currentStreetPin);
        }

        // Add new pin
        currentStreetPin = L.marker(latlng, {
          icon: L.divIcon({
            className: 'street-pin',
            html: 'üìç',
            iconSize: [30, 30],
            iconAnchor: [15, 30]
          })
        }).addTo(streetMap);

        // Store the pin - if you only want ONE current pin, don't push to streetPins
        // If you want multiple pins, keep this, but then 'currentStreetPin' logic needs adjustment
        // For now, assuming you only want one interactive pin at a time for insertion
        // If you want multiple, you'd iterate through streetPins for clearStreetPins
        // and currentStreetPin would just be the *last added*.
        streetPins.push(currentStreetPin);
        
        // Show popup with options
        const popupContent = `
          <div style="color: #1a1a1a;">
            <strong>Location Selected</strong><br>
            Lat: ${latlng.lat.toFixed(6)}<br>
            Lng: ${latlng.lng.toFixed(6)}<br>
            <button class="popup-insert-coords" style="margin: 5px; padding: 5px; background: #00aaff; color: white; border: none; border-radius: 3px; cursor: pointer;">Insert Coordinates</button>
            <button class="popup-insert-address" style="margin: 5px; padding: 5px; background: #00aaff; color: white; border: none; border-radius: 3px; cursor: pointer;">Insert Address</button>
          </div>
        `;

        currentStreetPin.bindPopup(popupContent).openPopup();

        // Add event listeners to buttons *after* the popup is opened and rendered
        currentStreetPin.getPopup().on('contentupdate', function() {
            const popupDiv = this.getElement();
            if (popupDiv) {
                const insertCoordsButton = popupDiv.querySelector('.popup-insert-coords');
                const insertAddressButton = popupDiv.querySelector('.popup-insert-address');

                if (insertCoordsButton) {
                    insertCoordsButton.onclick = window.insertCoordinates; // Reference the global function
                }
                if (insertAddressButton) {
                    insertAddressButton.onclick = window.insertAddress; // Reference the global function
                }
            }
        });
      }

      // Street map button handlers (these buttons should now work)
      // If you have these buttons in your HTML for the streetMapPanel, ensure their IDs match
      // For instance: <button id="insert-coordinates">Insert Coordinates</button>
      document.getElementById('insert-coordinates').addEventListener('click', window.insertCoordinates);
      document.getElementById('insert-address').addEventListener('click', window.insertAddress);
      document.getElementById('clear-street-pins').addEventListener('click', window.clearStreetPins);


      // Settings
      settingsBtn.addEventListener('click', () => {
        settingsPanel.style.display = 'block';
      });

      closeSettings.addEventListener('click', () => {
        settingsPanel.style.display = 'none';
        window.applySettings(); // Call the global applySettings
      });

      // Visual Effects
      visualEffectSelect.addEventListener('change', (e) => {
        currentEffect = e.target.value;
        updateEffects();
      });

      // Writing Tools
      document.getElementById('generate-poem').addEventListener('click', () => {
        const poems = [
          "The mountains stand in silent grace,\nTheir shadows fall on time and space.\nRivers weave through ancient stone,\nIn whispered tales of lands unknown.",
          "Where ocean meets the waiting shore,\nAnd waves crash with their endless roar.\nThe salt-kissed air, the seabird's cry,\nBeneath the vast and cloud-strewn sky.",
          "Through forest deep where shadows dance,\nThe sunlight steals a fleeting glance,\nAmong the trees, a world apart,\nWhere nature weaves her living art."
        ];
        writingArea.value += '\n\n' + poems[Math.floor(Math.random() * poems.length)];
      });

      document.getElementById('save-location').addEventListener('click', () => {
        const center = map.getCenter();
        if (writingArea.value.trim()) {
          const pin = L.marker(center, {
            icon: L.divIcon({
              className: 'location-pin',
              html: 'üìå',
              iconSize: [30, 30],
              iconAnchor: [15, 30]
            })
          }).addTo(map);
          
          pin.bindPopup(`<strong>Saved Note:</strong><br>${writingArea.value.substring(0, 100)}...`);
          alert('Note pinned to main map!');
        } else {
          alert('Please write something first!');
        }
      });

      document.getElementById('clear-text').addEventListener('click', () => {
        if (confirm('Clear all text?')) {
          writingArea.value = '';
        }
      });

      document.getElementById('export-text').addEventListener('click', () => {
        const text = writingArea.value;
        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'ataraxia-notes.txt';
        a.click();
        URL.revokeObjectURL(url);
      });

      // Location Inspiration
      const locationInspiration = document.getElementById('location-inspiration');
      const locationInfo = document.getElementById('location-info');
      const useInspiration = document.getElementById('use-inspiration');
      const closeInspiration = document.getElementById('close-inspiration');

      inspirationBtn.addEventListener('click', () => {
        getRandomLocationInspiration();
      });

      useInspiration.addEventListener('click', () => {
        writingArea.value += '\n\n' + locationInfo.textContent;
        locationInspiration.style.display = 'none';
      });

      closeInspiration.addEventListener('click', () => {
        locationInspiration.style.display = 'none';
      });

      function getRandomLocationInspiration() {
        const prompts = [
          "Describe a hidden civilization in these mountains",
          "What magical creatures live in these forests?",
          "Create a legend about this river's origin",
          "What secrets does this coastline hold?",
          "Design a city that could thrive in this landscape",
          "What ancient ruins might be buried here?",
          "Describe the sounds and smells of this place at dawn",
          "What adventures await explorers in this terrain?",
          "Create a myth about how these lands were formed",
          "What would daily life be like for people living here?"
        ];
        
        const terrains = [
          "majestic mountain ranges",
          "rolling hills and valleys", 
          "dense ancient forests",
          "vast open plains",
          "coastal landscapes",
          "desert expanses",
          "river deltas",
          "frozen wilderness",
          "tropical islands",
          "urban landscapes"
        ];
        
        const terrain = terrains[Math.floor(Math.random() * terrains.length)];
        const prompt = prompts[Math.floor(Math.random() * prompts.length)];
        
        locationInfo.innerHTML = `
          <strong>A landscape of ${terrain}</strong><br><br>
          <em>Writing Prompt:</em><br>
          ${prompt}
        `;
        
        locationInspiration.style.display = 'block';
      }

      // Close modals when clicking outside
      window.addEventListener('click', (e) => {
        if (e.target === settingsPanel) {
          settingsPanel.style.display = 'none';
          window.applySettings(); // Apply settings if clicked outside
        }
        if (e.target === locationInspiration) {
          locationInspiration.style.display = 'none';
        }
      });
    }); // End DOMContentLoaded

    // Street Map Functions (moved outside DOMContentLoaded to be global)
    window.insertCoordinates = function() { // Make global
      if (!currentStreetPin) return;
      
      const latlng = currentStreetPin.getLatLng();
      const coords = `[Location: ${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}]`;
      insertTextAtCursor(coords);
      
      // Close street map after insertion if desired
      // document.getElementById('street-map-panel').classList.remove('active');
    }

    window.insertAddress = function() { // Make global
      if (!currentStreetPin) return;
      
      const latlng = currentStreetPin.getLatLng();
      // Simple address format - in a real app you'd use reverse geocoding
      const address = `[Near: ${latlng.lat.toFixed(4)}¬∞N, ${latlng.lng.toFixed(4)}¬∞W]`;
      insertTextAtCursor(address);
    }

    window.clearStreetPins = function() { // Make global
      streetPins.forEach(pin => {
        if (streetMap) streetMap.removeLayer(pin);
      });
      streetPins = [];
      currentStreetPin = null;
    }

    function insertTextAtCursor(text) {
      const textarea = document.getElementById('writing-area');
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      
      const before = textarea.value.substring(0, start);
      const after = textarea.value.substring(end);
      
      textarea.value = before + text + after;
      textarea.selectionStart = textarea.selectionEnd = start + text.length;
      textarea.focus();
    }

    // Three.js Functions
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      document.getElementById('effects-container').appendChild(renderer.domElement);

      camera.position.z = 5;
    }

    function initEffects() {
      animate();
    }

    function createParticleEffect() {
      clearEffects();
      
      const particleCount = 1000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 10;
        positions[i + 1] = (Math.random() - 0.5) * 10;
        positions[i + 2] = (Math.random() - 0.5) * 5;

        colors[i] = Math.random() * 0.5 + 0.5;
        colors[i + 1] = Math.random() * 0.3 + 0.7;
        colors[i + 2] = Math.random() * 0.5 + 0.5;
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.8
      });

      particleSystem = new THREE.Points(geometry, material);
      scene.add(particleSystem);
      effectObjects.push(particleSystem);
    }

    function createHolographicEffect() {
      clearEffects();
      
      const gridGeometry = new THREE.BoxGeometry(4, 2, 0.1);
      const gridMaterial = new THREE.MeshBasicMaterial({
        color: 0x00aaff,
        wireframe: true,
        transparent: true,
        opacity: 0.3
      });
      
      const grid = new THREE.Mesh(gridGeometry, gridMaterial);
      scene.add(grid);
      effectObjects.push(grid);

      for (let i = 0; i < 20; i++) {
        const geometry = new THREE.IcosahedronGeometry(0.1, 0);
        const material = new THREE.MeshBasicMaterial({
          color: 0x00aaff,
          transparent: true,
          opacity: 0.5
        });
        const mesh = new THREE.Mesh(geometry, material);
        
        mesh.position.x = (Math.random() - 0.5) * 3;
        mesh.position.y = (Math.random() - 0.5) * 2;
        mesh.position.z = (Math.random() - 0.5) * 2;
        
        scene.add(mesh);
        effectObjects.push(mesh);
      }
    }

    function clearEffects() {
      effectObjects.forEach(obj => scene.remove(obj));
      effectObjects = [];
      particleSystem = null;
    }

    function updateEffects() {
      switch(currentEffect) {
        case 'particles':
          createParticleEffect();
          break;
        case 'holographic':
          createHolographicEffect();
          break;
        case 'none':
          clearEffects();
          break;
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      if (currentEffect === 'particles' && particleSystem) {
        particleSystem.rotation.x += 0.001;
        particleSystem.rotation.y += 0.002;
        
        const positions = particleSystem.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] += Math.sin(Date.now() * 0.001 + i) * 0.001;
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
      }

      if (currentEffect === 'holographic') {
        effectObjects.forEach((obj, index) => {
          obj.rotation.y += 0.005;
          obj.position.y = Math.sin(Date.now() * 0.001 + index) * 0.1;
        });
      }

      renderer.render(scene, camera);
    }

    // Font Functions
    function initFontSelector() {
      const fontSelector = document.getElementById('font-family');
      fontList.forEach(font => {
        const option = document.createElement('option');
        option.value = font.file;
        option.textContent = font.name;
        option.selected = font.name === "Olivetti Typewriter";
        fontSelector.appendChild(option);
      });

      applyFont('olivetti-typewriter-regular.otf');
      
      fontSelector.addEventListener('change', (e) => {
        applyFont(e.target.value);
      });
    }

    function applyFont(fontFile) {
      const fontFace = `
        @font-face {
          font-family: 'SelectedFont';
          src: url('https://cdn.jsdelivr.net/gh/ghostm68/eg/fonts/${fontFile}') format('opentype');
        }
      `;
      
      let styleElement = document.getElementById('dynamic-font');
      if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = 'dynamic-font';
        document.head.appendChild(styleElement);
      }
      styleElement.textContent = fontFace;
      
      document.getElementById('writing-area').style.fontFamily = 'SelectedFont, "Courier New", monospace';
    }

    // Settings function (moved outside DOMContentLoaded to be global)
    window.applySettings = function() {
      const theme = document.getElementById('map-theme').value;
      const fontSize = document.getElementById('font-size').value;
      
      // Update map theme
      if (map && currentTileLayer && tileLayers[theme]) { // Check if map and layers exist
        map.removeLayer(currentTileLayer);
        currentTileLayer = tileLayers[theme];
        currentTileLayer.addTo(map);
      }
      
      document.getElementById('writing-area').style.fontSize = fontSize + 'px';
      document.getElementById('font-size-value').textContent = fontSize + 'px';
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

</body>
</html>
