
<!DOCTYPE html>
<html>
    
    <head><base href="https://wordstar-online.com/">
        <meta charset="UTF-8">
        <meta name="keywords" content="typewriter, writing, retro, vintage, text editor, AI, generative, creative writing">
        <meta name="description" content="Experience the nostalgia of a classic typewriter with Wordstar, a web-based app that combines vintage aesthetics with modern AI-powered writing tools. Generate creative text, experiment with different writing styles, and rediscover the joy of putting words on paper (virtually!).">
        <meta name="viewport" content="width=device-width, initial-scale=1.0"><title>WordStar Nexus - Modern Text Editor</title><style>
    body, html {
        height: 100%;
        margin: 0;
        font-family: Arial, sans-serif;
        background-color: #2d2d2d;
        color: #f0f0f0;
    }
    .container {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    #toolbar {
        background-color: #1e1e1e;
        padding: 10px;
        display: flex;
        justify-content: space-between;
    }
    #editor {
        flex-grow: 1;
        padding: 20px;
        font-size: 16px;
        line-height: 1.6;
        background-color: #1e1e1e;
        color: #f0f0f0;
        border: none;
        resize: none;
    }
    #statusbar {
        background-color: #cc0000;
        color: white;
        padding: 5px 10px;
        font-size: 14px;
    }
    button {
        background-color: #cc0000;
        color: white;
        border: none;
        padding: 5px 10px;
        margin-right: 5px;
        cursor: pointer;
    }
    button:hover {
        background-color: #990000;
    }
    #dictionary-select {
        margin-right: 10px;
    }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.3.1/jspdf.umd.min.js"></script>
</head>
<body>
<div class="container">
    <div id="toolbar">
    <div>
        <button onclick="newDocument()" style="background-color: #cc0000;">New</button>
        <button onclick="saveDocument()" style="background-color: #cc0000;">Save</button>
        <button onclick="exportTxt()" style="background-color: #cc0000;">Export TXT</button>
        <button onclick="exportRtf()" style="background-color: #cc0000;">Export RTF</button>
        <button onclick="exportPdf()" style="background-color: #cc0000;">Export PDF</button>
        <button onclick="insertPoeticParagraph()" style="background-color: #cc0000;">Insert Random Poetic Paragraph</button>
    </div>
    <div>
        <button onclick="openNotepad()" style="background-color: #cc0000;">Popup Notepad</button>
        <button onclick="insertRandomScientificWord()" style="background-color: #cc0000;">Random Word</button>
    </div>
</div>
    <div id="editor" style="display: flex; justify-content: space-between;">
    <div id="ace-editor" style="width: 80%;"></div>
    <div style="width: 18%; display: flex; flex-direction: column;">
        <div>
    <select id="ai-model-select" style="width: 100%; padding: 5px; margin-bottom: 5px;">
    <option value="gpt2">GPT-2</option>
    <option value="bert">BERT</option>
    <option value="t5">T5</option>
    <option value="roberta">RoBERTa</option>
    <option value="xlnet">XLNet</option>
    <option value="elmo">ELMo</option>
    <option value="distilbert">DistilBERT</option>
    <option value="albert">ALBERT</option>
    <option value="electra">ELECTRA</option>
    <option value="markov">Markov Chain</option>
    <option value="wordassociation">Word Association</option>
    <option value="randomsentence">Random Sentence Generator</option>
    <option value="gpt-neo">GPT-Neo</option>
    <option value="gpt-j">GPT-J</option>
    <option value="bloom">BLOOM</option>
    <option value="opt">OPT</option>
    <option value="llama">LLaMA</option>
    <option value="tensorflow">TensorFlow</option>
    <option value="pytorch">PyTorch</option>
    <option value="huggingface">Hugging Face Transformers</option>
    <option value="gemma-2b">Gemma 2B</option>
    <option value="gemma-7b">Gemma 7B</option>
    <option value="palm">PaLM</option>
    <option value="bard">Bard</option>
</select>
    <textarea id="ai-prompt" placeholder="Enter your prompt here" style="width: 100%; padding: 5px; margin-bottom: 5px; height: 60px;"></textarea>
    <button onclick="generateText()" style="width: 100%; background-color: #cc0000; color: white; border: none; padding: 5px 10px; cursor: pointer; font-size: 12px;">Create Text</button>
</div>
        <div id="dictionary-results" style="flex-grow: 1; overflow-y: auto; background-color: #2d2d2d; padding: 10px; border: 1px solid #444; font-size: 12px;">
    <div id="word-info" style="display: none;">
        <h3 id="word-title" style="color: #cc0000; margin-bottom: 10px;"></h3>
        <div id="word-definition" style="margin-bottom: 10px;"></div>
        <div id="word-etymology" style="margin-bottom: 10px; font-style: italic;"></div>
        <div id="word-thesaurus">
            <h4 style="color: #cc0000; margin-bottom: 5px;">Synonyms:</h4>
            <ul id="word-synonyms" style="list-style-type: none; padding-left: 0;"></ul>
        </div>
    </div>
    <div id="ai-response" style="white-space: pre-wrap;">To use the text generation feature:

1. Choose a language model from the dropdown menu.
2. Enter a prompt in the text area.
3. Click the "Create Text" button.

The text will be generated based on your input and the selected model. Here's a brief overview of the working models:

1. Markov Chain: Generates text based on statistical patterns from a predefined dataset.
2. Word Association: Creates text by following word associations from a custom dictionary.
3. Random Sentence Generator: Constructs simple sentences using predefined components.

These models will generate more than just repeating the prompt. Here's what to expect:

- Markov Chain: Produces a sequence of words based on probabilistic transitions.
- Word Association: Expands on the prompt by following associated words.
- Random Sentence Generator: Creates a completely new sentence each time.

The other AI models listed are currently offline simulations. In a full implementation, they would connect to more sophisticated language models.

Try different prompts and models to see varied results. The generated text will appear here after you click "Create Text".</div>
</div>
    </div>
</div>
    <div id="statusbar" style="background-color: #cc0000; display: flex; justify-content: space-between; align-items: center;">
    <span>WordStar Online - Ready</span>
    <span style="font-size: 12px;">Â© MMXXIV www.inkrealm.info</span>
</div>
</div>

<script>
    let editor;
    let aiEngines = {
        "gpt2": "GPT-2 (Offline)",
        "bert": "BERT (Offline)",
        "t5": "T5 (Offline)",
        "roberta": "RoBERTa (Offline)",
        "xlnet": "XLNet (Offline)",
        "elmo": "ELMo (Offline)",
        "distilbert": "DistilBERT (Offline)",
        "albert": "ALBERT (Offline)",
        "electra": "ELECTRA (Offline)",
        "markov": "Markov Chain",
        "wordassociation": "Word Association",
        "randomsentence": "Random Sentence Generator",
        "gpt-neo": "GPT-Neo (Offline)",
        "gpt-j": "GPT-J (Offline)",
        "bloom": "BLOOM (Offline)",
        "opt": "OPT (Offline)",
        "llama": "LLaMA (Offline)",
        "tensorflow": "TensorFlow (Offline)",
        "pytorch": "PyTorch (Offline)",
        "huggingface": "Hugging Face Transformers (Offline)",
        "gemma-2b": "Gemma 2B (Offline)",
        "gemma-7b": "Gemma 7B (Offline)",
        "palm": "PaLM (Offline)",
        "bard": "Bard (Offline)"
    };
    let notepadWindow = null;

    // Word associations for the Word Association generator
    const wordAssociations = {
        "sun": ["bright", "warm", "yellow", "sky", "summer"],
        "moon": ["night", "stars", "crescent", "lunar", "glow"],
        "tree": ["leaves", "branches", "forest", "green", "nature"],
        "water": ["ocean", "river", "blue", "liquid", "flow"],
        "fire": ["hot", "flame", "burn", "red", "smoke"]
    };

    // Expanded Markov chain data structure
    const markovChain = {
        "the": ["cat", "dog", "sun", "moon", "tree", "river", "mountain", "city", "book", "computer"],
        "cat": ["is", "sleeps", "meows", "purrs", "stretches", "jumps", "plays", "hunts", "naps", "scratches"],
        "dog": ["barks", "runs", "plays", "fetches", "wags", "sniffs", "chases", "guards", "obeys", "drools"],
        "sun": ["shines", "sets", "rises", "warms", "illuminates", "brightens", "scorches", "dazzles", "glows", "beams"],
        "moon": ["glows", "wanes", "waxes", "rises", "sets", "illuminates", "orbits", "reflects", "inspires", "changes"],
        "tree": ["grows", "sways", "blooms", "sheds", "provides", "reaches", "stands", "rustles", "shades", "photosynthesizes"],
        "river": ["flows", "meanders", "rushes", "erodes", "floods", "nourishes", "carries", "reflects", "babbles", "surges"],
        "mountain": ["towers", "looms", "challenges", "inspires", "protects", "erodes", "stands", "rises", "dominates", "beckons"],
        "city": ["bustles", "grows", "thrives", "expands", "evolves", "glows", "sleeps", "awakens", "pulsates", "changes"],
        "book": ["informs", "entertains", "inspires", "educates", "captivates", "challenges", "enlightens", "provokes", "comforts", "transports"],
        "computer": ["calculates", "processes", "stores", "displays", "connects", "analyzes", "assists", "learns", "crashes", "updates"],
        "is": ["sleeping", "running", "shining", "growing", "flowing", "towering", "bustling", "informing", "calculating", "changing"],
        "sleeps": ["on", "under", "beside", "peacefully", "soundly", "fitfully", "deeply", "lightly", "briefly", "comfortably"],
        "meows": ["loudly", "softly", "at", "persistently", "melodiously", "plaintively", "happily", "angrily", "hungrily", "sleepily"],
        "barks": ["at", "loudly", "excitedly", "fiercely", "playfully", "warningly", "joyfully", "continuously", "suddenly", "softly"],
        "shines": ["brightly", "warmly", "through", "upon", "brilliantly", "softly", "steadily", "dimly", "radiantly", "gloriously"],
        "flows": ["swiftly", "gently", "steadily", "turbulently", "peacefully", "rapidly", "slowly", "smoothly", "powerfully", "endlessly"],
        "towers": ["above", "majestically", "imposingly", "steadily", "silently", "menacingly", "protectively", "grandly", "solidly", "impressively"],
        "bustles": ["with", "energetically", "chaotically", "vibrantly", "noisily", "excitedly", "constantly", "hurriedly", "busily", "frenetically"],
        "informs": ["clearly", "concisely", "thoroughly", "accurately", "effectively", "engagingly", "objectively", "comprehensively", "succinctly", "reliably"],
        "calculates": ["rapidly", "accurately", "efficiently", "tirelessly", "precisely", "instantly", "continuously", "reliably", "automatically", "systematically"]
    };

    window.onload = function() {
        editor = ace.edit("ace-editor");
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode("ace/mode/text");
        editor.setOptions({
            fontSize: "14pt",
            wrap: true,
            printMargin: false
        });
        
        // Ensure the Ace editor resizes correctly
        editor.resize();

        // Update status bar to reflect offline status
        updateStatusBar("WordStar Online - Ready");
    }

    function newDocument() {
        editor.setValue("");
        updateStatusBar("New document created");
    }

    function saveDocument() {
        const content = editor.getValue();
        const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "document.txt";
        link.click();
        URL.revokeObjectURL(url);
        updateStatusBar("Document saved");
    }

    function exportTxt() {
        const content = editor.getValue();
        const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "document.txt";
        link.click();
        URL.revokeObjectURL(url);
        updateStatusBar("Document exported as TXT");
    }

    function exportRtf() {
        const content = editor.getValue();
        const rtfContent = `{\\rtf1\\ansi\\deff0\n${content.replace(/\n/g, "\\par\n")}\n}`;
        const blob = new Blob([rtfContent], {type: "application/rtf"});
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = "document.rtf";
        link.click();
        URL.revokeObjectURL(url);
        updateStatusBar("Document exported as RTF");
    }

    function exportPdf() {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        const content = editor.getValue();
        doc.text(content, 10, 10);
        doc.save("document.pdf");
        updateStatusBar("Document exported as PDF");
    }

    function insertRandomScientificWord() {
        const scientificWords = [
            "Mitochondria", "Photosynthesis", "Quantum entanglement", "Cytoplasm", "Neurotransmitter",
            "Thermodynamics", "Genome sequencing", "Electromagnetism", "Cellular respiration", "Higgs boson",
            "Relativity", "Plate tectonics", "Superconductivity", "Chromatography", "Nucleosynthesis",
            "Homeostasis", "Endocytosis", "Gravitational waves", "Electrophoresis", "Nanotechnology"
        ];
        
        const randomWord = scientificWords[Math.floor(Math.random() * scientificWords.length)];
        editor.insert(randomWord + " ");
        updateStatusBar("Inserted scientific term: " + randomWord);
    }

    function generateText() {
        const selectedModel = document.getElementById("ai-model-select").value;
        const prompt = document.getElementById("ai-prompt").value;
        
        let generatedText;
        
        switch(selectedModel) {
            case "markov":
                generatedText = generateMarkovText(prompt);
                break;
            case "wordassociation":
                generatedText = generateWordAssociationText(prompt);
                break;
            case "randomsentence":
                generatedText = generateRandomSentence();
                break;
            default:
                generatedText = simulateAIGeneration(selectedModel, prompt);
        }
        
        // Display the generated text in the former search result box
        const aiResponseElement = document.getElementById("ai-response");
        aiResponseElement.textContent = generatedText;
        
        updateStatusBar(`Text created using ${aiEngines[selectedModel]}`);
    }

    function generateMarkovText(prompt) {
        let words = prompt.split(" ");
        if (words.length === 0 || !markovChain[words[words.length - 1]]) {
            words = ["the"];
        }
        let result = words.join(" ");
        for (let i = 0; i < 30; i++) {
            let lastWord = words[words.length - 1].toLowerCase();
            let nextWords = markovChain[lastWord];
            if (!nextWords) break;
            let nextWord = nextWords[Math.floor(Math.random() * nextWords.length)];
            result += " " + nextWord;
            words.push(nextWord);
        }
        return result;
    }

    function generateWordAssociationText(prompt) {
        let words = prompt.split(" ");
        let result = prompt;
        for (let i = 0; i < 10; i++) {
            let lastWord = words[words.length - 1].toLowerCase();
            let associations = wordAssociations[lastWord];
            if (!associations) break;
            let nextWord = associations[Math.floor(Math.random() * associations.length)];
            result += " " + nextWord;
            words.push(nextWord);
        }
        return result;
    }

    function generateRandomSentence() {
        const subjects = ["The cat", "A dog", "The sun", "The moon", "A tree", "The river", "The mountain", "The city", "The book", "The computer"];
        const verbs = ["jumps", "shines", "barks", "grows", "glows", "flows", "towers", "bustles", "informs", "calculates"];
        const objects = ["over the fence", "in the sky", "at the mailman", "in the forest", "through the night", "down the valley", "above the clouds", "with excitement", "the reader", "complex data"];
        
        const subject = subjects[Math.floor(Math.random() * subjects.length)];
        const verb = verbs[Math.floor(Math.random() * verbs.length)];
        const object = objects[Math.floor(Math.random() * objects.length)];
        
        return `${subject} ${verb} ${object}.`;
    }

    function simulateAIGeneration(model, prompt) {
        // This is a simple simulation. In a real implementation, you would call an API here.
        const responses = {
            "gpt2": "GPT-2 generated text based on: ",
            "bert": "BERT analysis result: ",
            "t5": "T5 transformation output: ",
            "roberta": "RoBERTa's interpretation: ",
            "xlnet": "XLNet's generated sequence: ",
            "elmo": "ELMo's contextual representation: ",
            "distilbert": "DistilBERT's efficient output: ",
            "albert": "ALBERT's response: ",
            "electra": "ELECTRA's discriminative output: ",
            "gpt-neo": "GPT-Neo's generated content: ",
            "gpt-j": "GPT-J's creative output: ",
            "bloom": "BLOOM's multilingual response: ",
            "opt": "OPT's optimized text: ",
            "llama": "LLaMA's language model output: ",
            "tensorflow": "TensorFlow's processed result: ",
            "pytorch": "PyTorch's neural network output: ",
            "huggingface": "Hugging Face Transformers' generated text: ",
            "gemma-2b": "Gemma 2B's concise response: ",
            "gemma-7b": "Gemma 7B's more detailed output: ",
            "palm": "PaLM's large language model response: ",
            "bard": "Bard's AI-generated content: "
        };

        return responses[model] + prompt + "\n\nThis is a simulated response. In a real implementation, this would be generated by the AI model.\n\n";
    }

    function updateStatusBar(message) {
        const statusBarSpan = document.querySelector("#statusbar span:first-child");
        if (statusBarSpan) {
            statusBarSpan.textContent = message;
        }
    }

    function insertPoeticParagraph() {
        const poeticParagraphs = [
            "Whispers of the wind, through autumn leaves,\nCarry tales of time, that memory weaves.\nIn golden light, and shadows long,\nNature composes her twilight song.\nAs day surrenders to starry night,\nWe ponder life's beauty, fleeting and bright.",
            "Moonlit waves caress the shore,\nEchoing secrets from days of yore.\nSilver sands stretch far and wide,\nWhere dreams and reality collide.\nIn this moment, between earth and sky,\nWe glimpse eternity passing by.",
            "Amidst the urban jungle's roar,\nA flower breaks through concrete floor.\nResilience in vibrant hue,\nReminding us what life can do.\nIn chaos, beauty finds its way,\nA testament to brighter day.",
            "Mountains touch the azure sky,\nWhere eagles soar and spirits fly.\nAncient peaks, with wisdom old,\nStand sentinel o'er stories untold.\nIn their presence, we are small,\nYet part of something grand and tall.",
            "Through fields of gold and emerald green,\nA river winds, its path unseen.\nReflecting clouds and summer's glow,\nIt carries life where'er it flows.\nIn its journey to the sea,\nWe see our own life's odyssey."
        ];
        const randomParagraph = poeticParagraphs[Math.floor(Math.random() * poeticParagraphs.length)] + '\n\n';
        editor.insert(randomParagraph);
        updateStatusBar("Random poetic paragraph inserted");
    }

    function openNotepad() {
        if (notepadWindow === null || notepadWindow.closed) {
            notepadWindow = window.open('', 'Notepad', 'width=400,height=400');
            notepadWindow.document.write('<html><head><title>Popup</title></head>
  body, html {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
  background-color: #343541;
  height: 100%;
  overflow: hidden;
}

.container {
  display: flex;
  height: 100vh;
}

.sidebar {
  width: 250px;
  min-width: 250px;
  background-color: #202123;
  color: white;
  padding: 20px;
  overflow-y: auto;
}

.main-content {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  padding: 20px;
  overflow-y: auto;
}

.header {
  text-align: center;
  margin-bottom: 20px;
  color: white;
  position: relative;
}

.header h1 {
  margin-top: 0;
  margin-bottom: 10px;
}

.chat-area {
  flex-grow: 1;
  background-color: #40414f;
  border-radius: 5px;
  padding: 15px;
  overflow-y: auto;
  margin-bottom: 20px;
  color: white;
}

.footer {
  text-align: center;
  font-size: 12px;
  color: white;
  margin-top: 10px;
}

#userInput {
  width: 100%;
  padding: 10px;
  margin-bottom: 10px;
  background-color: #40414f;
  color: white;
  border: 1px solid #565869;
  border-radius: 5px;
  resize: vertical;
  min-height: 50px;
  max-height: 200px;
}

#sendButton {
  width: 100%;
  padding: 10px;
  background-color: #10a37f;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin-bottom: 10px;
}

#sendButton:hover {
  background-color: #1a7f64;
}

#modelSelect {
  width: 100%;
  padding: 10px;
  margin-bottom: 10px;
  background-color: #40414f;
  color: white;
  border: 1px solid #565869;
  border-radius: 5px;
}

.created-by {
  position: absolute;
  bottom: 10px;
  right: 20px;
  font-size: 12px;
  color: #ffffff;
}

.message {
  margin-bottom: 10px;
  padding: 8px;
  border-radius: 5px;
  word-wrap: break-word;
}

.user {
  background-color: #2a2b32;
}

.assistant {
  background-color: #343541;
}

.system {
  background-color: #444654;
  font-style: italic;
}

.loading-spinner {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 3px solid #ffffff;
  border-radius: 50%;
  border-top: 3px solid #10a37f;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.chat-history-item {
  cursor: pointer;
  padding: 10px;
  margin-bottom: 5px;
  background-color: #2a2b32;
  border-radius: 5px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: background-color 0.3s ease;
}

.chat-history-item:hover {
  background-color: #40414f;
}

.chat-history-item.selected {
  background-color: #40414f;
}

.chat-history-buttons {
  display: flex;
  gap: 5px;
}

.chat-history-button {
  background-color: #565869;
  color: white;
  border: none;
  border-radius: 3px;
  padding: 3px 6px;
  font-size: 10px;
  cursor: pointer;
}

.chat-history-button:hover {
  background-color: #6e7087;
}

.new-chat-button {
  width: 100%;
  padding: 10px;
  margin-bottom: 20px;
  background-color: #10a37f;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

.new-chat-button:hover {
  background-color: #1a7f64;
}

#debugButton {
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: #565869;
  color: white;
  border: none;
  border-radius: 3px;
  padding: 5px 10px;
  font-size: 12px;
  cursor: pointer;
}

#debugButton:hover {
  background-color: #6e7087;
}

.eyeball-button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
  padding: 0 5px;
}

.popup {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #40414f;
  padding: 20px;
  border-radius: 5px;
  z-index: 1000;
  max-width: 80%;
  max-height: 80%;
  overflow-y: auto;
}

.popup-content {
  color: white;
  white-space: pre-wrap;
}

.close-popup {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: white;
  font-size: 20px;
  cursor: pointer;
}

.overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 999;
}
</style></head><body>
<div class="container">
  <div class="sidebar">
    <button class="new-chat-button" id="newChatButton">New Chat</button>
    <div id="chatHistory"></div>
  </div>
  <div class="main-content">
    <div class="header">
      <h1>Chat with Every AI FREE</h1>
      <button id="debugButton">Debug</button>
    </div>
    <div class="chat-area" id="chat-area">
      <!-- Chat messages will be inserted here -->
    </div>
    <textarea id="userInput" placeholder="Type your message here..."></textarea>
    <button id="sendButton">Send</button>
    <select id="modelSelect">
      <option value="">Loading models...</option>
    </select>
    <div class="footer">
      Chat with Every AI FREE. Free Research Preview. Our goal is to make AI systems more natural and safe to interact with. Your feedback will help us improve.
    </div>
    <div class="created-by">Created by @laznin â¡</div>
  </div>
</div>

<div id="overlay" class="overlay"></div>
<div id="popup" class="popup">
  <button class="close-popup" onclick="closePopup()">Ã</button>
  <div id="popupContent" class="popup-content"></div>
</div>

<script>
const systemPrompt = `You are an AI assistant. Respond in a helpful, respectful, and honest manner.`;
let selectedModel = '';
let currentChatId = null;
let debugMode = false;

function generateUniqueId() {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

function addMessage(role, content) {
  const chatArea = document.getElementById('chat-area');
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${role}`;
  const prefix = role === 'user' ? 'User: ' : (role === 'assistant' ? 'AI: ' : '');
  messageDiv.textContent = prefix + content;
  chatArea.appendChild(messageDiv);
  chatArea.scrollTop = chatArea.scrollHeight;

  // Save message to local storage
  if (currentChatId) {
    let chats = JSON.parse(localStorage.getItem('aiChats')) || {};
    if (!chats[currentChatId]) {
      chats[currentChatId] = { messages: [], name: `Chat ${currentChatId.substr(0, 6)}...` };
    }
    chats[currentChatId].messages.push({role, content});
    localStorage.setItem('aiChats', JSON.stringify(chats));
    updateChatHistory();
  }
}

function addLoadingSpinner() {
  const chatArea = document.getElementById('chat-area');
  const spinnerDiv = document.createElement('div');
  spinnerDiv.className = 'message system';
  spinnerDiv.innerHTML = 'AI: <div class="loading-spinner"></div>';
  chatArea.appendChild(spinnerDiv);
  chatArea.scrollTop = chatArea.scrollHeight;
  return spinnerDiv;
}

function startNewChat() {
  currentChatId = generateUniqueId();
  document.getElementById('chat-area').innerHTML = '';
  addMessage('system', 'How can I assist you today?');
  updateChatHistory();
}

function updateChatHistory() {
  const chatHistory = document.getElementById('chatHistory');
  chatHistory.innerHTML = '';
  const chats = JSON.parse(localStorage.getItem('aiChats')) || {};
  Object.keys(chats).forEach(chatId => {
    const chatDiv = document.createElement('div');
    chatDiv.className = 'chat-history-item';
    if (chatId === currentChatId) {
      chatDiv.classList.add('selected');
    }
    
    const chatName = document.createElement('span');
    chatName.textContent = chats[chatId].name || `Chat ${chatId.substr(0, 6)}...`;
    chatDiv.appendChild(chatName);
    
    const buttonsDiv = document.createElement('div');
    buttonsDiv.className = 'chat-history-buttons';
    
    const renameButton = document.createElement('button');
    renameButton.textContent = 'Rename';
    renameButton.className = 'chat-history-button';
    renameButton.onclick = (e) => {
      e.stopPropagation();
      renameChat(chatId);
    };
    
    const deleteButton = document.createElement('button');
    deleteButton.textContent = 'Delete';
    deleteButton.className = 'chat-history-button';
    deleteButton.onclick = (e) => {
      e.stopPropagation();
      deleteChat(chatId);
    };
    
    if (debugMode) {
      const eyeballButton = document.createElement('button');
      eyeballButton.innerHTML = 'ðï¸';
      eyeballButton.className = 'eyeball-button';
      eyeballButton.onclick = (e) => {
        e.stopPropagation();
        showChatData(chatId);
      };
      buttonsDiv.appendChild(eyeballButton);
    }
    
    buttonsDiv.appendChild(renameButton);
    buttonsDiv.appendChild(deleteButton);
    
    chatDiv.appendChild(buttonsDiv);
    chatHistory.appendChild(chatDiv);
    
    chatDiv.onclick = () => loadChat(chatId);
  });
}

function loadChat(chatId) {
  if (currentChatId === chatId) return; // Don't reload if it's already the current chat
  currentChatId = chatId;
  const chats = JSON.parse(localStorage.getItem('aiChats')) || {};
  const chatMessages = chats[chatId].messages || [];
  const chatArea = document.getElementById('chat-area');
  chatArea.innerHTML = '';
  chatMessages.forEach(message => addMessage(message.role, message.content));
  updateChatHistory(); // Update to show the selected chat
}

function renameChat(chatId) {
  const chats = JSON.parse(localStorage.getItem('aiChats')) || {};
  const newName = prompt('Enter new name for the chat:', chats[chatId].name);
  if (newName !== null) {
    chats[chatId].name = newName;
    localStorage.setItem('aiChats', JSON.stringify(chats));
    updateChatHistory();
  }
}

function deleteChat(chatId) {
  if (confirm('Are you sure you want to delete this chat?')) {
    const chats = JSON.parse(localStorage.getItem('aiChats')) || {};
    delete chats[chatId];
    localStorage.setItem('aiChats', JSON.stringify(chats));
    if (currentChatId === chatId) {
      startNewChat();
    } else {
      updateChatHistory();
    }
  }
}

function showChatData(chatId) {
  const chats = JSON.parse(localStorage.getItem('aiChats')) || {};
  const chatData = chats[chatId];
  const totalCharCount = chatData.messages.reduce((count, message) => count + message.content.length, 0);
  
  let popupContent = `Chat ID: ${chatId}\n`;
  popupContent += `Chat Name: ${chatData.name}\n`;
  popupContent += `Total Character Count: ${totalCharCount}\n\n`;
  popupContent += `Messages:\n`;
  chatData.messages.forEach((message, index) => {
    popupContent += `\n[${index + 1}] ${message.role}: ${message.content}\n`;
  });

  document.getElementById('popupContent').textContent = popupContent;
  document.getElementById('popup').style.display = 'block';
  document.getElementById('overlay').style.display = 'block';
}

function closePopup() {
  document.getElementById('popup').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';
}

// Fetch AI models
fetch('https://api.discord.rocks/v1/models')
  .then(response => response.json())
  .then(data => {
    const select = document.getElementById('modelSelect');
    select.innerHTML = ''; // Clear loading option
    data.data.forEach(model => {
      const option = document.createElement('option');
      option.value = model.id;
      option.textContent = model.id;
      select.appendChild(option);
    });
    select.value = 'llama-3-70b-chat-turbo';
    selectedModel = 'llama-3-70b-chat-turbo';
  })
  .catch(error => console.error('Error fetching AI models:', error));

// Handle model selection
document.getElementById('modelSelect').addEventListener('change', (event) => {
  selectedModel = event.target.value;
});

// Handle send button click and Enter key press
function sendMessage() {
  const userInput = document.getElementById('userInput');
  const message = userInput.value.trim();
  if (message) {
    addMessage('user', message);
    sendMessageToAI(message);
    userInput.value = '';
  }
}

document.getElementById('sendButton').addEventListener('click', sendMessage);
document.getElementById('userInput').addEventListener('keydown', (event) => {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
});

function sendMessageToAI(message) {
  const loadingSpinner = addLoadingSpinner();
  fetch('https://api.discord.rocks/v1/chat/completions', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: selectedModel,
      messages: [
        { role: 'system', content: systemPrompt },
        ...getCurrentChatMessages(),
        { role: 'user', content: message }
      ],
      max_tokens: 150
    })
  })
  .then(response => response.json())
  .then(data => {
    loadingSpinner.remove();
    if (data.choices && data.choices.length > 0) {
      addMessage('assistant', data.choices[0].message.content);
    } else {
      addMessage('system', 'Sorry, I couldn\'t generate a response.');
    }
  })
  .catch(error => {
    loadingSpinner.remove();
    console.error('Error sending message to AI:', error);
    addMessage('system', 'Sorry, there was an error communicating with the AI.');
  });
}

function getCurrentChatMessages() {
  const chats = JSON.parse(localStorage.getItem('aiChats')) || {};
  return currentChatId && chats[currentChatId] ? chats[currentChatId].messages : [];
}

// New Chat button
document.getElementById('newChatButton').addEventListener('click', startNewChat);

// Debug button
document.getElementById('debugButton').addEventListener('click', () => {
  debugMode = !debugMode;
  updateChatHistory();
});

// Initialize
updateChatHistory();
if (!currentChatId) {
  startNewChat();
} else {
  loadChat(currentChatId);
}

// Close popup when clicking outside
document.getElementById('overlay').addEventListener('click', closePopup);
</script></textarea></body></html>');
        } else {
            notepadWindow.focus();
        }
        updateStatusBar("Popup Notepad opened");
    }
</script>
</body></html>
